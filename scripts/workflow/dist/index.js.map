{"version":3,"sources":["../src/types/adoFieldTypes.ts","../src/types/adoLinkTypes.ts","../src/types/adoWikiTypes.ts","../src/types/sfMetadataTypes.ts","../src/types/sfQueryTypes.ts","../src/adoClient.ts","../src/lib/authAzureCli.ts","../src/lib/loggerStructured.ts","../src/adoWorkItems.ts","../src/lib/retryWithBackoff.ts","../src/lib/validationSchemas.ts","../src/adoWorkItemLinks.ts","../src/adoWikiPages.ts","../src/lib/authSalesforceCli.ts","../src/sfClient.ts","../src/sfQueryExecutor.ts","../src/sfMetadataDescriber.ts","../src/sfDependencyTraverser.ts","../src/sfDependencyEnrichment.ts","../src/sfDependencyDiscovery.ts","../src/sfDependencyAnalyzers.ts","../src/workflowPrepareTicket.ts","../src/lib/configLoader.ts","../src/workflowState.ts","../src/workflowRunner.ts","../src/workflowExecutor.ts"],"sourcesContent":["/**\n * Azure DevOps Field Types\n * Strongly-typed picklist values for ADO work item fields\n */\n\n// Work Class Type picklist values\nexport type WorkClassType =\n  | 'Critical/Escalation'\n  | 'Development'\n  | 'Fixed Date Delivery'\n  | 'Maintenance/Recurring Tasks'\n  | 'Standard';\n\n// Requires QA picklist values\nexport type RequiresQA = 'Yes' | 'No';\n\n// Priority picklist values\nexport type Priority = 1 | 2 | 3 | 4;\n\n// Severity picklist values\nexport type Severity = '1 - Critical' | '2 - High' | '3 - Medium' | '4 - Low';\n\n// State values for different work item types\nexport type UserStoryState =\n  | 'New'\n  | 'Active'\n  | 'Resolved'\n  | 'Closed'\n  | 'Removed';\n\nexport type TaskState =\n  | 'New'\n  | 'Active'\n  | 'Closed'\n  | 'Removed';\n\nexport type BugState =\n  | 'New'\n  | 'Active'\n  | 'Resolved'\n  | 'Closed';\n\n// Work item types\nexport type WorkItemType =\n  | 'User Story'\n  | 'Task'\n  | 'Bug'\n  | 'Feature'\n  | 'Epic'\n  | 'Issue'\n  | 'Test Case'\n  | 'Test Plan'\n  | 'Test Suite';\n\n// Value Area picklist\nexport type ValueArea = 'Business' | 'Architectural';\n\n// Risk picklist\nexport type Risk = '1 - High' | '2 - Medium' | '3 - Low';\n\n// Reason picklist values (common across types)\nexport type CommonReason =\n  | 'New'\n  | 'Build Failure'\n  | 'Implementation Started'\n  | 'Moved to the backlog'\n  | 'Moved out of the backlog';\n\n// Area Path type (for organizational structure)\nexport type AreaPath = string;\n\n// Iteration Path type (for sprint planning)\nexport type IterationPath = string;\n\n// Constants for ADO configuration\nexport const ADO_RESOURCE_ID = '499b84ac-1321-427f-aa17-267ca6975798';\nexport const DEFAULT_ADO_ORG = 'https://dev.azure.com/UMGC';\nexport const DEFAULT_ADO_PROJECT = 'Digital Platforms';\n\n// Field path constants\nexport const ADO_FIELDS = {\n  // System fields\n  ID: 'System.Id',\n  TITLE: 'System.Title',\n  DESCRIPTION: 'System.Description',\n  STATE: 'System.State',\n  REASON: 'System.Reason',\n  AREA_PATH: 'System.AreaPath',\n  ITERATION_PATH: 'System.IterationPath',\n  WORK_ITEM_TYPE: 'System.WorkItemType',\n  ASSIGNED_TO: 'System.AssignedTo',\n  CREATED_BY: 'System.CreatedBy',\n  CREATED_DATE: 'System.CreatedDate',\n  CHANGED_BY: 'System.ChangedBy',\n  CHANGED_DATE: 'System.ChangedDate',\n  TAGS: 'System.Tags',\n  HISTORY: 'System.History',\n  \n  // Microsoft VSTS Common fields\n  STORY_POINTS: 'Microsoft.VSTS.Scheduling.StoryPoints',\n  PRIORITY: 'Microsoft.VSTS.Common.Priority',\n  SEVERITY: 'Microsoft.VSTS.Common.Severity',\n  VALUE_AREA: 'Microsoft.VSTS.Common.ValueArea',\n  RISK: 'Microsoft.VSTS.Common.Risk',\n  ACCEPTANCE_CRITERIA: 'Microsoft.VSTS.Common.AcceptanceCriteria',\n  \n  // Microsoft VSTS TCM fields (Bug-specific)\n  REPRO_STEPS: 'Microsoft.VSTS.TCM.ReproSteps',\n  SYSTEM_INFO: 'Microsoft.VSTS.TCM.SystemInfo',\n  \n  // Custom fields\n  WORK_CLASS_TYPE: 'Custom.WorkClassType',\n  REQUIRES_QA: 'Custom.RequiresQA',\n  SF_COMPONENTS: 'Custom.SFComponents',\n  TECHNICAL_NOTES: 'Custom.TechnicalNotes',\n  ROOT_CAUSE_DETAIL: 'Custom.RootCauseDetail',\n} as const;\n","/**\n * Azure DevOps Link Types\n * Type definitions for work item relationships\n */\n\n/**\n * Standard link type names\n */\nexport type LinkTypeName =\n  | 'System.LinkTypes.Hierarchy-Forward'  // Parent\n  | 'System.LinkTypes.Hierarchy-Reverse'  // Child\n  | 'System.LinkTypes.Related'            // Related\n  | 'System.LinkTypes.Dependency-Forward' // Successor\n  | 'System.LinkTypes.Dependency-Reverse' // Predecessor\n  | 'Microsoft.VSTS.Common.Affects-Forward'\n  | 'Microsoft.VSTS.Common.Affects-Reverse'\n  | 'System.LinkTypes.Duplicate-Forward'\n  | 'System.LinkTypes.Duplicate-Reverse';\n\n/**\n * User-friendly link type aliases\n */\nexport type LinkTypeAlias =\n  | 'parent'\n  | 'child'\n  | 'related'\n  | 'predecessor'\n  | 'successor'\n  | 'duplicate'\n  | 'affects';\n\n/**\n * Mapping from friendly names to system link types\n */\nexport const LINK_TYPE_MAP: Record<LinkTypeAlias, LinkTypeName> = {\n  parent: 'System.LinkTypes.Hierarchy-Forward',\n  child: 'System.LinkTypes.Hierarchy-Reverse',\n  related: 'System.LinkTypes.Related',\n  predecessor: 'System.LinkTypes.Dependency-Reverse',\n  successor: 'System.LinkTypes.Dependency-Forward',\n  duplicate: 'System.LinkTypes.Duplicate-Forward',\n  affects: 'Microsoft.VSTS.Common.Affects-Forward',\n} as const;\n\n/**\n * Reverse mapping from system link types to friendly names\n */\nexport const LINK_TYPE_REVERSE_MAP: Record<LinkTypeName, LinkTypeAlias> = {\n  'System.LinkTypes.Hierarchy-Forward': 'parent',\n  'System.LinkTypes.Hierarchy-Reverse': 'child',\n  'System.LinkTypes.Related': 'related',\n  'System.LinkTypes.Dependency-Reverse': 'predecessor',\n  'System.LinkTypes.Dependency-Forward': 'successor',\n  'System.LinkTypes.Duplicate-Forward': 'duplicate',\n  'System.LinkTypes.Duplicate-Reverse': 'duplicate',\n  'Microsoft.VSTS.Common.Affects-Forward': 'affects',\n  'Microsoft.VSTS.Common.Affects-Reverse': 'affects',\n} as const;\n\n/**\n * Options for linking work items\n */\nexport interface LinkWorkItemsOptions {\n  sourceId: number;\n  targetId: number;\n  linkType: LinkTypeAlias;\n  comment?: string;\n}\n\n/**\n * Options for getting work item relations\n */\nexport interface GetRelationsOptions {\n  workItemId: number;\n  linkTypes?: LinkTypeAlias[];\n}\n\n/**\n * Relation result\n */\nexport interface RelationResult {\n  workItemId: number;\n  relations: ParsedRelation[];\n}\n\n/**\n * Parsed relation with friendly names\n */\nexport interface ParsedRelation {\n  targetId: number;\n  linkType: LinkTypeAlias;\n  linkTypeName: LinkTypeName;\n  url: string;\n  comment?: string;\n}\n\n/**\n * Helper to resolve link type alias to system name\n */\nexport function resolveLinkType(alias: LinkTypeAlias): LinkTypeName {\n  return LINK_TYPE_MAP[alias];\n}\n\n/**\n * Helper to parse link type name to alias\n */\nexport function parseLinkType(name: string): LinkTypeAlias | undefined {\n  return LINK_TYPE_REVERSE_MAP[name as LinkTypeName];\n}\n\n/**\n * Extract work item ID from relation URL\n */\nexport function extractWorkItemIdFromUrl(url: string): number | undefined {\n  const match = /\\/workItems\\/(\\d+)$/.exec(url);\n  return match ? parseInt(match[1], 10) : undefined;\n}\n","/**\n * Azure DevOps Wiki Types\n * Type definitions for wiki operations\n */\n\n/**\n * Wiki type\n */\nexport type WikiType = 'projectWiki' | 'codeWiki';\n\n/**\n * Wiki information\n */\nexport interface Wiki {\n  id: string;\n  name: string;\n  type: WikiType;\n  url: string;\n  projectId: string;\n  repositoryId?: string;\n  mappedPath?: string;\n  version?: string;\n}\n\n/**\n * Wiki page\n */\nexport interface WikiPage {\n  id: number;\n  path: string;\n  url: string;\n  remoteUrl: string;\n  gitItemPath?: string;\n  content?: string;\n  order?: number;\n  isParentPage?: boolean;\n  subPages?: WikiPage[];\n}\n\n/**\n * Wiki page with content\n */\nexport interface WikiPageWithContent extends WikiPage {\n  content: string;\n  eTag?: string;\n}\n\n/**\n * Options for getting a wiki page\n */\nexport interface GetWikiPageOptions {\n  wikiId?: string;\n  pageId?: number;\n  path?: string;\n  includeContent?: boolean;\n  recursionLevel?: 'None' | 'OneLevel' | 'Full';\n  versionDescriptor?: {\n    version?: string;\n    versionType?: 'branch' | 'tag' | 'commit';\n  };\n}\n\n/**\n * Options for updating a wiki page\n */\nexport interface UpdateWikiPageOptions {\n  wikiId?: string;\n  pageId?: number;\n  path?: string;\n  content: string;\n  comment?: string;\n  eTag?: string;\n}\n\n/**\n * Options for creating a wiki page\n */\nexport interface CreateWikiPageOptions {\n  wikiId?: string;\n  path: string;\n  content: string;\n  comment?: string;\n}\n\n/**\n * Wiki page update result\n */\nexport interface WikiPageUpdateResult {\n  page: WikiPage;\n  eTag: string;\n}\n\n/**\n * Wiki constants\n */\nexport const WIKI_DEFAULTS = {\n  WIKI_NAME: 'Digital Platforms Wiki',\n  PROJECT: 'Digital Platforms',\n} as const;\n","/**\n * Salesforce Metadata Types\n * Type definitions for Salesforce metadata operations\n */\n\n/**\n * Entity Definition from Tooling API\n */\nexport interface EntityDefinition {\n  Id: string;\n  DurableId: string;\n  QualifiedApiName: string;\n  NamespacePrefix: string | null;\n  DeveloperName: string;\n  MasterLabel: string;\n  Label: string;\n  PluralLabel: string;\n  KeyPrefix: string;\n  IsCustomSetting: boolean;\n  IsCustomizable: boolean;\n  IsApexTriggerable: boolean;\n  IsWorkflowEnabled: boolean;\n  IsProcessEnabled: boolean;\n  IsLayoutable: boolean;\n  IsCompactLayoutable: boolean;\n  DeploymentStatus: string;\n  IsSearchable: boolean;\n  IsQueryable: boolean;\n  IsIdEnabled: boolean;\n  IsReplicateable: boolean;\n  IsRetrieveable: boolean;\n  IsCreateable: boolean;\n  IsUpdateable: boolean;\n  IsDeletable: boolean;\n  IsUndeletable: boolean;\n  IsMergeable: boolean;\n  InternalSharingModel: string;\n  ExternalSharingModel: string;\n  RunningUserEntityAccessId: string | null;\n  PublisherId: string;\n}\n\n/**\n * Field Definition from Tooling API\n */\nexport interface FieldDefinition {\n  Id: string;\n  DurableId: string;\n  QualifiedApiName: string;\n  EntityDefinitionId: string;\n  NamespacePrefix: string | null;\n  DeveloperName: string;\n  MasterLabel: string;\n  Label: string;\n  Length: number;\n  DataType: string;\n  ValueTypeId: string;\n  ReferenceTo: {\n    referenceTo: string[];\n  } | null;\n  ReferenceTargetField: string | null;\n  IsCompound: boolean;\n  IsHighScaleNumber: boolean;\n  IsHtmlFormatted: boolean;\n  IsNameField: boolean;\n  IsNillable: boolean;\n  IsCalculated: boolean;\n  IsApiFilterable: boolean;\n  IsApiSortable: boolean;\n  IsApiGroupable: boolean;\n  IsPolymorphicForeignKey: boolean;\n  IsAiPredictionField: boolean;\n  IsCompactLayoutable: boolean;\n  Precision: number;\n  Scale: number;\n  IsFieldHistoryTracked: boolean;\n  IsIndexed: boolean;\n  IsUnique: boolean;\n  IsDeprecatedAndHidden: boolean;\n  ControllingFieldDefinitionId: string | null;\n  BusinessOwnerId: string | null;\n  BusinessStatus: string | null;\n  ComplianceGroup: string | null;\n  SecurityClassification: string | null;\n  Description: string | null;\n  InlineHelpText: string | null;\n  RelationshipName: string | null;\n  LastModifiedDate: string;\n  LastModifiedById: string;\n  PublisherId: string;\n  RunningUserFieldAccessId: string | null;\n}\n\n/**\n * Custom Field from Tooling API\n */\nexport interface CustomField {\n  Id: string;\n  DeveloperName: string;\n  NamespacePrefix: string | null;\n  TableEnumOrId: string;\n  FullName: string;\n  Metadata: CustomFieldMetadata;\n}\n\n/**\n * Custom Field Metadata\n */\nexport interface CustomFieldMetadata {\n  fullName: string;\n  label: string;\n  description: string | null;\n  type: string;\n  length?: number;\n  precision?: number;\n  scale?: number;\n  required?: boolean;\n  unique?: boolean;\n  externalId?: boolean;\n  trackHistory?: boolean;\n  trackFeedHistory?: boolean;\n  inlineHelpText?: string | null;\n  defaultValue?: string | null;\n  formula?: string | null;\n  referenceTo?: string;\n  relationshipLabel?: string;\n  relationshipName?: string;\n  deleteConstraint?: string;\n  valueSet?: ValueSet;\n}\n\n/**\n * Value Set for picklists\n */\nexport interface ValueSet {\n  restricted?: boolean;\n  valueSetDefinition?: {\n    sorted: boolean;\n    value: PicklistValue[];\n  };\n  controllingField?: string;\n}\n\n/**\n * Picklist Value\n */\nexport interface PicklistValue {\n  fullName: string;\n  label: string;\n  default?: boolean;\n  isActive?: boolean;\n  color?: string;\n  description?: string;\n}\n\n/**\n * Apex Class metadata\n */\nexport interface ApexClass {\n  Id: string;\n  Name: string;\n  NamespacePrefix: string | null;\n  ApiVersion: number;\n  Status: string;\n  IsValid: boolean;\n  LengthWithoutComments: number;\n  Body?: string;\n  SymbolTable?: SymbolTable;\n}\n\n/**\n * Symbol Table from Apex Class\n */\nexport interface SymbolTable {\n  name: string;\n  tableDeclaration: {\n    name: string;\n    modifiers: string[];\n    type: string;\n  };\n  variables: SymbolTableVariable[];\n  methods: SymbolTableMethod[];\n  innerClasses?: SymbolTable[];\n}\n\n/**\n * Symbol Table Variable\n */\nexport interface SymbolTableVariable {\n  name: string;\n  type: string;\n  modifiers: string[];\n}\n\n/**\n * Symbol Table Method\n */\nexport interface SymbolTableMethod {\n  name: string;\n  returnType: string;\n  modifiers: string[];\n  parameters: Array<{\n    name: string;\n    type: string;\n  }>;\n}\n\n/**\n * Apex Trigger metadata\n */\nexport interface ApexTrigger {\n  Id: string;\n  Name: string;\n  NamespacePrefix: string | null;\n  TableEnumOrId: string;\n  ApiVersion: number;\n  Status: string;\n  IsValid: boolean;\n  LengthWithoutComments: number;\n  UsageBeforeInsert: boolean;\n  UsageAfterInsert: boolean;\n  UsageBeforeUpdate: boolean;\n  UsageAfterUpdate: boolean;\n  UsageBeforeDelete: boolean;\n  UsageAfterDelete: boolean;\n  UsageAfterUndelete: boolean;\n  UsageIsBulk: boolean;\n  Body?: string;\n}\n\n/**\n * Validation Rule\n */\nexport interface ValidationRule {\n  Id: string;\n  ValidationName: string;\n  EntityDefinitionId: string;\n  Active: boolean;\n  Description: string | null;\n  ErrorDisplayField: string | null;\n  ErrorMessage: string;\n  FullName: string;\n  Metadata: {\n    active: boolean;\n    description: string | null;\n    errorConditionFormula: string;\n    errorDisplayField: string | null;\n    errorMessage: string;\n    fullName: string;\n  };\n}\n\n/**\n * Flow metadata\n */\nexport interface Flow {\n  Id: string;\n  DeveloperName: string;\n  MasterLabel: string;\n  NamespacePrefix: string | null;\n  ApiVersion: number;\n  ProcessType: string;\n  Status: string;\n  Description: string | null;\n  TriggerType: string | null;\n  TriggerObjectOrEvent: string | null;\n  RecordTriggerType: string | null;\n  IsActive: boolean;\n  IsTemplate: boolean;\n  RunInMode: string;\n  LastModifiedDate: string;\n  LastModifiedById: string;\n}\n\n/**\n * Describe SObject result\n */\nexport interface DescribeSObjectResult {\n  name: string;\n  label: string;\n  labelPlural: string;\n  keyPrefix: string;\n  custom: boolean;\n  customSetting: boolean;\n  createable: boolean;\n  updateable: boolean;\n  deletable: boolean;\n  queryable: boolean;\n  searchable: boolean;\n  layoutable: boolean;\n  triggerable: boolean;\n  fields: DescribeFieldResult[];\n  recordTypeInfos?: RecordTypeInfo[];\n  childRelationships?: ChildRelationship[];\n}\n\n/**\n * Describe Field result\n */\nexport interface DescribeFieldResult {\n  name: string;\n  label: string;\n  type: string;\n  length: number;\n  precision?: number;\n  scale?: number;\n  nillable: boolean;\n  unique: boolean;\n  createable: boolean;\n  updateable: boolean;\n  filterable: boolean;\n  sortable: boolean;\n  groupable: boolean;\n  custom: boolean;\n  calculated: boolean;\n  formulaTreatNullNumberAsZero?: boolean;\n  defaultValue?: unknown;\n  inlineHelpText?: string;\n  picklistValues?: PicklistEntry[];\n  referenceTo?: string[];\n  relationshipName?: string;\n  relationshipOrder?: number;\n}\n\n/**\n * Picklist Entry\n */\nexport interface PicklistEntry {\n  value: string;\n  label: string;\n  active: boolean;\n  defaultValue: boolean;\n}\n\n/**\n * Record Type Info\n */\nexport interface RecordTypeInfo {\n  recordTypeId: string;\n  name: string;\n  developerName: string;\n  available: boolean;\n  master: boolean;\n  defaultRecordTypeMapping: boolean;\n}\n\n/**\n * Child Relationship\n */\nexport interface ChildRelationship {\n  childSObject: string;\n  field: string;\n  relationshipName: string;\n  cascadeDelete: boolean;\n  deprecatedAndHidden: boolean;\n  junctionIdListNames?: string[];\n  junctionReferenceTo?: string[];\n  restrictedDelete: boolean;\n}\n\n/**\n * Salesforce defaults\n */\nexport const SF_DEFAULTS = {\n  ORG_ALIAS: 'production',\n  API_VERSION: '59.0',\n} as const;\n","/**\n * Salesforce Query Types\n * Type definitions for SOQL and Tooling API queries\n */\n\n/**\n * Generic query result from Salesforce\n */\nexport interface QueryResult<T = Record<string, unknown>> {\n  done: boolean;\n  totalSize: number;\n  records: T[];\n  nextRecordsUrl?: string;\n}\n\n/**\n * Tooling API query result\n */\nexport interface ToolingQueryResult<T = Record<string, unknown>> extends QueryResult<T> {\n  entityTypeName?: string;\n}\n\n/**\n * Query options\n */\nexport interface QueryOptions {\n  query: string;\n  useToolingApi?: boolean;\n  allRows?: boolean;\n  maxRecords?: number;\n}\n\n/**\n * Query execution result with metadata\n */\nexport interface QueryExecutionResult<T = Record<string, unknown>> {\n  success: boolean;\n  data: QueryResult<T>;\n  queryLocator?: string;\n  executionTime?: number;\n  error?: string;\n}\n\n/**\n * Batch query request\n */\nexport interface BatchQueryRequest {\n  queries: Array<{\n    name: string;\n    query: string;\n    useToolingApi?: boolean;\n  }>;\n}\n\n/**\n * Batch query result\n */\nexport interface BatchQueryResult {\n  results: Record<string, QueryExecutionResult>;\n  totalExecutionTime: number;\n  errors: Array<{\n    name: string;\n    error: string;\n  }>;\n}\n\n/**\n * Common Tooling API entities that can be queried\n */\nexport type ToolingEntity =\n  | 'ApexClass'\n  | 'ApexTrigger'\n  | 'ApexPage'\n  | 'ApexComponent'\n  | 'AuraDefinitionBundle'\n  | 'LightningComponentBundle'\n  | 'CustomField'\n  | 'CustomObject'\n  | 'EntityDefinition'\n  | 'FieldDefinition'\n  | 'Flow'\n  | 'FlowDefinition'\n  | 'ValidationRule'\n  | 'WorkflowRule'\n  | 'CustomTab'\n  | 'CustomApplication'\n  | 'Layout'\n  | 'Profile'\n  | 'PermissionSet'\n  | 'RecordType';\n\n/**\n * SOQL Query Builder options\n */\nexport interface SOQLBuilderOptions {\n  object: string;\n  fields: string[];\n  where?: string;\n  orderBy?: string;\n  limit?: number;\n  offset?: number;\n  includeDeleted?: boolean;\n}\n\n/**\n * Build a SOQL query from options\n */\nexport function buildSOQL(options: SOQLBuilderOptions): string {\n  const { object, fields, where, orderBy, limit, offset, includeDeleted } = options;\n  \n  let query = `SELECT ${fields.join(', ')} FROM ${object}`;\n  \n  if (where) {\n    query += ` WHERE ${where}`;\n  }\n  \n  if (orderBy) {\n    query += ` ORDER BY ${orderBy}`;\n  }\n  \n  if (limit !== undefined) {\n    query += ` LIMIT ${limit}`;\n  }\n  \n  if (offset !== undefined) {\n    query += ` OFFSET ${offset}`;\n  }\n  \n  if (includeDeleted) {\n    query += ' ALL ROWS';\n  }\n  \n  return query;\n}\n","/**\n * Azure DevOps Client\n * Creates authenticated connections to Azure DevOps\n */\n\nimport * as azdev from 'azure-devops-node-api';\nimport type { IWorkItemTrackingApi } from 'azure-devops-node-api/WorkItemTrackingApi.js';\nimport type { IWikiApi } from 'azure-devops-node-api/WikiApi.js';\nimport type { ICoreApi } from 'azure-devops-node-api/CoreApi.js';\nimport type { IGitApi } from 'azure-devops-node-api/GitApi.js';\nimport { getAzureBearerToken, validateAzureAuth } from './lib/authAzureCli.js';\nimport { DEFAULT_ADO_ORG, DEFAULT_ADO_PROJECT } from './types/adoFieldTypes.js';\nimport { logInfo, logDebug } from './lib/loggerStructured.js';\n\n/**\n * ADO connection configuration\n */\nexport interface AdoConnectionConfig {\n  /** Azure DevOps organization URL (default: https://dev.azure.com/UMGC) */\n  orgUrl?: string;\n  /** Project name (default: Digital Platforms) */\n  project?: string;\n  /** Skip auth validation (for testing) */\n  skipAuthValidation?: boolean;\n}\n\n/**\n * ADO connection with APIs\n */\nexport interface AdoConnection {\n  /** The WebApi connection */\n  connection: azdev.WebApi;\n  /** Organization URL */\n  orgUrl: string;\n  /** Project name */\n  project: string;\n  /** Get Work Item Tracking API */\n  getWorkItemTrackingApi: () => Promise<IWorkItemTrackingApi>;\n  /** Get Wiki API */\n  getWikiApi: () => Promise<IWikiApi>;\n  /** Get Core API */\n  getCoreApi: () => Promise<ICoreApi>;\n  /** Get Git API */\n  getGitApi: () => Promise<IGitApi>;\n}\n\n/**\n * Cached connection to avoid re-creating for each operation\n */\nlet cachedConnection: AdoConnection | null = null;\nlet cachedConfig: AdoConnectionConfig | null = null;\n\n/**\n * Check if config has changed\n */\nfunction configChanged(config: AdoConnectionConfig): boolean {\n  if (!cachedConfig) return true;\n  return (\n    config.orgUrl !== cachedConfig.orgUrl ||\n    config.project !== cachedConfig.project\n  );\n}\n\n/**\n * Create an authenticated connection to Azure DevOps\n * \n * @param config - Connection configuration\n * @returns ADO connection with APIs\n */\nexport async function createAdoConnection(\n  config: AdoConnectionConfig = {}\n): Promise<AdoConnection> {\n  const orgUrl = config.orgUrl ?? DEFAULT_ADO_ORG;\n  const project = config.project ?? DEFAULT_ADO_PROJECT;\n\n  // Return cached connection if config hasn't changed\n  if (cachedConnection && !configChanged(config)) {\n    logDebug('Using cached ADO connection');\n    return cachedConnection;\n  }\n\n  logInfo(`Creating ADO connection to ${orgUrl}`);\n\n  // Validate Azure CLI auth\n  if (!config.skipAuthValidation) {\n    validateAzureAuth();\n  }\n\n  // Get bearer token from Azure CLI\n  const token = getAzureBearerToken();\n  \n  // Create auth handler with bearer token\n  const authHandler = azdev.getBearerHandler(token);\n  \n  // Create connection\n  const connection = new azdev.WebApi(orgUrl, authHandler);\n\n  // Create the connection object\n  const adoConnection: AdoConnection = {\n    connection,\n    orgUrl,\n    project,\n    getWorkItemTrackingApi: () => connection.getWorkItemTrackingApi(),\n    getWikiApi: () => connection.getWikiApi(),\n    getCoreApi: () => connection.getCoreApi(),\n    getGitApi: () => connection.getGitApi(),\n  };\n\n  // Cache the connection\n  cachedConnection = adoConnection;\n  cachedConfig = { orgUrl, project };\n\n  logDebug('ADO connection created successfully');\n  return adoConnection;\n}\n\n/**\n * Clear the cached connection (useful for testing or forced refresh)\n */\nexport function clearAdoConnectionCache(): void {\n  cachedConnection = null;\n  cachedConfig = null;\n}\n\n/**\n * Get the Work Item Tracking API\n * Convenience function that creates connection if needed\n */\nexport async function getWorkItemTrackingApi(\n  config?: AdoConnectionConfig\n): Promise<IWorkItemTrackingApi> {\n  const conn = await createAdoConnection(config);\n  return conn.getWorkItemTrackingApi();\n}\n\n/**\n * Get the Wiki API\n * Convenience function that creates connection if needed\n */\nexport async function getWikiApi(\n  config?: AdoConnectionConfig\n): Promise<IWikiApi> {\n  const conn = await createAdoConnection(config);\n  return conn.getWikiApi();\n}\n\n/**\n * Get the Core API\n * Convenience function that creates connection if needed\n */\nexport async function getCoreApi(\n  config?: AdoConnectionConfig\n): Promise<ICoreApi> {\n  const conn = await createAdoConnection(config);\n  return conn.getCoreApi();\n}\n","/**\n * Azure CLI Authentication\n * Provides bearer token authentication using Azure CLI\n */\n\nimport { execSync } from 'child_process';\nimport { ADO_RESOURCE_ID } from '../types/adoFieldTypes.js';\n\n/**\n * Cache for bearer tokens to avoid repeated CLI calls\n */\ninterface TokenCache {\n  token: string;\n  expiresAt: number;\n}\n\nlet tokenCache: TokenCache | null = null;\nconst TOKEN_EXPIRY_BUFFER_MS = 5 * 60 * 1000; // 5 minutes before expiry\n\n/**\n * Get a bearer token for Azure DevOps using Azure CLI\n * \n * @returns Bearer token string\n * @throws Error if Azure CLI is not authenticated\n */\nexport function getAzureBearerToken(): string {\n  // Check cache first\n  if (tokenCache && Date.now() < tokenCache.expiresAt - TOKEN_EXPIRY_BUFFER_MS) {\n    return tokenCache.token;\n  }\n\n  try {\n    // Get token with expiry info\n    const result = execSync(\n      `az account get-access-token --resource ${ADO_RESOURCE_ID} --query \"{token:accessToken,expiresOn:expiresOn}\" -o json`,\n      { encoding: 'utf-8', stdio: ['pipe', 'pipe', 'pipe'] }\n    );\n\n    const parsed = JSON.parse(result) as { token: string; expiresOn: string };\n    const expiresAt = new Date(parsed.expiresOn).getTime();\n\n    // Cache the token\n    tokenCache = {\n      token: parsed.token,\n      expiresAt,\n    };\n\n    return parsed.token;\n  } catch (error) {\n    // Clear cache on error\n    tokenCache = null;\n\n    if (error instanceof Error) {\n      if (error.message.includes('az: command not found') || \n          error.message.includes('is not recognized')) {\n        throw new Error(\n          'Azure CLI is not installed. Please install it from: https://docs.microsoft.com/en-us/cli/azure/install-azure-cli'\n        );\n      }\n      if (error.message.includes('AADSTS') || \n          error.message.includes('Please run')) {\n        throw new Error(\n          'Azure CLI is not authenticated. Please run: az login'\n        );\n      }\n      throw new Error(`Failed to get Azure bearer token: ${error.message}`);\n    }\n    throw error;\n  }\n}\n\n/**\n * Validate that Azure CLI is authenticated\n * \n * @throws Error if Azure CLI is not installed or not authenticated\n */\nexport function validateAzureAuth(): void {\n  try {\n    execSync('az account show', { \n      encoding: 'utf-8', \n      stdio: ['pipe', 'pipe', 'pipe'] \n    });\n  } catch (error) {\n    if (error instanceof Error) {\n      if (error.message.includes('az: command not found') || \n          error.message.includes('is not recognized')) {\n        throw new Error(\n          'Azure CLI is not installed. Please install it from: https://docs.microsoft.com/en-us/cli/azure/install-azure-cli'\n        );\n      }\n      throw new Error(\n        'Azure CLI is not authenticated. Please run: az login'\n      );\n    }\n    throw error;\n  }\n}\n\n/**\n * Get the current Azure account information\n * \n * @returns Account information including subscription and tenant\n */\nexport function getAzureAccountInfo(): AzureAccountInfo {\n  validateAzureAuth();\n\n  const result = execSync(\n    'az account show --query \"{subscription:name,subscriptionId:id,tenantId:tenantId,user:user.name}\" -o json',\n    { encoding: 'utf-8', stdio: ['pipe', 'pipe', 'pipe'] }\n  );\n\n  return JSON.parse(result) as AzureAccountInfo;\n}\n\n/**\n * Azure account information\n */\nexport interface AzureAccountInfo {\n  subscription: string;\n  subscriptionId: string;\n  tenantId: string;\n  user: string;\n}\n\n/**\n * Clear the token cache (useful for testing or forced refresh)\n */\nexport function clearTokenCache(): void {\n  tokenCache = null;\n}\n","/**\n * Structured Logger\n * JSON-based logging for consistent output\n */\n\n/**\n * Log levels\n */\nexport type LogLevel = 'debug' | 'info' | 'warn' | 'error';\n\n/**\n * Log entry structure\n */\nexport interface LogEntry {\n  timestamp: string;\n  level: LogLevel;\n  message: string;\n  data?: unknown;\n  context?: LogContext;\n}\n\n/**\n * Log context for tracking operations\n */\nexport interface LogContext {\n  operation?: string;\n  workItemId?: number;\n  sfOrg?: string;\n  duration?: number;\n  [key: string]: unknown;\n}\n\n/**\n * Logger configuration\n */\nexport interface LoggerConfig {\n  minLevel: LogLevel;\n  jsonOutput: boolean;\n  includeTimestamp: boolean;\n  context?: LogContext;\n  /** When true, suppress all log output (useful for CLI --json mode) */\n  silent: boolean;\n  /** When true, output to stderr instead of stdout */\n  useStderr: boolean;\n}\n\n/**\n * Log level priority (higher = more important)\n */\nconst LOG_LEVEL_PRIORITY: Record<LogLevel, number> = {\n  debug: 0,\n  info: 1,\n  warn: 2,\n  error: 3,\n};\n\n/**\n * Default logger configuration\n */\nlet config: LoggerConfig = {\n  minLevel: 'info',\n  jsonOutput: false,\n  includeTimestamp: true,\n  silent: false,\n  useStderr: false,\n};\n\n/**\n * Configure the logger\n */\nexport function configureLogger(newConfig: Partial<LoggerConfig>): void {\n  config = { ...config, ...newConfig };\n}\n\n/**\n * Get current logger configuration\n */\nexport function getLoggerConfig(): LoggerConfig {\n  return { ...config };\n}\n\n/**\n * Check if a log level should be output\n */\nfunction shouldLog(level: LogLevel): boolean {\n  if (config.silent) return false;\n  return LOG_LEVEL_PRIORITY[level] >= LOG_LEVEL_PRIORITY[config.minLevel];\n}\n\n/**\n * Output a log message to the appropriate stream\n */\nfunction output(level: LogLevel, message: string): void {\n  if (config.useStderr) {\n    console.error(message);\n  } else {\n    switch (level) {\n      case 'debug':\n        console.debug(message);\n        break;\n      case 'info':\n        console.info(message);\n        break;\n      case 'warn':\n        console.warn(message);\n        break;\n      case 'error':\n        console.error(message);\n        break;\n    }\n  }\n}\n\n/**\n * Format a log entry\n */\nfunction formatEntry(entry: LogEntry): string {\n  if (config.jsonOutput) {\n    return JSON.stringify(entry);\n  }\n\n  const parts: string[] = [];\n\n  if (config.includeTimestamp) {\n    parts.push(`[${entry.timestamp}]`);\n  }\n\n  parts.push(`[${entry.level.toUpperCase()}]`);\n  parts.push(entry.message);\n\n  if (entry.data !== undefined) {\n    if (typeof entry.data === 'object') {\n      parts.push(JSON.stringify(entry.data, null, 2));\n    } else {\n      parts.push(String(entry.data));\n    }\n  }\n\n  return parts.join(' ');\n}\n\n/**\n * Create a log entry\n */\nfunction createEntry(level: LogLevel, message: string, data?: unknown, context?: LogContext): LogEntry {\n  return {\n    timestamp: new Date().toISOString(),\n    level,\n    message,\n    data,\n    context: context ?? config.context,\n  };\n}\n\n/**\n * Log a debug message\n */\nexport function logDebug(message: string, data?: unknown, context?: LogContext): void {\n  if (!shouldLog('debug')) return;\n  const entry = createEntry('debug', message, data, context);\n  output('debug', formatEntry(entry));\n}\n\n/**\n * Log an info message\n */\nexport function logInfo(message: string, data?: unknown, context?: LogContext): void {\n  if (!shouldLog('info')) return;\n  const entry = createEntry('info', message, data, context);\n  output('info', formatEntry(entry));\n}\n\n/**\n * Log a warning message\n */\nexport function logWarn(message: string, data?: unknown, context?: LogContext): void {\n  if (!shouldLog('warn')) return;\n  const entry = createEntry('warn', message, data, context);\n  output('warn', formatEntry(entry));\n}\n\n/**\n * Log an error message\n */\nexport function logError(message: string, data?: unknown, context?: LogContext): void {\n  if (!shouldLog('error')) return;\n  const entry = createEntry('error', message, data, context);\n  output('error', formatEntry(entry));\n}\n\n/**\n * Log an event (always info level, but with structured event data)\n */\nexport function logEvent(event: string, data?: Record<string, unknown>, context?: LogContext): void {\n  if (!shouldLog('info')) return;\n  const entry = createEntry('info', `[EVENT] ${event}`, data, context);\n  output('info', formatEntry(entry));\n}\n\n/**\n * Create a child logger with additional context\n */\nexport function createChildLogger(additionalContext: LogContext): ChildLogger {\n  return {\n    debug: (message: string, data?: unknown) => logDebug(message, data, additionalContext),\n    info: (message: string, data?: unknown) => logInfo(message, data, additionalContext),\n    warn: (message: string, data?: unknown) => logWarn(message, data, additionalContext),\n    error: (message: string, data?: unknown) => logError(message, data, additionalContext),\n    event: (event: string, data?: Record<string, unknown>) => logEvent(event, data, additionalContext),\n  };\n}\n\n/**\n * Child logger interface\n */\nexport interface ChildLogger {\n  debug: (message: string, data?: unknown) => void;\n  info: (message: string, data?: unknown) => void;\n  warn: (message: string, data?: unknown) => void;\n  error: (message: string, data?: unknown) => void;\n  event: (event: string, data?: Record<string, unknown>) => void;\n}\n\n/**\n * Timer utility for measuring operation duration\n */\nexport function createTimer(): Timer {\n  const startTime = Date.now();\n  return {\n    elapsed: () => Date.now() - startTime,\n    elapsedSeconds: () => (Date.now() - startTime) / 1000,\n    log: (operation: string, level: LogLevel = 'info') => {\n      const duration = Date.now() - startTime;\n      const message = `${operation} completed in ${duration}ms`;\n      const context: LogContext = { operation, duration };\n      \n      switch (level) {\n        case 'debug': logDebug(message, undefined, context); break;\n        case 'info': logInfo(message, undefined, context); break;\n        case 'warn': logWarn(message, undefined, context); break;\n        case 'error': logError(message, undefined, context); break;\n      }\n    },\n  };\n}\n\n/**\n * Timer interface\n */\nexport interface Timer {\n  elapsed: () => number;\n  elapsedSeconds: () => number;\n  log: (operation: string, level?: LogLevel) => void;\n}\n","/**\n * Azure DevOps Work Items\n * Operations for getting, creating, updating, and searching work items\n */\n\nimport { Operation, type JsonPatchOperation } from 'azure-devops-node-api/interfaces/common/VSSInterfaces.js';\nimport type { \n  WorkItem as AdoWorkItem,\n  WorkItemExpand,\n  Wiql,\n} from 'azure-devops-node-api/interfaces/WorkItemTrackingInterfaces.js';\nimport { createAdoConnection, type AdoConnectionConfig } from './adoClient.js';\nimport { retryWithBackoff, RETRY_PRESETS } from './lib/retryWithBackoff.js';\nimport { logInfo, logDebug, createTimer } from './lib/loggerStructured.js';\nimport { validate, GetWorkItemOptionsSchema, CreateWorkItemOptionsSchema, UpdateWorkItemOptionsSchema, SearchWorkItemsOptionsSchema } from './lib/validationSchemas.js';\nimport type {\n  WorkItem,\n  WorkItemWithComments,\n  WorkItemFields,\n  GetWorkItemOptions,\n  CreateWorkItemOptions,\n  UpdateWorkItemOptions,\n  SearchWorkItemsOptions,\n  WorkItemSearchResult,\n} from './types/adoWorkItemTypes.js';\nimport { ADO_FIELDS } from './types/adoFieldTypes.js';\n\n/**\n * Convert ADO API work item to our WorkItem type\n */\nfunction convertWorkItem(item: AdoWorkItem): WorkItem {\n  return {\n    id: item.id ?? 0,\n    rev: item.rev ?? 0,\n    url: item.url ?? '',\n    fields: (item.fields ?? {}) as WorkItemFields,\n    relations: item.relations?.map(r => ({\n      rel: r.rel ?? '',\n      url: r.url ?? '',\n      attributes: r.attributes ?? {},\n    })) ?? [],\n    _links: item._links as Record<string, { href: string }> | undefined,\n  };\n}\n\n/**\n * Map expand option to API enum\n */\nfunction mapExpandOption(expand?: string): WorkItemExpand | undefined {\n  if (!expand) return undefined;\n  const expandMap: Record<string, WorkItemExpand> = {\n    'None': 0,\n    'Relations': 1,\n    'Fields': 2,\n    'Links': 3,\n    'All': 4,\n  };\n  return expandMap[expand];\n}\n\n/**\n * Get a work item by ID\n * \n * @param id - Work item ID\n * @param options - Get options\n * @param config - Connection config\n * @returns Work item\n */\nexport async function getWorkItem(\n  id: number,\n  options: GetWorkItemOptions = {},\n  config?: AdoConnectionConfig\n): Promise<WorkItemWithComments> {\n  const timer = createTimer();\n  const validatedOptions = validate(GetWorkItemOptionsSchema, options);\n  \n  logInfo(`Getting work item ${id}`, { expand: validatedOptions.expand });\n\n  const conn = await createAdoConnection(config);\n  const witApi = await conn.getWorkItemTrackingApi();\n\n  const workItem = await retryWithBackoff(\n    () => witApi.getWorkItem(\n      id,\n      validatedOptions.fields,\n      undefined,\n      mapExpandOption(validatedOptions.expand),\n      conn.project\n    ),\n    { ...RETRY_PRESETS.standard, operationName: `getWorkItem(${id})` }\n  );\n\n  if (!workItem) {\n    throw new Error(`Work item ${id} not found`);\n  }\n\n  const result: WorkItemWithComments = convertWorkItem(workItem);\n\n  // Fetch comments if requested\n  if (validatedOptions.includeComments) {\n    logDebug(`Fetching comments for work item ${id}`);\n    const comments = await retryWithBackoff(\n      () => witApi.getComments(conn.project, id),\n      { ...RETRY_PRESETS.standard, operationName: `getComments(${id})` }\n    );\n    \n    result.comments = comments.comments?.map(c => ({\n      id: c.id ?? 0,\n      workItemId: c.workItemId ?? id,\n      text: c.text ?? '',\n      createdBy: {\n        displayName: c.createdBy?.displayName ?? '',\n        url: c.createdBy?.url ?? '',\n        id: c.createdBy?.id ?? '',\n        uniqueName: c.createdBy?.uniqueName ?? '',\n      },\n      createdDate: c.createdDate?.toISOString() ?? '',\n      format: 'html',\n    })) ?? [];\n  }\n\n  timer.log(`getWorkItem(${id})`);\n  return result;\n}\n\n/**\n * Update a work item\n * \n * @param id - Work item ID\n * @param options - Update options\n * @param config - Connection config\n * @returns Updated work item\n */\nexport async function updateWorkItem(\n  id: number,\n  options: UpdateWorkItemOptions,\n  config?: AdoConnectionConfig\n): Promise<WorkItem> {\n  const timer = createTimer();\n  const validatedOptions = validate(UpdateWorkItemOptionsSchema, options);\n\n  logInfo(`Updating work item ${id}`);\n\n  // Build patch document\n  const patchDoc: JsonPatchOperation[] = [];\n\n  // Add fields from options\n  if (validatedOptions.fields) {\n    for (const [key, value] of Object.entries(validatedOptions.fields)) {\n      if (value !== undefined) {\n        patchDoc.push({\n          op: Operation.Add,\n          path: `/fields/${key}`,\n          value,\n        });\n      }\n    }\n  }\n\n\n  // Add comment/history if specified\n  if (validatedOptions.comment) {\n    patchDoc.push({\n      op: Operation.Add,\n      path: `/fields/${ADO_FIELDS.HISTORY}`,\n      value: validatedOptions.comment,\n    });\n  }\n\n  if (patchDoc.length === 0) {\n    logDebug('No updates to apply');\n    return getWorkItem(id, {}, config);\n  }\n\n  logDebug(`Applying ${patchDoc.length} patch operations`);\n\n  const conn = await createAdoConnection(config);\n  const witApi = await conn.getWorkItemTrackingApi();\n\n  const updatedItem = await retryWithBackoff(\n    () => witApi.updateWorkItem(\n      undefined, // customHeaders\n      patchDoc,\n      id,\n      conn.project\n    ),\n    { ...RETRY_PRESETS.standard, operationName: `updateWorkItem(${id})` }\n  );\n\n  if (!updatedItem) {\n    throw new Error(`Failed to update work item ${id}`);\n  }\n\n  timer.log(`updateWorkItem(${id})`);\n  return convertWorkItem(updatedItem);\n}\n\n/**\n * Create a new work item\n * \n * @param options - Create options\n * @param config - Connection config\n * @returns Created work item\n */\nexport async function createWorkItem(\n  options: CreateWorkItemOptions,\n  config?: AdoConnectionConfig\n): Promise<WorkItem> {\n  const timer = createTimer();\n  const validatedOptions = validate(CreateWorkItemOptionsSchema, options);\n\n  logInfo(`Creating ${validatedOptions.type} work item: ${validatedOptions.title}`);\n\n  // Build patch document\n  const patchDoc: JsonPatchOperation[] = [];\n\n  // Required: Title\n  patchDoc.push({\n    op: Operation.Add,\n    path: `/fields/${ADO_FIELDS.TITLE}`,\n    value: validatedOptions.title,\n  });\n\n  // Optional fields\n  if (validatedOptions.description) {\n    patchDoc.push({\n      op: Operation.Add,\n      path: `/fields/${ADO_FIELDS.DESCRIPTION}`,\n      value: validatedOptions.description,\n    });\n  }\n\n  if (validatedOptions.areaPath) {\n    patchDoc.push({\n      op: Operation.Add,\n      path: `/fields/${ADO_FIELDS.AREA_PATH}`,\n      value: validatedOptions.areaPath,\n    });\n  }\n\n  if (validatedOptions.iterationPath) {\n    patchDoc.push({\n      op: Operation.Add,\n      path: `/fields/${ADO_FIELDS.ITERATION_PATH}`,\n      value: validatedOptions.iterationPath,\n    });\n  }\n\n  if (validatedOptions.assignedTo) {\n    patchDoc.push({\n      op: Operation.Add,\n      path: `/fields/${ADO_FIELDS.ASSIGNED_TO}`,\n      value: validatedOptions.assignedTo,\n    });\n  }\n\n  if (validatedOptions.tags && validatedOptions.tags.length > 0) {\n    patchDoc.push({\n      op: Operation.Add,\n      path: `/fields/${ADO_FIELDS.TAGS}`,\n      value: validatedOptions.tags.join('; '),\n    });\n  }\n\n  // Add parent link if specified\n  if (validatedOptions.parentId) {\n    const conn = await createAdoConnection(config);\n    patchDoc.push({\n      op: Operation.Add,\n      path: '/relations/-',\n      value: {\n        rel: 'System.LinkTypes.Hierarchy-Reverse',\n        url: `${conn.orgUrl}/${conn.project}/_apis/wit/workItems/${validatedOptions.parentId}`,\n      },\n    });\n  }\n\n  // Add any additional fields\n  if (validatedOptions.additionalFields) {\n    for (const [key, value] of Object.entries(validatedOptions.additionalFields)) {\n      if (value !== undefined && !key.startsWith('System.')) {\n        patchDoc.push({\n          op: Operation.Add,\n          path: `/fields/${key}`,\n          value,\n        });\n      }\n    }\n  }\n\n  const conn = await createAdoConnection(config);\n  const witApi = await conn.getWorkItemTrackingApi();\n\n  const createdItem = await retryWithBackoff(\n    () => witApi.createWorkItem(\n      undefined, // customHeaders\n      patchDoc,\n      conn.project,\n      validatedOptions.type\n    ),\n    { ...RETRY_PRESETS.standard, operationName: 'createWorkItem' }\n  );\n\n  if (!createdItem) {\n    throw new Error('Failed to create work item');\n  }\n\n  logInfo(`Created work item ${createdItem.id}`);\n  timer.log('createWorkItem');\n  return convertWorkItem(createdItem);\n}\n\n/**\n * Search for work items\n * \n * @param options - Search options\n * @param config - Connection config\n * @returns Search results\n */\nexport async function searchWorkItems(\n  options: SearchWorkItemsOptions,\n  config?: AdoConnectionConfig\n): Promise<WorkItemSearchResult> {\n  const timer = createTimer();\n  const validatedOptions = validate(SearchWorkItemsOptionsSchema, options);\n\n  logInfo('Searching work items', validatedOptions);\n\n  const conn = await createAdoConnection(config);\n  const witApi = await conn.getWorkItemTrackingApi();\n\n  let wiqlQuery: string;\n\n  if (validatedOptions.wiql) {\n    // Use provided WIQL directly\n    wiqlQuery = validatedOptions.wiql;\n  } else {\n    // Build WIQL from options\n    const conditions: string[] = [];\n\n    if (validatedOptions.searchText) {\n      conditions.push(`[System.Title] CONTAINS '${validatedOptions.searchText}'`);\n    }\n\n    if (validatedOptions.workItemType) {\n      conditions.push(`[System.WorkItemType] = '${validatedOptions.workItemType}'`);\n    }\n\n    if (validatedOptions.state) {\n      conditions.push(`[System.State] = '${validatedOptions.state}'`);\n    }\n\n    if (validatedOptions.assignedTo) {\n      conditions.push(`[System.AssignedTo] = '${validatedOptions.assignedTo}'`);\n    }\n\n    if (validatedOptions.areaPath) {\n      conditions.push(`[System.AreaPath] UNDER '${validatedOptions.areaPath}'`);\n    }\n\n    if (validatedOptions.iterationPath) {\n      conditions.push(`[System.IterationPath] UNDER '${validatedOptions.iterationPath}'`);\n    }\n\n    if (validatedOptions.tags && validatedOptions.tags.length > 0) {\n      for (const tag of validatedOptions.tags) {\n        conditions.push(`[System.Tags] CONTAINS '${tag}'`);\n      }\n    }\n\n    const whereClause = conditions.length > 0 \n      ? `WHERE ${conditions.join(' AND ')}` \n      : '';\n\n    // WIQL format: SELECT [fields] FROM WorkItems WHERE ... ORDER BY ...\n    // Note: WIQL doesn't support TOP in the query - we limit in code instead\n    wiqlQuery = `SELECT [System.Id] FROM WorkItems ${whereClause} ORDER BY [System.ChangedDate] DESC`;\n  }\n\n  logDebug('Executing WIQL', { wiql: wiqlQuery });\n\n  const wiql: Wiql = { query: wiqlQuery };\n\n  const queryResult = await retryWithBackoff(\n    () => witApi.queryByWiql(wiql, { project: conn.project }),\n    { ...RETRY_PRESETS.standard, operationName: 'queryByWiql' }\n  );\n\n  if (!queryResult.workItems || queryResult.workItems.length === 0) {\n    logDebug('No work items found');\n    return { workItems: [], count: 0 };\n  }\n\n  // Get full work item details\n  let ids = queryResult.workItems\n    .map(wi => wi.id)\n    .filter((id): id is number => id !== undefined);\n\n  // Apply top limit if specified\n  if (validatedOptions.top && ids.length > validatedOptions.top) {\n    ids = ids.slice(0, validatedOptions.top);\n  }\n\n  logDebug(`Found ${ids.length} work items, fetching details`);\n\n  // Azure DevOps API has a 200 work item limit per request\n  // Fetch in batches to handle larger result sets\n  const BATCH_SIZE = 200;\n  const allWorkItems: AdoWorkItem[] = [];\n  \n  for (let i = 0; i < ids.length; i += BATCH_SIZE) {\n    const batchIds = ids.slice(i, i + BATCH_SIZE);\n    logDebug(`Fetching batch ${Math.floor(i / BATCH_SIZE) + 1} of ${Math.ceil(ids.length / BATCH_SIZE)} (${batchIds.length} items)`);\n    \n    const batchWorkItems = await retryWithBackoff(\n      () => witApi.getWorkItems(batchIds, undefined, undefined, undefined, undefined, conn.project),\n      { ...RETRY_PRESETS.standard, operationName: `getWorkItems(batch ${Math.floor(i / BATCH_SIZE) + 1})` }\n    );\n    \n    allWorkItems.push(...batchWorkItems.filter((wi): wi is AdoWorkItem => wi !== null));\n  }\n\n  const results = allWorkItems.map(convertWorkItem);\n\n  timer.log('searchWorkItems');\n  return {\n    workItems: results,\n    count: results.length,\n  };\n}\n","/**\n * Retry with Exponential Backoff\n * Provides resilient API calls with configurable retry logic\n */\n\nimport { logWarn, logError, logDebug } from './loggerStructured.js';\n\n/**\n * Retry options\n */\nexport interface RetryOptions {\n  /** Maximum number of retry attempts (default: 3) */\n  maxRetries?: number;\n  /** Initial delay in milliseconds (default: 1000) */\n  initialDelayMs?: number;\n  /** Maximum delay in milliseconds (default: 30000) */\n  maxDelayMs?: number;\n  /** Backoff multiplier (default: 2) */\n  backoffMultiplier?: number;\n  /** Jitter factor 0-1 to randomize delay (default: 0.1) */\n  jitterFactor?: number;\n  /** Custom function to determine if error is retryable */\n  isRetryable?: (error: unknown) => boolean;\n  /** Callback before each retry attempt */\n  onRetry?: (attempt: number, error: unknown, delayMs: number) => void;\n  /** Operation name for logging */\n  operationName?: string;\n}\n\n/**\n * Default retry options\n */\nconst DEFAULT_OPTIONS: Required<Omit<RetryOptions, 'isRetryable' | 'onRetry' | 'operationName'>> = {\n  maxRetries: 3,\n  initialDelayMs: 1000,\n  maxDelayMs: 30000,\n  backoffMultiplier: 2,\n  jitterFactor: 0.1,\n};\n\n/**\n * Calculate exponential delay with optional jitter\n */\nexport function exponentialDelay(\n  attempt: number,\n  initialDelayMs: number,\n  backoffMultiplier: number,\n  maxDelayMs: number,\n  jitterFactor: number\n): number {\n  // Calculate base delay with exponential backoff\n  const baseDelay = initialDelayMs * Math.pow(backoffMultiplier, attempt - 1);\n  \n  // Cap at max delay\n  const cappedDelay = Math.min(baseDelay, maxDelayMs);\n  \n  // Add jitter\n  const jitter = cappedDelay * jitterFactor * (Math.random() * 2 - 1);\n  \n  return Math.max(0, Math.round(cappedDelay + jitter));\n}\n\n/**\n * Default function to determine if an error is retryable\n */\nfunction defaultIsRetryable(error: unknown): boolean {\n  if (error instanceof Error) {\n    const message = error.message.toLowerCase();\n    const name = error.name.toLowerCase();\n    \n    // Network errors\n    if (message.includes('network') || \n        message.includes('timeout') ||\n        message.includes('econnreset') ||\n        message.includes('econnrefused') ||\n        message.includes('socket hang up')) {\n      return true;\n    }\n    \n    // Rate limiting\n    if (message.includes('rate limit') ||\n        message.includes('too many requests') ||\n        message.includes('429')) {\n      return true;\n    }\n    \n    // Temporary server errors\n    if (message.includes('502') ||\n        message.includes('503') ||\n        message.includes('504') ||\n        message.includes('service unavailable') ||\n        message.includes('internal server error')) {\n      return true;\n    }\n    \n    // Transient errors\n    if (name.includes('transient') ||\n        message.includes('temporarily')) {\n      return true;\n    }\n  }\n  \n  // Check for HTTP status codes on response objects\n  if (typeof error === 'object' && error !== null) {\n    const statusCode = (error as Record<string, unknown>)['statusCode'] ?? \n                       (error as Record<string, unknown>)['status'];\n    if (typeof statusCode === 'number') {\n      // Retry on 429, 502, 503, 504\n      return [429, 502, 503, 504].includes(statusCode);\n    }\n  }\n  \n  return false;\n}\n\n/**\n * Sleep for a specified duration\n */\nfunction sleep(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n/**\n * Execute a function with retry and exponential backoff\n * \n * @param fn - Async function to execute\n * @param options - Retry options\n * @returns Result of the function\n * @throws Last error if all retries fail\n */\nexport async function retryWithBackoff<T>(\n  fn: () => Promise<T>,\n  options: RetryOptions = {}\n): Promise<T> {\n  const {\n    maxRetries = DEFAULT_OPTIONS.maxRetries,\n    initialDelayMs = DEFAULT_OPTIONS.initialDelayMs,\n    maxDelayMs = DEFAULT_OPTIONS.maxDelayMs,\n    backoffMultiplier = DEFAULT_OPTIONS.backoffMultiplier,\n    jitterFactor = DEFAULT_OPTIONS.jitterFactor,\n    isRetryable = defaultIsRetryable,\n    onRetry,\n    operationName = 'operation',\n  } = options;\n\n  let lastError: unknown;\n  \n  for (let attempt = 1; attempt <= maxRetries + 1; attempt++) {\n    try {\n      logDebug(`${operationName}: attempt ${attempt}/${maxRetries + 1}`);\n      return await fn();\n    } catch (error) {\n      lastError = error;\n      \n      // Check if we've exhausted retries\n      if (attempt > maxRetries) {\n        logError(`${operationName}: all ${maxRetries} retries exhausted`, {\n          error: error instanceof Error ? error.message : String(error),\n        });\n        break;\n      }\n      \n      // Check if error is retryable\n      if (!isRetryable(error)) {\n        logError(`${operationName}: non-retryable error`, {\n          error: error instanceof Error ? error.message : String(error),\n        });\n        break;\n      }\n      \n      // Calculate delay\n      const delayMs = exponentialDelay(\n        attempt,\n        initialDelayMs,\n        backoffMultiplier,\n        maxDelayMs,\n        jitterFactor\n      );\n      \n      logWarn(`${operationName}: attempt ${attempt} failed, retrying in ${delayMs}ms`, {\n        error: error instanceof Error ? error.message : String(error),\n        attempt,\n        delayMs,\n      });\n      \n      // Call onRetry callback if provided\n      if (onRetry) {\n        onRetry(attempt, error, delayMs);\n      }\n      \n      // Wait before retrying\n      await sleep(delayMs);\n    }\n  }\n  \n  throw lastError;\n}\n\n/**\n * Create a retry wrapper for a function\n */\nexport function withRetry<T extends unknown[], R>(\n  fn: (...args: T) => Promise<R>,\n  options: RetryOptions = {}\n): (...args: T) => Promise<R> {\n  return (...args: T) => retryWithBackoff(() => fn(...args), options);\n}\n\n/**\n * Retry decorator options for specific error types\n */\nexport const RETRY_PRESETS = {\n  /** Quick retry for transient network issues */\n  quick: {\n    maxRetries: 2,\n    initialDelayMs: 500,\n    maxDelayMs: 2000,\n    backoffMultiplier: 2,\n  } satisfies RetryOptions,\n  \n  /** Standard retry for API calls */\n  standard: {\n    maxRetries: 3,\n    initialDelayMs: 1000,\n    maxDelayMs: 10000,\n    backoffMultiplier: 2,\n  } satisfies RetryOptions,\n  \n  /** Aggressive retry for critical operations */\n  aggressive: {\n    maxRetries: 5,\n    initialDelayMs: 1000,\n    maxDelayMs: 60000,\n    backoffMultiplier: 2,\n  } satisfies RetryOptions,\n  \n  /** Rate limit specific retry (longer delays) */\n  rateLimit: {\n    maxRetries: 3,\n    initialDelayMs: 5000,\n    maxDelayMs: 60000,\n    backoffMultiplier: 3,\n  } satisfies RetryOptions,\n} as const;\n","/**\n * Validation Schemas\n * Zod schemas for runtime validation of inputs\n */\n\nimport { z } from 'zod';\n\n// ============================================\n// Azure DevOps Schemas\n// ============================================\n\n/**\n * Work Class Type enum\n */\nexport const WorkClassTypeSchema = z.enum([\n  'Critical/Escalation',\n  'Development',\n  'Fixed Date Delivery',\n  'Maintenance/Recurring Tasks',\n  'Standard',\n]);\n\n/**\n * Requires QA enum\n */\nexport const RequiresQASchema = z.enum(['Yes', 'No']);\n\n/**\n * Priority enum\n */\nexport const PrioritySchema = z.union([\n  z.literal(1),\n  z.literal(2),\n  z.literal(3),\n  z.literal(4),\n]);\n\n/**\n * Work item type enum\n */\nexport const WorkItemTypeSchema = z.enum([\n  'User Story',\n  'Task',\n  'Bug',\n  'Feature',\n  'Epic',\n  'Issue',\n  'Test Case',\n  'Test Plan',\n  'Test Suite',\n]);\n\n/**\n * Link type alias enum\n */\nexport const LinkTypeAliasSchema = z.enum([\n  'parent',\n  'child',\n  'related',\n  'predecessor',\n  'successor',\n  'duplicate',\n  'affects',\n]);\n\n/**\n * Work item fields schema (partial - only commonly used fields)\n */\nexport const WorkItemFieldsSchema = z.object({\n  // System fields\n  'System.Title': z.string().optional(),\n  'System.Description': z.string().optional(),\n  'System.State': z.string().optional(),\n  'System.AreaPath': z.string().optional(),\n  'System.IterationPath': z.string().optional(),\n  'System.AssignedTo': z.string().optional(),\n  'System.Tags': z.string().optional(),\n  // Microsoft VSTS Common fields\n  'Microsoft.VSTS.Scheduling.StoryPoints': z.number().optional(),\n  'Microsoft.VSTS.Common.Priority': PrioritySchema.optional(),\n  'Microsoft.VSTS.Common.AcceptanceCriteria': z.string().optional(),\n  // Microsoft VSTS TCM fields (Bug-specific)\n  'Microsoft.VSTS.TCM.ReproSteps': z.string().optional(),\n  'Microsoft.VSTS.TCM.SystemInfo': z.string().optional(),\n  // Custom fields\n  'Custom.WorkClassType': WorkClassTypeSchema.optional(),\n  'Custom.RequiresQA': RequiresQASchema.optional(),\n  'Custom.SFComponents': z.string().optional(),\n  'Custom.TechnicalNotes': z.string().optional(),\n  'Custom.RootCauseDetail': z.string().optional(),\n}).passthrough(); // Allow additional fields\n\n/**\n * Get work item options schema\n */\nexport const GetWorkItemOptionsSchema = z.object({\n  expand: z.enum(['None', 'Relations', 'Fields', 'Links', 'All']).optional(),\n  includeComments: z.boolean().optional(),\n  fields: z.array(z.string()).optional(),\n});\n\n/**\n * Create work item options schema\n */\nexport const CreateWorkItemOptionsSchema = z.object({\n  type: WorkItemTypeSchema,\n  title: z.string().min(1),\n  description: z.string().optional(),\n  parentId: z.number().positive().optional(),\n  areaPath: z.string().optional(),\n  iterationPath: z.string().optional(),\n  assignedTo: z.string().optional(),\n  tags: z.array(z.string()).optional(),\n  additionalFields: WorkItemFieldsSchema.optional(),\n});\n\n/**\n * Update work item options schema\n */\nexport const UpdateWorkItemOptionsSchema = z.object({\n  fields: WorkItemFieldsSchema.optional(),\n  comment: z.string().optional(),\n});\n\n/**\n * Search work items options schema\n */\nexport const SearchWorkItemsOptionsSchema = z.object({\n  searchText: z.string().optional(),\n  wiql: z.string().optional(),\n  workItemType: WorkItemTypeSchema.optional(),\n  state: z.string().optional(),\n  assignedTo: z.string().optional(),\n  areaPath: z.string().optional(),\n  iterationPath: z.string().optional(),\n  tags: z.array(z.string()).optional(),\n  top: z.number().positive().optional(),\n});\n\n/**\n * Link work items options schema\n */\nexport const LinkWorkItemsOptionsSchema = z.object({\n  sourceId: z.number().positive(),\n  targetId: z.number().positive(),\n  linkType: LinkTypeAliasSchema,\n  comment: z.string().optional(),\n});\n\n// ============================================\n// Salesforce Schemas\n// ============================================\n\n/**\n * Query options schema\n */\nexport const QueryOptionsSchema = z.object({\n  query: z.string().min(1),\n  useToolingApi: z.boolean().optional(),\n  allRows: z.boolean().optional(),\n  maxRecords: z.number().positive().optional(),\n});\n\n/**\n * Dependency discovery options schema\n */\nexport const MetadataTypeSchema = z.enum([\n  'CustomObject',\n  'CustomField',\n  'ApexClass',\n  'ApexTrigger',\n  'ApexPage',\n  'ApexComponent',\n  'AuraDefinitionBundle',\n  'LightningComponentBundle',\n  'Flow',\n  'FlowDefinition',\n  'ValidationRule',\n  'WorkflowRule',\n  'WorkflowFieldUpdate',\n  'WorkflowAlert',\n  'ProcessBuilder',\n  'CustomMetadataType',\n  'CustomSetting',\n  'CustomLabel',\n  'Layout',\n  'RecordType',\n  'FieldSet',\n  'CompactLayout',\n  'ListView',\n  'Report',\n  'Dashboard',\n  'PermissionSet',\n  'Profile',\n  'Unknown',\n]);\n\nexport const DiscoverDependenciesOptionsSchema = z.object({\n  rootType: MetadataTypeSchema,\n  rootName: z.string().min(1),\n  maxDepth: z.number().positive().optional(),\n  includeStandardObjects: z.boolean().optional(),\n  includeNamespaced: z.boolean().optional(),\n  excludeTypes: z.array(MetadataTypeSchema).optional(),\n  parallelQueries: z.number().positive().optional(),\n});\n\n// ============================================\n// Workflow Schemas\n// ============================================\n\n/**\n * Workflow status schema\n */\nexport const WorkflowStatusSchema = z.enum([\n  'pending',\n  'in_progress',\n  'paused',\n  'completed',\n  'failed',\n  'cancelled',\n]);\n\n/**\n * Workflow execution options schema\n */\nexport const WorkflowExecutionOptionsSchema = z.object({\n  workItemId: z.number().positive(),\n  phases: z.array(z.string()).optional(),\n  steps: z.array(z.string()).optional(),\n  dryRun: z.boolean().optional(),\n  verbose: z.boolean().optional(),\n  continueOnError: z.boolean().optional(),\n});\n\n// ============================================\n// Validation Helpers\n// ============================================\n\n/**\n * Validate data against a schema and return typed result\n */\nexport function validate<T>(schema: z.ZodSchema<T>, data: unknown): T {\n  return schema.parse(data);\n}\n\n/**\n * Safely validate data, returning result or undefined\n */\nexport function safeValidate<T>(schema: z.ZodSchema<T>, data: unknown): T | undefined {\n  const result = schema.safeParse(data);\n  return result.success ? result.data : undefined;\n}\n\n/**\n * Get validation errors as a formatted string\n */\nexport function getValidationErrors(schema: z.ZodSchema, data: unknown): string[] {\n  const result = schema.safeParse(data);\n  if (result.success) {\n    return [];\n  }\n  return result.error.errors.map(e => `${e.path.join('.')}: ${e.message}`);\n}\n","/**\n * Azure DevOps Work Item Links\n * Operations for linking work items together\n */\n\nimport { Operation, type JsonPatchOperation } from 'azure-devops-node-api/interfaces/common/VSSInterfaces.js';\nimport { createAdoConnection, type AdoConnectionConfig } from './adoClient.js';\nimport { getWorkItem } from './adoWorkItems.js';\nimport { retryWithBackoff, RETRY_PRESETS } from './lib/retryWithBackoff.js';\nimport { logInfo, logDebug, createTimer } from './lib/loggerStructured.js';\nimport { validate, LinkWorkItemsOptionsSchema } from './lib/validationSchemas.js';\nimport type { WorkItem } from './types/adoWorkItemTypes.js';\nimport {\n  type LinkWorkItemsOptions,\n  type GetRelationsOptions,\n  type RelationResult,\n  type ParsedRelation,\n  type LinkTypeAlias,\n  resolveLinkType,\n  parseLinkType,\n  extractWorkItemIdFromUrl,\n} from './types/adoLinkTypes.js';\n\n/**\n * Link two work items together\n * \n * @param options - Link options\n * @param config - Connection config\n * @returns Updated source work item\n */\nexport async function linkWorkItems(\n  options: LinkWorkItemsOptions,\n  config?: AdoConnectionConfig\n): Promise<WorkItem> {\n  const timer = createTimer();\n  const validatedOptions = validate(LinkWorkItemsOptionsSchema, options);\n\n  const { sourceId, targetId, linkType, comment } = validatedOptions;\n  const linkTypeName = resolveLinkType(linkType);\n\n  logInfo(`Linking work items: ${sourceId} -> ${targetId} (${linkType})`);\n\n  const conn = await createAdoConnection(config);\n  const witApi = await conn.getWorkItemTrackingApi();\n\n  // Build the relation URL\n  const targetUrl = `${conn.orgUrl}/${conn.project}/_apis/wit/workItems/${targetId}`;\n\n  // Build patch document to add the link\n  const patchDoc: JsonPatchOperation[] = [\n    {\n      op: Operation.Add,\n      path: '/relations/-',\n      value: {\n        rel: linkTypeName,\n        url: targetUrl,\n        attributes: comment ? { comment } : {},\n      },\n    },\n  ];\n\n  logDebug(`Adding link: ${linkTypeName} to ${targetUrl}`);\n\n  const updatedItem = await retryWithBackoff(\n    () => witApi.updateWorkItem(\n      undefined, // customHeaders\n      patchDoc,\n      sourceId,\n      conn.project\n    ),\n    { ...RETRY_PRESETS.standard, operationName: `linkWorkItems(${sourceId}->${targetId})` }\n  );\n\n  if (!updatedItem) {\n    throw new Error(`Failed to link work items ${sourceId} -> ${targetId}`);\n  }\n\n  logInfo(`Successfully linked work items ${sourceId} -> ${targetId}`);\n  timer.log(`linkWorkItems(${sourceId}->${targetId})`);\n\n  return {\n    id: updatedItem.id ?? 0,\n    rev: updatedItem.rev ?? 0,\n    url: updatedItem.url ?? '',\n    fields: (updatedItem.fields ?? {}) as WorkItem['fields'],\n    relations: updatedItem.relations?.map(r => ({\n      rel: r.rel ?? '',\n      url: r.url ?? '',\n      attributes: r.attributes ?? {},\n    })) ?? [],\n  };\n}\n\n/**\n * Remove a link between two work items\n * \n * @param sourceId - Source work item ID\n * @param targetId - Target work item ID\n * @param linkType - Type of link to remove\n * @param config - Connection config\n * @returns Updated source work item\n */\nexport async function unlinkWorkItems(\n  sourceId: number,\n  targetId: number,\n  linkType: LinkTypeAlias,\n  config?: AdoConnectionConfig\n): Promise<WorkItem> {\n  const timer = createTimer();\n  \n  logInfo(`Unlinking work items: ${sourceId} -> ${targetId} (${linkType})`);\n\n  // First, get the work item to find the relation index\n  const workItem = await getWorkItem(sourceId, { expand: 'Relations' }, config);\n  \n  if (!workItem.relations || workItem.relations.length === 0) {\n    throw new Error(`Work item ${sourceId} has no relations`);\n  }\n\n  // Find the relation to remove\n  const linkTypeName = resolveLinkType(linkType);\n  const relationIndex = workItem.relations.findIndex(r => {\n    const relTargetId = extractWorkItemIdFromUrl(r.url);\n    return r.rel === linkTypeName && relTargetId === targetId;\n  });\n\n  if (relationIndex === -1) {\n    throw new Error(`No ${linkType} link found from ${sourceId} to ${targetId}`);\n  }\n\n  const conn = await createAdoConnection(config);\n  const witApi = await conn.getWorkItemTrackingApi();\n\n  // Build patch document to remove the link\n  const patchDoc: JsonPatchOperation[] = [\n    {\n      op: Operation.Remove,\n      path: `/relations/${relationIndex}`,\n    },\n  ];\n\n  logDebug(`Removing relation at index ${relationIndex}`);\n\n  const updatedItem = await retryWithBackoff(\n    () => witApi.updateWorkItem(\n      undefined,\n      patchDoc,\n      sourceId,\n      conn.project\n    ),\n    { ...RETRY_PRESETS.standard, operationName: `unlinkWorkItems(${sourceId}->${targetId})` }\n  );\n\n  if (!updatedItem) {\n    throw new Error(`Failed to unlink work items ${sourceId} -> ${targetId}`);\n  }\n\n  logInfo(`Successfully unlinked work items ${sourceId} -> ${targetId}`);\n  timer.log(`unlinkWorkItems(${sourceId}->${targetId})`);\n\n  return {\n    id: updatedItem.id ?? 0,\n    rev: updatedItem.rev ?? 0,\n    url: updatedItem.url ?? '',\n    fields: (updatedItem.fields ?? {}) as WorkItem['fields'],\n    relations: updatedItem.relations?.map(r => ({\n      rel: r.rel ?? '',\n      url: r.url ?? '',\n      attributes: r.attributes ?? {},\n    })) ?? [],\n  };\n}\n\n/**\n * Get all relations for a work item\n * \n * @param options - Get relations options\n * @param config - Connection config\n * @returns Relation result with parsed relations\n */\nexport async function getWorkItemRelations(\n  options: GetRelationsOptions,\n  config?: AdoConnectionConfig\n): Promise<RelationResult> {\n  const timer = createTimer();\n  const { workItemId, linkTypes } = options;\n\n  logInfo(`Getting relations for work item ${workItemId}`);\n\n  // Get work item with relations expanded\n  const workItem = await getWorkItem(workItemId, { expand: 'Relations' }, config);\n\n  if (!workItem.relations || workItem.relations.length === 0) {\n    logDebug(`Work item ${workItemId} has no relations`);\n    return { workItemId, relations: [] };\n  }\n\n  // Parse and filter relations\n  const parsedRelations: ParsedRelation[] = [];\n\n  for (const relation of workItem.relations) {\n    const friendlyType = parseLinkType(relation.rel);\n    \n    // Skip if we're filtering by link types and this doesn't match\n    if (linkTypes && linkTypes.length > 0 && friendlyType && !linkTypes.includes(friendlyType)) {\n      continue;\n    }\n\n    const targetId = extractWorkItemIdFromUrl(relation.url);\n    \n    if (targetId !== undefined) {\n      const parsed: ParsedRelation = {\n        targetId,\n        linkType: friendlyType ?? 'related',\n        linkTypeName: relation.rel as ParsedRelation['linkTypeName'],\n        url: relation.url,\n      };\n      \n      // Only add comment if it exists\n      const commentValue = relation.attributes?.comment;\n      if (typeof commentValue === 'string') {\n        parsed.comment = commentValue;\n      }\n      \n      parsedRelations.push(parsed);\n    }\n  }\n\n  logDebug(`Found ${parsedRelations.length} relations for work item ${workItemId}`);\n  timer.log(`getWorkItemRelations(${workItemId})`);\n\n  return { workItemId, relations: parsedRelations };\n}\n\n/**\n * Get related work items by link type\n * \n * @param workItemId - Work item ID\n * @param linkType - Type of link to filter by\n * @param config - Connection config\n * @returns Array of related work item IDs\n */\nexport async function getRelatedWorkItemIds(\n  workItemId: number,\n  linkType: LinkTypeAlias,\n  config?: AdoConnectionConfig\n): Promise<number[]> {\n  const result = await getWorkItemRelations(\n    { workItemId, linkTypes: [linkType] },\n    config\n  );\n  \n  return result.relations.map(r => r.targetId);\n}\n\n/**\n * Get parent work item ID\n * \n * @param workItemId - Work item ID\n * @param config - Connection config\n * @returns Parent work item ID or undefined\n */\nexport async function getParentWorkItemId(\n  workItemId: number,\n  config?: AdoConnectionConfig\n): Promise<number | undefined> {\n  const ids = await getRelatedWorkItemIds(workItemId, 'parent', config);\n  return ids[0];\n}\n\n/**\n * Get child work item IDs\n * \n * @param workItemId - Work item ID\n * @param config - Connection config\n * @returns Array of child work item IDs\n */\nexport async function getChildWorkItemIds(\n  workItemId: number,\n  config?: AdoConnectionConfig\n): Promise<number[]> {\n  return getRelatedWorkItemIds(workItemId, 'child', config);\n}\n\n/**\n * Check if a link exists between two work items\n * \n * @param sourceId - Source work item ID\n * @param targetId - Target work item ID\n * @param linkType - Type of link (optional - checks any if not specified)\n * @param config - Connection config\n * @returns True if link exists\n */\nexport async function hasLink(\n  sourceId: number,\n  targetId: number,\n  linkType?: LinkTypeAlias,\n  config?: AdoConnectionConfig\n): Promise<boolean> {\n  const options: GetRelationsOptions = { workItemId: sourceId };\n  if (linkType) {\n    options.linkTypes = [linkType];\n  }\n  \n  const result = await getWorkItemRelations(options, config);\n  \n  return result.relations.some(r => r.targetId === targetId);\n}\n","/**\n * Azure DevOps Wiki Pages\n * Operations for managing wiki pages\n * \n * NOTE: The azure-devops-node-api package has limited wiki page support.\n * It only provides stream-based methods (getPageText, getPageZip) not JSON responses.\n * We use direct REST API calls for all page operations.\n * See: https://github.com/microsoft/azure-devops-node-api/issues/416\n */\n\nimport { readFileSync } from 'fs';\nimport type { \n  WikiPage as AdoWikiPage,\n} from 'azure-devops-node-api/interfaces/WikiInterfaces.js';\nimport { getAzureBearerToken, validateAzureAuth } from './lib/authAzureCli.js';\nimport { retryWithBackoff, RETRY_PRESETS } from './lib/retryWithBackoff.js';\nimport { logInfo, logDebug, logError, createTimer } from './lib/loggerStructured.js';\nimport { DEFAULT_ADO_ORG, DEFAULT_ADO_PROJECT } from './types/adoFieldTypes.js';\nimport type { AdoConnectionConfig } from './adoClient.js';\nimport type {\n  WikiPage,\n  WikiPageWithContent,\n  GetWikiPageOptions,\n  UpdateWikiPageOptions,\n  CreateWikiPageOptions,\n  WikiPageUpdateResult,\n} from './types/adoWikiTypes.js';\nimport { WIKI_DEFAULTS } from './types/adoWikiTypes.js';\n\n/**\n * Response from wiki page create/update REST API\n */\ninterface WikiPageCreateUpdateResponse {\n  page: AdoWikiPage;\n  eTag: string;\n}\n\n/**\n * Get authorization headers for REST API calls\n */\nfunction getAuthHeaders(): Record<string, string> {\n  validateAzureAuth();\n  const token = getAzureBearerToken();\n  return {\n    'Authorization': `Bearer ${token}`,\n    'Content-Type': 'application/json',\n  };\n}\n\n/**\n * Build REST API URL for wiki pages\n */\nfunction buildWikiPageUrl(\n  orgUrl: string,\n  project: string,\n  wikiIdentifier: string,\n  path: string,\n  queryParams?: Record<string, string | number | boolean | undefined>\n): string {\n  const encodedPath = encodeURIComponent(path);\n  const baseUrl = `${orgUrl}/${encodeURIComponent(project)}/_apis/wiki/wikis/${encodeURIComponent(wikiIdentifier)}/pages`;\n  \n  const params = new URLSearchParams();\n  params.set('path', path);\n  params.set('api-version', '7.1');\n  \n  if (queryParams) {\n    for (const [key, value] of Object.entries(queryParams)) {\n      if (value !== undefined) {\n        params.set(key, String(value));\n      }\n    }\n  }\n  \n  return `${baseUrl}?${params.toString()}`;\n}\n\n/**\n * Convert ADO Wiki page to our WikiPage type\n */\nfunction convertWikiPage(page: AdoWikiPage): WikiPage {\n  return {\n    id: page.id ?? 0,\n    path: page.path ?? '',\n    url: page.url ?? '',\n    remoteUrl: page.remoteUrl ?? '',\n    gitItemPath: page.gitItemPath,\n    content: page.content,\n    order: page.order,\n    isParentPage: page.isParentPage,\n    subPages: page.subPages?.map(convertWikiPage),\n  };\n}\n\n/**\n * Get wiki identifier (name or ID)\n */\nfunction getWikiIdentifier(wikiId: string | undefined): string {\n  return wikiId ?? WIKI_DEFAULTS.WIKI_NAME;\n}\n\n/**\n * Make a REST API call to get a wiki page\n */\nasync function getPageRest(\n  orgUrl: string,\n  project: string,\n  wikiIdentifier: string,\n  path: string,\n  options?: {\n    includeContent?: boolean;\n    recursionLevel?: number;\n  }\n): Promise<AdoWikiPage> {\n  const headers = getAuthHeaders();\n  \n  const queryParams: Record<string, string | number | boolean | undefined> = {\n    includeContent: options?.includeContent ?? true,\n    recursionLevel: options?.recursionLevel,\n  };\n  \n  const url = buildWikiPageUrl(orgUrl, project, wikiIdentifier, path, queryParams);\n  \n  const response = await fetch(url, {\n    method: 'GET',\n    headers,\n  });\n  \n  if (!response.ok) {\n    const errorText = await response.text();\n    throw new Error(`Wiki API error (${response.status}): ${errorText}`);\n  }\n  \n  const page = await response.json() as AdoWikiPage;\n  return page;\n}\n\n/**\n * Make a REST API call to create or update a wiki page\n */\nasync function createOrUpdatePageRest(\n  orgUrl: string,\n  project: string,\n  wikiIdentifier: string,\n  path: string,\n  content: string,\n  comment?: string,\n  eTag?: string\n): Promise<WikiPageCreateUpdateResponse> {\n  const headers = getAuthHeaders();\n  \n  if (eTag) {\n    headers['If-Match'] = eTag;\n  }\n  \n  const params = new URLSearchParams();\n  params.set('path', path);\n  params.set('api-version', '7.1');\n  if (comment) {\n    params.set('comment', comment);\n  }\n  \n  const url = `${orgUrl}/${encodeURIComponent(project)}/_apis/wiki/wikis/${encodeURIComponent(wikiIdentifier)}/pages?${params.toString()}`;\n  \n  const response = await fetch(url, {\n    method: 'PUT',\n    headers,\n    body: JSON.stringify({ content }),\n  });\n  \n  if (!response.ok) {\n    const errorText = await response.text();\n    throw new Error(`Wiki API error (${response.status}): ${errorText}`);\n  }\n  \n  const page = await response.json() as AdoWikiPage;\n  const responseETag = response.headers.get('ETag') ?? '';\n  \n  return {\n    page,\n    eTag: responseETag,\n  };\n}\n\n/**\n * Make a REST API call to delete a wiki page\n */\nasync function deletePageRest(\n  orgUrl: string,\n  project: string,\n  wikiIdentifier: string,\n  path: string\n): Promise<void> {\n  const headers = getAuthHeaders();\n  \n  const params = new URLSearchParams();\n  params.set('path', path);\n  params.set('api-version', '7.1');\n  \n  const url = `${orgUrl}/${encodeURIComponent(project)}/_apis/wiki/wikis/${encodeURIComponent(wikiIdentifier)}/pages?${params.toString()}`;\n  \n  const response = await fetch(url, {\n    method: 'DELETE',\n    headers,\n  });\n  \n  if (!response.ok) {\n    const errorText = await response.text();\n    throw new Error(`Wiki API error (${response.status}): ${errorText}`);\n  }\n}\n\n/**\n * Get a wiki page by path\n * \n * @param options - Get options\n * @param config - Connection config\n * @returns Wiki page\n */\nexport async function getWikiPage(\n  options: GetWikiPageOptions,\n  config?: AdoConnectionConfig\n): Promise<WikiPageWithContent> {\n  const timer = createTimer();\n  const { path, includeContent = true, recursionLevel } = options;\n\n  if (!path) {\n    throw new Error('Page path must be specified');\n  }\n\n  logInfo(`Getting wiki page: ${path}`);\n\n  const orgUrl = config?.orgUrl ?? DEFAULT_ADO_ORG;\n  const project = config?.project ?? DEFAULT_ADO_PROJECT;\n  const wikiIdentifier = getWikiIdentifier(options.wikiId);\n\n  const page = await retryWithBackoff(\n    () => getPageRest(orgUrl, project, wikiIdentifier, path, {\n      includeContent,\n      recursionLevel: recursionLevel as number | undefined,\n    }),\n    { ...RETRY_PRESETS.standard, operationName: `getWikiPage(${path})` }\n  );\n\n  if (!page) {\n    throw new Error(`Wiki page ${path} not found`);\n  }\n\n  const result: WikiPageWithContent = {\n    ...convertWikiPage(page),\n    content: page.content ?? '',\n    eTag: (page as { eTag?: string }).eTag,\n  };\n\n  timer.log(`getWikiPage(${path})`);\n  return result;\n}\n\n/**\n * Update a wiki page\n * \n * @param options - Update options\n * @param config - Connection config\n * @returns Update result with new page and eTag\n */\nexport async function updateWikiPage(\n  options: UpdateWikiPageOptions,\n  config?: AdoConnectionConfig\n): Promise<WikiPageUpdateResult> {\n  const timer = createTimer();\n  const { path, content, comment, eTag } = options;\n\n  if (!path) {\n    throw new Error('Page path is required for updates');\n  }\n\n  logInfo(`Updating wiki page: ${path}`);\n\n  // Load content from file if it's a file path\n  let pageContent = content;\n  if (content.endsWith('.md') || content.includes('/') || content.includes('\\\\')) {\n    try {\n      logDebug(`Loading content from file: ${content}`);\n      pageContent = readFileSync(content, 'utf-8');\n    } catch {\n      // Not a file, use as raw content\n      logDebug('Content is not a file path, using as raw content');\n    }\n  }\n\n  const orgUrl = config?.orgUrl ?? DEFAULT_ADO_ORG;\n  const project = config?.project ?? DEFAULT_ADO_PROJECT;\n  const wikiIdentifier = getWikiIdentifier(options.wikiId);\n\n  // Get current page to get eTag if not provided\n  let currentETag = eTag;\n  if (!currentETag) {\n    try {\n      const currentPage = await getWikiPage({ path, wikiId: options.wikiId }, config);\n      currentETag = currentPage.eTag;\n    } catch {\n      // Page might not exist yet\n      logDebug('Could not get current page eTag, will attempt update without it');\n    }\n  }\n\n  const result = await retryWithBackoff(\n    () => createOrUpdatePageRest(\n      orgUrl,\n      project,\n      wikiIdentifier,\n      path,\n      pageContent,\n      comment ?? 'Updated via API',\n      currentETag\n    ),\n    { ...RETRY_PRESETS.standard, operationName: `updateWikiPage(${path})` }\n  );\n\n  logInfo(`Successfully updated wiki page: ${path}`);\n  timer.log(`updateWikiPage(${path})`);\n\n  return {\n    page: convertWikiPage(result.page),\n    eTag: result.eTag,\n  };\n}\n\n/**\n * Create a new wiki page\n * \n * @param options - Create options\n * @param config - Connection config\n * @returns Created page with eTag\n */\nexport async function createWikiPage(\n  options: CreateWikiPageOptions,\n  config?: AdoConnectionConfig\n): Promise<WikiPageUpdateResult> {\n  const timer = createTimer();\n  const { path, content, comment } = options;\n\n  logInfo(`Creating wiki page: ${path}`);\n\n  // Load content from file if it's a file path\n  let pageContent = content;\n  if (content.endsWith('.md') || content.includes('/') || content.includes('\\\\')) {\n    try {\n      logDebug(`Loading content from file: ${content}`);\n      pageContent = readFileSync(content, 'utf-8');\n    } catch {\n      // Not a file, use as raw content\n      logDebug('Content is not a file path, using as raw content');\n    }\n  }\n\n  const orgUrl = config?.orgUrl ?? DEFAULT_ADO_ORG;\n  const project = config?.project ?? DEFAULT_ADO_PROJECT;\n  const wikiIdentifier = getWikiIdentifier(options.wikiId);\n\n  const result = await retryWithBackoff(\n    () => createOrUpdatePageRest(\n      orgUrl,\n      project,\n      wikiIdentifier,\n      path,\n      pageContent,\n      comment ?? 'Created via API'\n      // No eTag for new pages\n    ),\n    { ...RETRY_PRESETS.standard, operationName: `createWikiPage(${path})` }\n  );\n\n  logInfo(`Successfully created wiki page: ${path}`);\n  timer.log(`createWikiPage(${path})`);\n\n  return {\n    page: convertWikiPage(result.page),\n    eTag: result.eTag,\n  };\n}\n\n/**\n * Delete a wiki page\n * \n * @param path - Page path\n * @param wikiId - Wiki identifier (optional)\n * @param config - Connection config\n */\nexport async function deleteWikiPage(\n  path: string,\n  wikiId?: string,\n  config?: AdoConnectionConfig\n): Promise<void> {\n  const timer = createTimer();\n  \n  logInfo(`Deleting wiki page: ${path}`);\n\n  const orgUrl = config?.orgUrl ?? DEFAULT_ADO_ORG;\n  const project = config?.project ?? DEFAULT_ADO_PROJECT;\n  const wikiIdentifier = getWikiIdentifier(wikiId);\n\n  await retryWithBackoff(\n    () => deletePageRest(orgUrl, project, wikiIdentifier, path),\n    { ...RETRY_PRESETS.standard, operationName: `deleteWikiPage(${path})` }\n  );\n\n  logInfo(`Successfully deleted wiki page: ${path}`);\n  timer.log(`deleteWikiPage(${path})`);\n}\n\n/**\n * Search wiki pages by keyword\n * \n * @param searchText - Text to search for in page paths and titles\n * @param wikiId - Wiki identifier (optional)\n * @param config - Connection config\n * @returns Array of matching wiki pages\n */\nexport async function searchWikiPages(\n  searchText: string,\n  wikiId?: string,\n  config?: AdoConnectionConfig\n): Promise<WikiPage[]> {\n  const timer = createTimer();\n  \n  logInfo(`Searching wiki for: ${searchText}`);\n\n  try {\n    // Get all pages recursively\n    const allPages = await getAllWikiPagesRecursive('/', wikiId, config);\n    \n    // Filter pages by search text (case-insensitive)\n    const searchLower = searchText.toLowerCase();\n    const matchingPages = allPages.filter(page => {\n      const pathLower = page.path.toLowerCase();\n      return pathLower.includes(searchLower);\n    });\n\n    logDebug(`Found ${matchingPages.length} wiki pages matching \"${searchText}\"`);\n    timer.log(`searchWikiPages(${searchText})`);\n    \n    return matchingPages;\n  } catch (error) {\n    logError(`Wiki search failed: ${error instanceof Error ? error.message : error}`);\n    // Return empty array on error to allow workflow to continue\n    return [];\n  }\n}\n\n/**\n * Get all wiki pages recursively\n */\nasync function getAllWikiPagesRecursive(\n  path: string,\n  wikiId?: string,\n  config?: AdoConnectionConfig\n): Promise<WikiPage[]> {\n  const orgUrl = config?.orgUrl ?? DEFAULT_ADO_ORG;\n  const project = config?.project ?? DEFAULT_ADO_PROJECT;\n  const wikiIdentifier = getWikiIdentifier(wikiId);\n\n  const page = await retryWithBackoff(\n    () => getPageRest(orgUrl, project, wikiIdentifier, path, {\n      includeContent: false,\n      recursionLevel: 120, // Full recursion (OneLevel=1, Full=120)\n    }),\n    { ...RETRY_PRESETS.standard, operationName: `getAllWikiPages(${path})` }\n  );\n\n  if (!page) {\n    return [];\n  }\n\n  const result: WikiPage[] = [];\n  \n  // Add current page if it has valid content\n  if (page.path && page.path !== '/') {\n    result.push(convertWikiPage(page));\n  }\n\n  // Recursively add subpages\n  function collectSubPages(p: typeof page) {\n    if (p.subPages) {\n      for (const subPage of p.subPages) {\n        result.push(convertWikiPage(subPage));\n        collectSubPages(subPage);\n      }\n    }\n  }\n  collectSubPages(page);\n\n  return result;\n}\n\n/**\n * List wiki pages under a path\n * \n * @param path - Parent path (optional, defaults to root)\n * @param wikiId - Wiki identifier (optional)\n * @param config - Connection config\n * @returns Array of wiki pages\n */\nexport async function listWikiPages(\n  path?: string,\n  wikiId?: string,\n  config?: AdoConnectionConfig\n): Promise<WikiPage[]> {\n  const timer = createTimer();\n  const pagePath = path ?? '/';\n  \n  logInfo(`Listing wiki pages under: ${pagePath}`);\n\n  const orgUrl = config?.orgUrl ?? DEFAULT_ADO_ORG;\n  const project = config?.project ?? DEFAULT_ADO_PROJECT;\n  const wikiIdentifier = getWikiIdentifier(wikiId);\n\n  const page = await retryWithBackoff(\n    () => getPageRest(orgUrl, project, wikiIdentifier, pagePath, {\n      includeContent: false,\n      recursionLevel: 1, // OneLevel\n    }),\n    { ...RETRY_PRESETS.standard, operationName: `listWikiPages(${pagePath})` }\n  );\n\n  if (!page) {\n    return [];\n  }\n\n  const result = page.subPages?.map(convertWikiPage) ?? [];\n  \n  logDebug(`Found ${result.length} wiki pages under ${pagePath}`);\n  timer.log(`listWikiPages(${pagePath})`);\n  \n  return result;\n}\n","/**\n * Salesforce CLI Authentication\n * Reuses existing SF CLI authentication sessions\n */\n\nimport { AuthInfo, Connection, Org, ConfigAggregator } from '@salesforce/core';\n\n/**\n * Connection cache to avoid repeated auth lookups\n */\nconst connectionCache = new Map<string, Connection>();\n\n/**\n * Get the default org alias/username from SF CLI config\n * \n * @returns The default org alias or undefined if not set\n */\nasync function getDefaultOrgAlias(): Promise<string | undefined> {\n  try {\n    const configAggregator = await ConfigAggregator.create();\n    const targetOrg = configAggregator.getPropertyValue('target-org');\n    return typeof targetOrg === 'string' ? targetOrg : undefined;\n  } catch {\n    return undefined;\n  }\n}\n\n/**\n * Get a Salesforce connection using existing SF CLI authentication\n * \n * @param aliasOrUsername - Org alias or username (if not provided, uses default org)\n * @returns Salesforce Connection instance\n * @throws Error if not authenticated to the specified org\n */\nexport async function getSfConnection(aliasOrUsername?: string): Promise<Connection> {\n  // If no alias provided, get the default org\n  let targetAlias = aliasOrUsername;\n  if (!targetAlias) {\n    targetAlias = await getDefaultOrgAlias();\n    if (!targetAlias) {\n      throw new Error(\n        'No default Salesforce org is set. Please run: sf config set target-org <alias>'\n      );\n    }\n  }\n\n  // Check cache first\n  const cached = connectionCache.get(targetAlias);\n  if (cached) {\n    // Verify connection is still valid\n    try {\n      await cached.identity();\n      return cached;\n    } catch {\n      // Connection expired, remove from cache\n      connectionCache.delete(targetAlias);\n    }\n  }\n\n  try {\n    // Use Org.create which handles alias resolution automatically\n    const org = await Org.create({ aliasOrUsername: targetAlias });\n    const connection = org.getConnection();\n\n    // Cache the connection using the alias/username that was requested\n    connectionCache.set(targetAlias, connection);\n\n    return connection;\n  } catch (error) {\n    if (error instanceof Error) {\n      if (error.message.includes('No authorization found') ||\n          error.message.includes('NamedOrgNotFound') ||\n          error.message.includes('No authorization information')) {\n        throw new Error(\n          `Salesforce org '${targetAlias}' is not authenticated. Please run: sf org login web -a ${targetAlias}`\n        );\n      }\n      throw new Error(`Failed to connect to Salesforce: ${error.message}`);\n    }\n    throw error;\n  }\n}\n\n/**\n * Validate that SF CLI is authenticated to the specified org\n * \n * @param alias - Org alias or username to validate (uses default if not provided)\n * @throws Error if not authenticated\n */\nexport async function validateSfAuth(alias?: string): Promise<void> {\n  let targetAlias = alias;\n  if (!targetAlias) {\n    targetAlias = await getDefaultOrgAlias();\n    if (!targetAlias) {\n      throw new Error('No default Salesforce org is set.');\n    }\n  }\n\n  const auths = await AuthInfo.listAllAuthorizations();\n  \n  const found = auths.some(auth => \n    auth.username === targetAlias || \n    auth.aliases?.includes(targetAlias!)\n  );\n\n  if (!found) {\n    throw new Error(\n      `Salesforce org '${targetAlias}' is not authenticated. Please run: sf org login web -a ${targetAlias}`\n    );\n  }\n}\n\n/**\n * List all authenticated Salesforce orgs\n * \n * @returns Array of org information\n */\nexport async function listSfOrgs(): Promise<SfOrgInfo[]> {\n  const auths = await AuthInfo.listAllAuthorizations();\n  \n  return auths.map(auth => ({\n    username: auth.username,\n    aliases: auth.aliases ?? [],\n    instanceUrl: auth.instanceUrl ?? '',\n    orgId: auth.orgId ?? '',\n    isDefaultUsername: auth.isDefaultUsername ?? false,\n    isDefaultDevhubUsername: auth.isDefaultDevhubUsername ?? false,\n  }));\n}\n\n/**\n * Get detailed org information\n * \n * @param alias - Org alias or username (uses default if not provided)\n * @returns Org details\n */\nexport async function getSfOrgInfo(alias?: string): Promise<SfOrgDetails> {\n  const connection = await getSfConnection(alias);\n  const org = await Org.create({ connection });\n  \n  const identity = await connection.identity();\n  \n  return {\n    username: identity.username,\n    orgId: identity.organization_id,\n    userId: identity.user_id,\n    instanceUrl: connection.instanceUrl,\n    apiVersion: connection.version,\n    accessToken: connection.accessToken ?? '',\n  };\n}\n\n/**\n * Salesforce org information\n */\nexport interface SfOrgInfo {\n  username: string;\n  aliases: string[];\n  instanceUrl: string;\n  orgId: string;\n  isDefaultUsername: boolean;\n  isDefaultDevhubUsername: boolean;\n}\n\n/**\n * Detailed Salesforce org information\n */\nexport interface SfOrgDetails {\n  username: string;\n  orgId: string;\n  userId: string;\n  instanceUrl: string;\n  apiVersion: string;\n  accessToken: string;\n}\n\n/**\n * Clear the connection cache\n */\nexport function clearConnectionCache(): void {\n  connectionCache.clear();\n}\n\n/**\n * Remove a specific connection from cache\n */\nexport function removeFromCache(alias: string): void {\n  connectionCache.delete(alias);\n}\n","/**\n * Salesforce Client\n * Creates authenticated connections to Salesforce using SF CLI\n */\n\nimport { Connection } from '@salesforce/core';\nimport { getSfConnection, validateSfAuth, type SfOrgDetails } from './lib/authSalesforceCli.js';\nimport { SF_DEFAULTS } from './types/sfMetadataTypes.js';\nimport { logInfo, logDebug } from './lib/loggerStructured.js';\n\n/**\n * SF connection configuration\n */\nexport interface SfConnectionConfig {\n  /** Org alias or username (uses default org if not provided) */\n  alias?: string;\n  /** API version to use */\n  apiVersion?: string;\n  /** Skip auth validation */\n  skipAuthValidation?: boolean;\n}\n\n/**\n * SF connection wrapper with additional helpers\n */\nexport interface SfConnectionWrapper {\n  /** The underlying jsforce Connection */\n  connection: Connection;\n  /** Org alias */\n  alias: string;\n  /** API version */\n  apiVersion: string;\n  /** Instance URL */\n  instanceUrl: string;\n}\n\n/**\n * Create an authenticated Salesforce connection\n * \n * @param config - Connection configuration\n * @returns SF connection wrapper\n */\nexport async function createSfConnection(\n  config: SfConnectionConfig = {}\n): Promise<SfConnectionWrapper> {\n  const apiVersion = config.apiVersion ?? SF_DEFAULTS.API_VERSION;\n\n  logInfo(`Creating SF connection${config.alias ? ` to ${config.alias}` : ' (using default org)'}`);\n\n  // Validate SF CLI auth (getSfConnection handles default org resolution)\n  if (!config.skipAuthValidation) {\n    await validateSfAuth(config.alias);\n  }\n\n  // Get connection using SF CLI auth (will use default org if alias not specified)\n  const connection = await getSfConnection(config.alias);\n\n  // Set API version if different from default\n  if (apiVersion !== connection.version) {\n    logDebug(`Setting API version to ${apiVersion}`);\n    connection.version = apiVersion;\n  }\n\n  logDebug(`SF connection created: ${connection.instanceUrl}`);\n\n  // Get the actual username from the connection for the wrapper\n  const identity = await connection.identity();\n\n  return {\n    connection,\n    alias: config.alias ?? identity.username,\n    apiVersion: connection.version,\n    instanceUrl: connection.instanceUrl,\n  };\n}\n\n/**\n * Get the jsforce Connection object directly\n * Convenience function for when you need the raw connection\n */\nexport async function getConnection(\n  config?: SfConnectionConfig\n): Promise<Connection> {\n  const wrapper = await createSfConnection(config);\n  return wrapper.connection;\n}\n\n/**\n * Execute a SOQL query\n * Convenience wrapper that creates connection if needed\n */\nexport async function query<T = Record<string, unknown>>(\n  soql: string,\n  config?: SfConnectionConfig\n): Promise<T[]> {\n  const conn = await getConnection(config);\n  const result = await conn.query<T>(soql);\n  return result.records;\n}\n\n/**\n * Execute a Tooling API query\n * Convenience wrapper that creates connection if needed\n */\nexport async function toolingQuery<T = Record<string, unknown>>(\n  soql: string,\n  config?: SfConnectionConfig\n): Promise<T[]> {\n  const conn = await getConnection(config);\n  const result = await conn.tooling.query<T>(soql);\n  return result.records;\n}\n\n/**\n * Get the identity of the authenticated user\n */\nexport async function getIdentity(\n  config?: SfConnectionConfig\n): Promise<SfIdentity> {\n  const conn = await getConnection(config);\n  const identity = await conn.identity();\n  \n  return {\n    userId: identity.user_id,\n    username: identity.username,\n    organizationId: identity.organization_id,\n    displayName: identity.display_name,\n    email: identity.email,\n  };\n}\n\n/**\n * SF identity information\n */\nexport interface SfIdentity {\n  userId: string;\n  username: string;\n  organizationId: string;\n  displayName: string;\n  email: string;\n}\n\n/**\n * Get organization limits\n */\nexport async function getOrgLimits(\n  config?: SfConnectionConfig\n): Promise<Record<string, OrgLimit>> {\n  const conn = await getConnection(config);\n  const limits = await conn.limits();\n  return limits as Record<string, OrgLimit>;\n}\n\n/**\n * Org limit information\n */\nexport interface OrgLimit {\n  Max: number;\n  Remaining: number;\n}\n\n/**\n * Test connection to Salesforce\n */\nexport async function testConnection(\n  config?: SfConnectionConfig\n): Promise<ConnectionTestResult> {\n  try {\n    const start = Date.now();\n    const identity = await getIdentity(config);\n    const duration = Date.now() - start;\n\n    return {\n      success: true,\n      username: identity.username,\n      organizationId: identity.organizationId,\n      responseTimeMs: duration,\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : String(error),\n    };\n  }\n}\n\n/**\n * Connection test result\n */\nexport interface ConnectionTestResult {\n  success: boolean;\n  username?: string;\n  organizationId?: string;\n  responseTimeMs?: number;\n  error?: string;\n}\n","/**\n * Salesforce Query Executor\n * Executes SOQL and Tooling API queries\n */\n\nimport { createSfConnection, type SfConnectionConfig } from './sfClient.js';\nimport { retryWithBackoff, RETRY_PRESETS } from './lib/retryWithBackoff.js';\nimport { logInfo, logDebug, logError, createTimer } from './lib/loggerStructured.js';\nimport { validate, QueryOptionsSchema } from './lib/validationSchemas.js';\nimport type {\n  QueryResult,\n  ToolingQueryResult,\n  QueryOptions,\n  QueryExecutionResult,\n  BatchQueryRequest,\n  BatchQueryResult,\n} from './types/sfQueryTypes.js';\n\n/**\n * Execute a SOQL query\n * \n * @param query - SOQL query string\n * @param config - Connection config\n * @returns Query result with records\n */\nexport async function executeSoqlQuery<T = Record<string, unknown>>(\n  query: string,\n  config?: SfConnectionConfig\n): Promise<QueryResult<T>> {\n  const timer = createTimer();\n  \n  logInfo('Executing SOQL query');\n  logDebug('Query', { query });\n\n  const { connection } = await createSfConnection(config);\n\n  const result = await retryWithBackoff(\n    async () => {\n      const queryResult = await connection.query<T>(query);\n      return {\n        done: queryResult.done,\n        totalSize: queryResult.totalSize,\n        records: queryResult.records,\n        nextRecordsUrl: queryResult.nextRecordsUrl,\n      };\n    },\n    { ...RETRY_PRESETS.standard, operationName: 'executeSoqlQuery' }\n  );\n\n  logInfo(`Query returned ${result.totalSize} records`);\n  timer.log('executeSoqlQuery');\n  \n  return result;\n}\n\n/**\n * Execute a Tooling API query\n * \n * @param query - SOQL query string for Tooling API\n * @param config - Connection config\n * @returns Query result with records\n */\nexport async function executeToolingQuery<T = Record<string, unknown>>(\n  query: string,\n  config?: SfConnectionConfig\n): Promise<ToolingQueryResult<T>> {\n  const timer = createTimer();\n  \n  logInfo('Executing Tooling API query');\n  logDebug('Query', { query });\n\n  const { connection } = await createSfConnection(config);\n\n  const result = await retryWithBackoff(\n    async () => {\n      const queryResult = await connection.tooling.query<T>(query);\n      return {\n        done: queryResult.done,\n        totalSize: queryResult.totalSize,\n        records: queryResult.records,\n        nextRecordsUrl: queryResult.nextRecordsUrl,\n        entityTypeName: queryResult.entityTypeName,\n      };\n    },\n    { ...RETRY_PRESETS.standard, operationName: 'executeToolingQuery' }\n  );\n\n  logInfo(`Tooling query returned ${result.totalSize} records`);\n  timer.log('executeToolingQuery');\n  \n  return result;\n}\n\n/**\n * Execute a query with full options\n * \n * @param options - Query options\n * @param config - Connection config\n * @returns Query execution result with metadata\n */\nexport async function executeQuery<T = Record<string, unknown>>(\n  options: QueryOptions,\n  config?: SfConnectionConfig\n): Promise<QueryExecutionResult<T>> {\n  const timer = createTimer();\n  const validatedOptions = validate(QueryOptionsSchema, options);\n\n  logInfo('Executing query', { useToolingApi: validatedOptions.useToolingApi });\n\n  try {\n    let result: QueryResult<T>;\n\n    if (validatedOptions.useToolingApi) {\n      result = await executeToolingQuery<T>(validatedOptions.query, config);\n    } else {\n      result = await executeSoqlQuery<T>(validatedOptions.query, config);\n    }\n\n    // Limit records if maxRecords is specified\n    if (validatedOptions.maxRecords && result.records.length > validatedOptions.maxRecords) {\n      result.records = result.records.slice(0, validatedOptions.maxRecords);\n    }\n\n    return {\n      success: true,\n      data: result,\n      executionTime: timer.elapsed(),\n    };\n  } catch (error) {\n    logError('Query execution failed', { \n      error: error instanceof Error ? error.message : String(error) \n    });\n\n    return {\n      success: false,\n      data: { done: true, totalSize: 0, records: [] },\n      error: error instanceof Error ? error.message : String(error),\n      executionTime: timer.elapsed(),\n    };\n  }\n}\n\n/**\n * Execute multiple queries in batch\n * \n * @param request - Batch query request\n * @param config - Connection config\n * @returns Batch query results\n */\nexport async function executeBatchQueries(\n  request: BatchQueryRequest,\n  config?: SfConnectionConfig\n): Promise<BatchQueryResult> {\n  const timer = createTimer();\n  \n  logInfo(`Executing batch of ${request.queries.length} queries`);\n\n  const results: Record<string, QueryExecutionResult> = {};\n  const errors: Array<{ name: string; error: string }> = [];\n\n  // Execute queries in parallel with concurrency limit\n  const CONCURRENCY = 5;\n  const queries = [...request.queries];\n  \n  while (queries.length > 0) {\n    const batch = queries.splice(0, CONCURRENCY);\n    \n    await Promise.all(\n      batch.map(async (queryDef) => {\n        try {\n          const result = await executeQuery(\n            {\n              query: queryDef.query,\n              useToolingApi: queryDef.useToolingApi,\n            },\n            config\n          );\n          results[queryDef.name] = result;\n        } catch (error) {\n          const errorMsg = error instanceof Error ? error.message : String(error);\n          errors.push({ name: queryDef.name, error: errorMsg });\n          results[queryDef.name] = {\n            success: false,\n            data: { done: true, totalSize: 0, records: [] },\n            error: errorMsg,\n          };\n        }\n      })\n    );\n  }\n\n  const totalTime = timer.elapsed();\n  logInfo(`Batch execution completed in ${totalTime}ms`, {\n    successful: Object.values(results).filter(r => r.success).length,\n    failed: errors.length,\n  });\n\n  return {\n    results,\n    totalExecutionTime: totalTime,\n    errors,\n  };\n}\n\n/**\n * Execute a query and get all records (handles pagination)\n * \n * @param query - SOQL query string\n * @param config - Connection config\n * @returns All records from query\n */\nexport async function queryAll<T = Record<string, unknown>>(\n  query: string,\n  config?: SfConnectionConfig\n): Promise<T[]> {\n  const timer = createTimer();\n  \n  logInfo('Executing queryAll');\n  logDebug('Query', { query });\n\n  const { connection } = await createSfConnection(config);\n\n  const allRecords: T[] = [];\n  \n  const result = await retryWithBackoff(\n    () => connection.query<T>(query),\n    { ...RETRY_PRESETS.standard, operationName: 'queryAll-initial' }\n  );\n\n  allRecords.push(...result.records);\n\n  // Fetch additional records if there are more\n  let nextRecordsUrl = result.nextRecordsUrl;\n  while (nextRecordsUrl) {\n    logDebug(`Fetching more records from ${nextRecordsUrl}`);\n    \n    const moreResult = await retryWithBackoff(\n      () => connection.queryMore<T>(nextRecordsUrl as string),\n      { ...RETRY_PRESETS.standard, operationName: 'queryAll-more' }\n    );\n\n    allRecords.push(...moreResult.records);\n    nextRecordsUrl = moreResult.nextRecordsUrl;\n  }\n\n  logInfo(`queryAll returned ${allRecords.length} total records`);\n  timer.log('queryAll');\n\n  return allRecords;\n}\n\n/**\n * Count records matching a query\n * \n * @param objectName - SObject name\n * @param whereClause - Optional WHERE clause (without WHERE keyword)\n * @param config - Connection config\n * @returns Record count\n */\nexport async function countRecords(\n  objectName: string,\n  whereClause?: string,\n  config?: SfConnectionConfig\n): Promise<number> {\n  const query = whereClause\n    ? `SELECT COUNT() FROM ${objectName} WHERE ${whereClause}`\n    : `SELECT COUNT() FROM ${objectName}`;\n\n  const result = await executeSoqlQuery<{ expr0: number }>(query, config);\n  return result.totalSize;\n}\n\n/**\n * Check if any records exist matching criteria\n * \n * @param objectName - SObject name\n * @param whereClause - WHERE clause (without WHERE keyword)\n * @param config - Connection config\n * @returns True if records exist\n */\nexport async function recordsExist(\n  objectName: string,\n  whereClause: string,\n  config?: SfConnectionConfig\n): Promise<boolean> {\n  const query = `SELECT Id FROM ${objectName} WHERE ${whereClause} LIMIT 1`;\n  const result = await executeSoqlQuery(query, config);\n  return result.totalSize > 0;\n}\n","/**\n * Salesforce Metadata Describer\n * Describes objects, fields, and metadata\n */\n\nimport { createSfConnection, type SfConnectionConfig } from './sfClient.js';\nimport { executeToolingQuery } from './sfQueryExecutor.js';\nimport { retryWithBackoff, RETRY_PRESETS } from './lib/retryWithBackoff.js';\nimport { logInfo, logDebug, createTimer } from './lib/loggerStructured.js';\nimport type {\n  DescribeSObjectResult,\n  DescribeFieldResult,\n  EntityDefinition,\n  FieldDefinition,\n  ApexClass,\n  ApexTrigger,\n  ValidationRule,\n  Flow,\n} from './types/sfMetadataTypes.js';\n\n/**\n * Describe an SObject\n * \n * @param objectName - API name of the object\n * @param config - Connection config\n * @returns Object describe result\n */\nexport async function describeObject(\n  objectName: string,\n  config?: SfConnectionConfig\n): Promise<DescribeSObjectResult> {\n  const timer = createTimer();\n  \n  logInfo(`Describing object: ${objectName}`);\n\n  const { connection } = await createSfConnection(config);\n\n  const result = await retryWithBackoff(\n    () => connection.describe(objectName),\n    { ...RETRY_PRESETS.standard, operationName: `describeObject(${objectName})` }\n  );\n\n  // Convert to our type\n  const describe: DescribeSObjectResult = {\n    name: result.name,\n    label: result.label,\n    labelPlural: result.labelPlural,\n    keyPrefix: result.keyPrefix ?? '',\n    custom: result.custom,\n    customSetting: result.customSetting,\n    createable: result.createable,\n    updateable: result.updateable,\n    deletable: result.deletable,\n    queryable: result.queryable,\n    searchable: result.searchable,\n    layoutable: result.layoutable,\n    triggerable: result.triggerable,\n    fields: result.fields.map(f => ({\n      name: f.name,\n      label: f.label,\n      type: f.type,\n      length: f.length,\n      precision: f.precision,\n      scale: f.scale,\n      nillable: f.nillable,\n      unique: f.unique,\n      createable: f.createable,\n      updateable: f.updateable,\n      filterable: f.filterable,\n      sortable: f.sortable,\n      groupable: f.groupable,\n      custom: f.custom,\n      calculated: f.calculated,\n      defaultValue: f.defaultValue,\n      inlineHelpText: f.inlineHelpText ?? undefined,\n      picklistValues: f.picklistValues?.map(p => ({\n        value: p.value,\n        label: p.label,\n        active: p.active,\n        defaultValue: p.defaultValue,\n      })),\n      referenceTo: f.referenceTo,\n      relationshipName: f.relationshipName ?? undefined,\n    })),\n    recordTypeInfos: result.recordTypeInfos?.map(rt => ({\n      recordTypeId: rt.recordTypeId ?? '',\n      name: rt.name,\n      developerName: rt.developerName ?? '',\n      available: rt.available,\n      master: rt.master,\n      defaultRecordTypeMapping: rt.defaultRecordTypeMapping,\n    })),\n    childRelationships: result.childRelationships?.map(cr => ({\n      childSObject: cr.childSObject,\n      field: cr.field,\n      relationshipName: cr.relationshipName ?? '',\n      cascadeDelete: cr.cascadeDelete,\n      deprecatedAndHidden: cr.deprecatedAndHidden,\n      restrictedDelete: cr.restrictedDelete,\n    })),\n  };\n\n  logInfo(`Described ${objectName}: ${describe.fields.length} fields`);\n  timer.log(`describeObject(${objectName})`);\n\n  return describe;\n}\n\n/**\n * Describe a specific field\n * \n * @param objectName - Object API name\n * @param fieldName - Field API name\n * @param config - Connection config\n * @returns Field describe result\n */\nexport async function describeField(\n  objectName: string,\n  fieldName: string,\n  config?: SfConnectionConfig\n): Promise<DescribeFieldResult> {\n  const timer = createTimer();\n  \n  logInfo(`Describing field: ${objectName}.${fieldName}`);\n\n  const objectDescribe = await describeObject(objectName, config);\n  \n  const field = objectDescribe.fields.find(\n    f => f.name.toLowerCase() === fieldName.toLowerCase()\n  );\n\n  if (!field) {\n    throw new Error(`Field ${fieldName} not found on ${objectName}`);\n  }\n\n  timer.log(`describeField(${objectName}.${fieldName})`);\n  return field;\n}\n\n/**\n * Get entity definition from Tooling API\n * \n * @param objectName - Object API name\n * @param config - Connection config\n * @returns Entity definition\n */\nexport async function getEntityDefinition(\n  objectName: string,\n  config?: SfConnectionConfig\n): Promise<EntityDefinition | undefined> {\n  const timer = createTimer();\n  \n  logInfo(`Getting entity definition: ${objectName}`);\n\n  const query = `\n    SELECT Id, DurableId, QualifiedApiName, NamespacePrefix, DeveloperName,\n           MasterLabel, Label, PluralLabel, KeyPrefix, IsCustomSetting,\n           IsCustomizable, IsApexTriggerable, IsWorkflowEnabled, IsProcessEnabled,\n           IsLayoutable, IsCompactLayoutable, DeploymentStatus, IsSearchable,\n           IsQueryable, IsIdEnabled, IsReplicateable, IsRetrieveable,\n           IsCreateable, IsUpdateable, IsDeletable, IsUndeletable, IsMergeable,\n           InternalSharingModel, ExternalSharingModel, PublisherId\n    FROM EntityDefinition\n    WHERE QualifiedApiName = '${objectName}'\n  `;\n\n  const result = await executeToolingQuery<EntityDefinition>(query, config);\n  \n  timer.log(`getEntityDefinition(${objectName})`);\n  return result.records[0];\n}\n\n/**\n * Get field definitions for an object from Tooling API\n * \n * @param objectName - Object API name\n * @param config - Connection config\n * @returns Array of field definitions\n */\nexport async function getFieldDefinitions(\n  objectName: string,\n  config?: SfConnectionConfig\n): Promise<FieldDefinition[]> {\n  const timer = createTimer();\n  \n  logInfo(`Getting field definitions for: ${objectName}`);\n\n  // First get the EntityDefinition to get its DurableId\n  const entity = await getEntityDefinition(objectName, config);\n  if (!entity) {\n    throw new Error(`Entity ${objectName} not found`);\n  }\n\n  const query = `\n    SELECT Id, DurableId, QualifiedApiName, EntityDefinitionId, NamespacePrefix,\n           DeveloperName, MasterLabel, Label, Length, DataType, ValueTypeId,\n           ReferenceTo, ReferenceTargetField, IsCompound, IsHighScaleNumber,\n           IsHtmlFormatted, IsNameField, IsNillable, IsCalculated,\n           IsApiFilterable, IsApiSortable, IsApiGroupable, IsPolymorphicForeignKey,\n           IsCompactLayoutable, Precision, Scale, IsFieldHistoryTracked,\n           IsIndexed, IsUnique, IsDeprecatedAndHidden, Description,\n           InlineHelpText, RelationshipName, LastModifiedDate, PublisherId\n    FROM FieldDefinition\n    WHERE EntityDefinitionId = '${entity.DurableId}'\n  `;\n\n  const result = await executeToolingQuery<FieldDefinition>(query, config);\n  \n  logInfo(`Got ${result.records.length} field definitions for ${objectName}`);\n  timer.log(`getFieldDefinitions(${objectName})`);\n  \n  return result.records;\n}\n\n/**\n * Get Apex classes\n * \n * @param namePattern - Optional name pattern (use % for wildcard)\n * @param config - Connection config\n * @returns Array of Apex classes\n */\nexport async function getApexClasses(\n  namePattern?: string,\n  config?: SfConnectionConfig\n): Promise<ApexClass[]> {\n  const timer = createTimer();\n  \n  logInfo('Getting Apex classes', { namePattern });\n\n  let query = `\n    SELECT Id, Name, NamespacePrefix, ApiVersion, Status, IsValid, LengthWithoutComments\n    FROM ApexClass\n  `;\n\n  if (namePattern) {\n    query += ` WHERE Name LIKE '${namePattern}'`;\n  }\n\n  query += ' ORDER BY Name';\n\n  const result = await executeToolingQuery<ApexClass>(query, config);\n  \n  logInfo(`Got ${result.records.length} Apex classes`);\n  timer.log('getApexClasses');\n  \n  return result.records;\n}\n\n/**\n * Get Apex triggers for an object\n * \n * @param objectName - Object API name (optional)\n * @param config - Connection config\n * @returns Array of Apex triggers\n */\nexport async function getApexTriggers(\n  objectName?: string,\n  config?: SfConnectionConfig\n): Promise<ApexTrigger[]> {\n  const timer = createTimer();\n  \n  logInfo('Getting Apex triggers', { objectName });\n\n  let query = `\n    SELECT Id, Name, NamespacePrefix, TableEnumOrId, ApiVersion, Status, IsValid,\n           LengthWithoutComments, UsageBeforeInsert, UsageAfterInsert,\n           UsageBeforeUpdate, UsageAfterUpdate, UsageBeforeDelete,\n           UsageAfterDelete, UsageAfterUndelete, UsageIsBulk\n    FROM ApexTrigger\n  `;\n\n  if (objectName) {\n    query += ` WHERE TableEnumOrId = '${objectName}'`;\n  }\n\n  query += ' ORDER BY Name';\n\n  const result = await executeToolingQuery<ApexTrigger>(query, config);\n  \n  logInfo(`Got ${result.records.length} Apex triggers`);\n  timer.log('getApexTriggers');\n  \n  return result.records;\n}\n\n/**\n * Get validation rules for an object\n * \n * @param objectName - Object API name\n * @param activeOnly - Only return active rules\n * @param config - Connection config\n * @returns Array of validation rules\n */\nexport async function getValidationRules(\n  objectName: string,\n  activeOnly = true,\n  config?: SfConnectionConfig\n): Promise<ValidationRule[]> {\n  const timer = createTimer();\n  \n  logInfo(`Getting validation rules for: ${objectName}`);\n\n  // Get entity definition first\n  const entity = await getEntityDefinition(objectName, config);\n  if (!entity) {\n    throw new Error(`Entity ${objectName} not found`);\n  }\n\n  let query = `\n    SELECT Id, ValidationName, EntityDefinitionId, Active, Description,\n           ErrorDisplayField, ErrorMessage, FullName, Metadata\n    FROM ValidationRule\n    WHERE EntityDefinitionId = '${entity.DurableId}'\n  `;\n\n  if (activeOnly) {\n    query += ' AND Active = true';\n  }\n\n  const result = await executeToolingQuery<ValidationRule>(query, config);\n  \n  logInfo(`Got ${result.records.length} validation rules for ${objectName}`);\n  timer.log(`getValidationRules(${objectName})`);\n  \n  return result.records;\n}\n\n/**\n * Get flows related to an object\n * \n * @param objectName - Object API name (optional)\n * @param activeOnly - Only return active flows\n * @param config - Connection config\n * @returns Array of flows\n */\nexport async function getFlows(\n  objectName?: string,\n  activeOnly = true,\n  config?: SfConnectionConfig\n): Promise<Flow[]> {\n  const timer = createTimer();\n  \n  logInfo('Getting flows', { objectName, activeOnly });\n\n  let query = `\n    SELECT Id, DeveloperName, MasterLabel, NamespacePrefix, ApiVersion,\n           ProcessType, Status, Description, TriggerType, TriggerObjectOrEvent,\n           RecordTriggerType, IsActive, IsTemplate, RunInMode,\n           LastModifiedDate, LastModifiedById\n    FROM Flow\n  `;\n\n  const conditions: string[] = [];\n\n  if (objectName) {\n    conditions.push(`TriggerObjectOrEvent = '${objectName}'`);\n  }\n\n  if (activeOnly) {\n    conditions.push('IsActive = true');\n  }\n\n  if (conditions.length > 0) {\n    query += ` WHERE ${conditions.join(' AND ')}`;\n  }\n\n  query += ' ORDER BY MasterLabel';\n\n  const result = await executeToolingQuery<Flow>(query, config);\n  \n  logInfo(`Got ${result.records.length} flows`);\n  timer.log('getFlows');\n  \n  return result.records;\n}\n\n/**\n * Get all custom objects\n * \n * @param config - Connection config\n * @returns Array of custom object names\n */\nexport async function getCustomObjects(\n  config?: SfConnectionConfig\n): Promise<string[]> {\n  const timer = createTimer();\n  \n  logInfo('Getting custom objects');\n\n  const query = `\n    SELECT QualifiedApiName\n    FROM EntityDefinition\n    WHERE IsCustomizable = true AND IsCustomSetting = false\n    ORDER BY QualifiedApiName\n  `;\n\n  const result = await executeToolingQuery<{ QualifiedApiName: string }>(query, config);\n  \n  const customObjects = result.records\n    .map(r => r.QualifiedApiName)\n    .filter(name => name.endsWith('__c'));\n\n  logInfo(`Got ${customObjects.length} custom objects`);\n  timer.log('getCustomObjects');\n  \n  return customObjects;\n}\n","/**\n * Salesforce Dependency Traverser\n * Traverses and analyzes dependency graphs\n */\n\nimport { logDebug, logWarn } from './lib/loggerStructured.js';\nimport type {\n  DependencyNode,\n  DependencyEdge,\n  DependencyGraph,\n  TraversalOptions,\n  CycleDetectionResult,\n} from './types/sfDependencyTypes.js';\n\n/**\n * Traverse dependencies using depth-first search\n * \n * @param graph - Dependency graph to traverse\n * @param options - Traversal options\n * @returns Visited nodes in order\n */\nexport function traverseDependencies(\n  graph: DependencyGraph,\n  options: TraversalOptions\n): DependencyNode[] {\n  const visited = new Set<string>();\n  const result: DependencyNode[] = [];\n  const stack: string[] = [];\n\n  function dfs(nodeId: string, depth: number): void {\n    if (depth > options.maxDepth) {\n      return;\n    }\n\n    if (visited.has(nodeId)) {\n      if (options.detectCycles && stack.includes(nodeId)) {\n        const cycleStart = stack.indexOf(nodeId);\n        const cyclePath = [...stack.slice(cycleStart), nodeId];\n        \n        logWarn('Cycle detected', { path: cyclePath });\n        \n        if (options.onCycleDetected) {\n          options.onCycleDetected(cyclePath);\n        }\n      }\n      return;\n    }\n\n    visited.add(nodeId);\n    stack.push(nodeId);\n\n    const node = graph.nodes.get(nodeId);\n    if (node) {\n      result.push(node);\n      \n      if (options.onNodeVisit) {\n        options.onNodeVisit(node);\n      }\n\n      // Find outgoing edges\n      const outgoingEdges = graph.edges.filter(e => e.sourceId === nodeId);\n      \n      for (const edge of outgoingEdges) {\n        dfs(edge.targetId, depth + 1);\n      }\n    }\n\n    stack.pop();\n  }\n\n  dfs(graph.rootId, 0);\n  return result;\n}\n\n/**\n * Detect cycles in the dependency graph\n * \n * @param nodes - Map of nodes\n * @param edges - Array of edges\n * @param startNodeId - Starting node ID\n * @returns Cycle detection result\n */\nexport function detectCycles(\n  nodes: Map<string, DependencyNode>,\n  edges: DependencyEdge[],\n  startNodeId: string\n): CycleDetectionResult {\n  const visited = new Set<string>();\n  const recursionStack = new Set<string>();\n  const cycles: string[][] = [];\n\n  // Build adjacency list\n  const adjacencyList = new Map<string, string[]>();\n  for (const edge of edges) {\n    if (!adjacencyList.has(edge.sourceId)) {\n      adjacencyList.set(edge.sourceId, []);\n    }\n    adjacencyList.get(edge.sourceId)!.push(edge.targetId);\n  }\n\n  function dfs(nodeId: string, path: string[]): void {\n    visited.add(nodeId);\n    recursionStack.add(nodeId);\n    path.push(nodeId);\n\n    const neighbors = adjacencyList.get(nodeId) ?? [];\n    \n    for (const neighbor of neighbors) {\n      if (!visited.has(neighbor)) {\n        dfs(neighbor, [...path]);\n      } else if (recursionStack.has(neighbor)) {\n        // Cycle found\n        const cycleStart = path.indexOf(neighbor);\n        if (cycleStart !== -1) {\n          const cycle = path.slice(cycleStart);\n          cycle.push(neighbor); // Complete the cycle\n          cycles.push(cycle);\n        }\n      }\n    }\n\n    recursionStack.delete(nodeId);\n  }\n\n  // Start DFS from all nodes to catch disconnected components\n  for (const nodeId of nodes.keys()) {\n    if (!visited.has(nodeId)) {\n      dfs(nodeId, []);\n    }\n  }\n\n  return {\n    hasCycles: cycles.length > 0,\n    cycles,\n    visitedNodes: visited,\n  };\n}\n\n/**\n * Get all nodes at a specific depth\n * \n * @param graph - Dependency graph\n * @param depth - Target depth\n * @returns Nodes at the specified depth\n */\nexport function getNodesAtDepth(\n  graph: DependencyGraph,\n  depth: number\n): DependencyNode[] {\n  return Array.from(graph.nodes.values()).filter(n => n.depth === depth);\n}\n\n/**\n * Get all leaf nodes (nodes with no outgoing edges)\n * \n * @param graph - Dependency graph\n * @returns Leaf nodes\n */\nexport function getLeafNodes(graph: DependencyGraph): DependencyNode[] {\n  const nodesWithOutgoing = new Set(graph.edges.map(e => e.sourceId));\n  \n  return Array.from(graph.nodes.values()).filter(\n    n => !nodesWithOutgoing.has(n.id)\n  );\n}\n\n/**\n * Get all root nodes (nodes with no incoming edges)\n * \n * @param graph - Dependency graph\n * @returns Root nodes\n */\nexport function getRootNodes(graph: DependencyGraph): DependencyNode[] {\n  const nodesWithIncoming = new Set(graph.edges.map(e => e.targetId));\n  \n  return Array.from(graph.nodes.values()).filter(\n    n => !nodesWithIncoming.has(n.id)\n  );\n}\n\n/**\n * Get the path from root to a specific node\n * \n * @param graph - Dependency graph\n * @param targetNodeId - Target node ID\n * @returns Path of node IDs from root to target\n */\nexport function getPathToNode(\n  graph: DependencyGraph,\n  targetNodeId: string\n): string[] | null {\n  const visited = new Set<string>();\n  const parent = new Map<string, string>();\n\n  function bfs(): boolean {\n    const queue: string[] = [graph.rootId];\n    visited.add(graph.rootId);\n\n    while (queue.length > 0) {\n      const current = queue.shift()!;\n      \n      if (current === targetNodeId) {\n        return true;\n      }\n\n      const outgoingEdges = graph.edges.filter(e => e.sourceId === current);\n      \n      for (const edge of outgoingEdges) {\n        if (!visited.has(edge.targetId)) {\n          visited.add(edge.targetId);\n          parent.set(edge.targetId, current);\n          queue.push(edge.targetId);\n        }\n      }\n    }\n\n    return false;\n  }\n\n  if (!bfs()) {\n    return null;\n  }\n\n  // Reconstruct path\n  const path: string[] = [];\n  let current: string | undefined = targetNodeId;\n  \n  while (current !== undefined) {\n    path.unshift(current);\n    current = parent.get(current);\n  }\n\n  return path;\n}\n\n/**\n * Get all dependencies of a node (direct and transitive)\n * \n * @param graph - Dependency graph\n * @param nodeId - Node ID\n * @returns Set of dependency node IDs\n */\nexport function getAllDependencies(\n  graph: DependencyGraph,\n  nodeId: string\n): Set<string> {\n  const dependencies = new Set<string>();\n  const visited = new Set<string>();\n\n  function collect(currentId: string): void {\n    if (visited.has(currentId)) return;\n    visited.add(currentId);\n\n    const outgoingEdges = graph.edges.filter(e => e.sourceId === currentId);\n    \n    for (const edge of outgoingEdges) {\n      dependencies.add(edge.targetId);\n      collect(edge.targetId);\n    }\n  }\n\n  collect(nodeId);\n  return dependencies;\n}\n\n/**\n * Get all dependents of a node (nodes that depend on this node)\n * \n * @param graph - Dependency graph\n * @param nodeId - Node ID\n * @returns Set of dependent node IDs\n */\nexport function getAllDependents(\n  graph: DependencyGraph,\n  nodeId: string\n): Set<string> {\n  const dependents = new Set<string>();\n  const visited = new Set<string>();\n\n  function collect(currentId: string): void {\n    if (visited.has(currentId)) return;\n    visited.add(currentId);\n\n    const incomingEdges = graph.edges.filter(e => e.targetId === currentId);\n    \n    for (const edge of incomingEdges) {\n      dependents.add(edge.sourceId);\n      collect(edge.sourceId);\n    }\n  }\n\n  collect(nodeId);\n  return dependents;\n}\n\n/**\n * Calculate the impact score for a node\n * Higher score = more components depend on this node\n * \n * @param graph - Dependency graph\n * @param nodeId - Node ID\n * @returns Impact score\n */\nexport function calculateImpactScore(\n  graph: DependencyGraph,\n  nodeId: string\n): number {\n  const dependents = getAllDependents(graph, nodeId);\n  return dependents.size;\n}\n\n/**\n * Sort nodes by impact score (most impactful first)\n * \n * @param graph - Dependency graph\n * @returns Sorted array of nodes with scores\n */\nexport function sortByImpact(\n  graph: DependencyGraph\n): Array<{ node: DependencyNode; score: number }> {\n  const results: Array<{ node: DependencyNode; score: number }> = [];\n\n  for (const node of graph.nodes.values()) {\n    const score = calculateImpactScore(graph, node.id);\n    results.push({ node, score });\n  }\n\n  return results.sort((a, b) => b.score - a.score);\n}\n\n/**\n * Get subgraph for a specific node and its dependencies\n * \n * @param graph - Original dependency graph\n * @param nodeId - Node ID to extract subgraph for\n * @param includeDepth - How many levels of dependencies to include\n * @returns Subgraph\n */\nexport function extractSubgraph(\n  graph: DependencyGraph,\n  nodeId: string,\n  includeDepth: number = Infinity\n): DependencyGraph {\n  const subNodes = new Map<string, DependencyNode>();\n  const subEdges: DependencyEdge[] = [];\n  const visited = new Set<string>();\n\n  function collect(currentId: string, depth: number): void {\n    if (visited.has(currentId) || depth > includeDepth) return;\n    visited.add(currentId);\n\n    const node = graph.nodes.get(currentId);\n    if (node) {\n      subNodes.set(currentId, { ...node, depth });\n    }\n\n    const outgoingEdges = graph.edges.filter(e => e.sourceId === currentId);\n    \n    for (const edge of outgoingEdges) {\n      subEdges.push(edge);\n      collect(edge.targetId, depth + 1);\n    }\n  }\n\n  collect(nodeId, 0);\n\n  return {\n    nodes: subNodes,\n    edges: subEdges,\n    rootId: nodeId,\n    metadata: {\n      ...graph.metadata,\n      rootName: graph.nodes.get(nodeId)?.name ?? nodeId,\n      nodeCount: subNodes.size,\n      edgeCount: subEdges.length,\n    },\n  };\n}\n","/**\n * Salesforce Dependency Enrichment\n * Enriches dependency graphs with usage information and pills\n */\n\nimport { executeToolingQuery } from './sfQueryExecutor.js';\nimport { logInfo, logDebug, createTimer } from './lib/loggerStructured.js';\nimport type { SfConnectionConfig } from './sfClient.js';\nimport type {\n  DependencyGraph,\n  DependencyNode,\n  UsagePill,\n  UsagePillType,\n  UsageSeverity,\n  EnrichmentOptions,\n  EnrichmentResult,\n} from './types/sfDependencyTypes.js';\n\n/**\n * Default enrichment options\n */\nconst DEFAULT_ENRICHMENT_OPTIONS: EnrichmentOptions = {\n  includeApexUsage: true,\n  includeFlowUsage: true,\n  includeValidationUsage: true,\n  includeWorkflowUsage: true,\n  includeFormulaUsage: false,\n  includeLayoutUsage: false,\n  includeReportUsage: false,\n};\n\n/**\n * Enrich a dependency graph with usage pills\n * \n * @param graph - Dependency graph to enrich\n * @param config - Connection config\n * @param options - Enrichment options\n * @returns Array of usage pills\n */\nexport async function enrichWithUsagePills(\n  graph: DependencyGraph,\n  config?: SfConnectionConfig,\n  options: EnrichmentOptions = DEFAULT_ENRICHMENT_OPTIONS\n): Promise<UsagePill[]> {\n  const timer = createTimer();\n  const pills: UsagePill[] = [];\n\n  logInfo('Enriching graph with usage pills');\n\n  // Collect all field and object names for querying\n  const objectNames = new Set<string>();\n  const fieldNames = new Set<string>();\n\n  for (const node of graph.nodes.values()) {\n    if (node.type === 'CustomObject') {\n      objectNames.add(node.apiName);\n    } else if (node.type === 'CustomField') {\n      fieldNames.add(node.apiName);\n    }\n  }\n\n  // Enrich with Apex usage\n  if (options.includeApexUsage && (objectNames.size > 0 || fieldNames.size > 0)) {\n    const apexPills = await analyzeApexUsage(objectNames, fieldNames, config);\n    pills.push(...apexPills);\n  }\n\n  // Enrich with Flow usage\n  if (options.includeFlowUsage && objectNames.size > 0) {\n    const flowPills = await analyzeFlowUsage(objectNames, config);\n    pills.push(...flowPills);\n  }\n\n  // Enrich with Validation Rule usage\n  if (options.includeValidationUsage && fieldNames.size > 0) {\n    const validationPills = await analyzeValidationUsage(fieldNames, config);\n    pills.push(...validationPills);\n  }\n\n  logInfo(`Created ${pills.length} usage pills`);\n  timer.log('enrichWithUsagePills');\n\n  return pills;\n}\n\n/**\n * Analyze Apex code for field/object usage\n */\nasync function analyzeApexUsage(\n  objectNames: Set<string>,\n  fieldNames: Set<string>,\n  config?: SfConnectionConfig\n): Promise<UsagePill[]> {\n  const pills: UsagePill[] = [];\n\n  if (objectNames.size === 0 && fieldNames.size === 0) {\n    return pills;\n  }\n\n  logDebug('Analyzing Apex usage');\n\n  // Query Apex classes that might reference these objects\n  for (const objectName of objectNames) {\n    try {\n      const query = `\n        SELECT Id, Name FROM ApexClass \n        WHERE Status = 'Active'\n        LIMIT 100\n      `;\n      \n      const result = await executeToolingQuery<{ Id: string; Name: string }>(query, config);\n      \n      // For each class, we would ideally parse the body to find references\n      // For now, create a general pill indicating potential Apex usage\n      if (result.records.length > 0) {\n        pills.push(createPill({\n          type: 'apex_usage',\n          label: `${objectName} Apex Usage`,\n          description: `${result.records.length} Apex classes in org may reference this object`,\n          severity: 'info',\n          affectedComponents: result.records.slice(0, 10).map(r => r.Name),\n          recommendation: 'Review Apex classes for direct object references before making schema changes',\n        }));\n      }\n    } catch (error) {\n      logDebug(`Error analyzing Apex for ${objectName}: ${error}`);\n    }\n  }\n\n  return pills;\n}\n\n/**\n * Analyze Flows for object usage\n */\nasync function analyzeFlowUsage(\n  objectNames: Set<string>,\n  config?: SfConnectionConfig\n): Promise<UsagePill[]> {\n  const pills: UsagePill[] = [];\n\n  logDebug('Analyzing Flow usage');\n\n  for (const objectName of objectNames) {\n    try {\n      const query = `\n        SELECT Id, MasterLabel, ProcessType, Status\n        FROM Flow\n        WHERE TriggerObjectOrEvent = '${objectName}'\n        AND IsActive = true\n      `;\n      \n      const result = await executeToolingQuery<{\n        Id: string;\n        MasterLabel: string;\n        ProcessType: string;\n        Status: string;\n      }>(query, config);\n      \n      if (result.records.length > 0) {\n        const severity: UsageSeverity = result.records.length > 3 ? 'warning' : 'info';\n        \n        pills.push(createPill({\n          type: 'flow_usage',\n          label: `${objectName} Flow Usage`,\n          description: `${result.records.length} active Flow(s) trigger on this object`,\n          severity,\n          affectedComponents: result.records.map(r => r.MasterLabel),\n          recommendation: severity === 'warning' \n            ? 'Multiple flows may cause performance issues or conflicts'\n            : 'Review flows before making changes to this object',\n        }));\n      }\n    } catch (error) {\n      logDebug(`Error analyzing Flows for ${objectName}: ${error}`);\n    }\n  }\n\n  return pills;\n}\n\n/**\n * Analyze Validation Rules for field usage\n */\nasync function analyzeValidationUsage(\n  fieldNames: Set<string>,\n  config?: SfConnectionConfig\n): Promise<UsagePill[]> {\n  const pills: UsagePill[] = [];\n\n  logDebug('Analyzing Validation Rule usage');\n\n  // Group fields by object\n  const fieldsByObject = new Map<string, string[]>();\n  \n  for (const fieldName of fieldNames) {\n    const parts = fieldName.split('.');\n    if (parts.length === 2) {\n      const objectName = parts[0];\n      const field = parts[1];\n      \n      if (!fieldsByObject.has(objectName!)) {\n        fieldsByObject.set(objectName!, []);\n      }\n      fieldsByObject.get(objectName!)!.push(field!);\n    }\n  }\n\n  for (const [objectName, fields] of fieldsByObject) {\n    try {\n      const query = `\n        SELECT Id, ValidationName, ErrorMessage, Active\n        FROM ValidationRule\n        WHERE EntityDefinition.QualifiedApiName = '${objectName}'\n        AND Active = true\n      `;\n      \n      const result = await executeToolingQuery<{\n        Id: string;\n        ValidationName: string;\n        ErrorMessage: string;\n        Active: boolean;\n      }>(query, config);\n      \n      if (result.records.length > 0) {\n        pills.push(createPill({\n          type: 'validation_usage',\n          label: `${objectName} Validation Rules`,\n          description: `${result.records.length} active validation rule(s) on this object`,\n          severity: 'info',\n          affectedComponents: result.records.map(r => r.ValidationName),\n          recommendation: 'Review validation rules when modifying fields on this object',\n        }));\n      }\n    } catch (error) {\n      logDebug(`Error analyzing Validation Rules for ${objectName}: ${error}`);\n    }\n  }\n\n  return pills;\n}\n\n/**\n * Create a usage pill with a unique ID\n */\nexport function createPill(options: Omit<UsagePill, 'id'>): UsagePill {\n  return {\n    id: `pill_${Date.now()}_${Math.random().toString(36).substring(7)}`,\n    ...options,\n  };\n}\n\n/**\n * Filter pills by severity\n */\nexport function filterPillsBySeverity(\n  pills: UsagePill[],\n  minSeverity: UsageSeverity\n): UsagePill[] {\n  const severityOrder: Record<UsageSeverity, number> = {\n    info: 0,\n    warning: 1,\n    critical: 2,\n  };\n\n  const minLevel = severityOrder[minSeverity];\n  return pills.filter(p => severityOrder[p.severity] >= minLevel);\n}\n\n/**\n * Filter pills by type\n */\nexport function filterPillsByType(\n  pills: UsagePill[],\n  types: UsagePillType[]\n): UsagePill[] {\n  return pills.filter(p => types.includes(p.type));\n}\n\n/**\n * Group pills by severity\n */\nexport function groupPillsBySeverity(\n  pills: UsagePill[]\n): Record<UsageSeverity, UsagePill[]> {\n  const result: Record<UsageSeverity, UsagePill[]> = {\n    info: [],\n    warning: [],\n    critical: [],\n  };\n\n  for (const pill of pills) {\n    result[pill.severity].push(pill);\n  }\n\n  return result;\n}\n\n/**\n * Get summary of pills\n */\nexport function getPillsSummary(pills: UsagePill[]): PillsSummary {\n  const grouped = groupPillsBySeverity(pills);\n  \n  return {\n    total: pills.length,\n    byCategory: {\n      info: grouped.info.length,\n      warning: grouped.warning.length,\n      critical: grouped.critical.length,\n    },\n    topRecommendations: pills\n      .filter(p => p.recommendation)\n      .slice(0, 5)\n      .map(p => p.recommendation!),\n  };\n}\n\n/**\n * Pills summary interface\n */\nexport interface PillsSummary {\n  total: number;\n  byCategory: Record<UsageSeverity, number>;\n  topRecommendations: string[];\n}\n\n/**\n * Format pills for display\n */\nexport function formatPillsForDisplay(pills: UsagePill[]): string {\n  const lines: string[] = [];\n  const grouped = groupPillsBySeverity(pills);\n\n  if (grouped.critical.length > 0) {\n    lines.push(' CRITICAL:');\n    for (const pill of grouped.critical) {\n      lines.push(`  - ${pill.label}: ${pill.description}`);\n    }\n    lines.push('');\n  }\n\n  if (grouped.warning.length > 0) {\n    lines.push(' WARNINGS:');\n    for (const pill of grouped.warning) {\n      lines.push(`  - ${pill.label}: ${pill.description}`);\n    }\n    lines.push('');\n  }\n\n  if (grouped.info.length > 0) {\n    lines.push(' INFO:');\n    for (const pill of grouped.info) {\n      lines.push(`  - ${pill.label}: ${pill.description}`);\n    }\n  }\n\n  return lines.join('\\n');\n}\n","/**\n * Salesforce Dependency Discovery\n * Discovers metadata dependencies for a given component\n */\n\nimport { createSfConnection, type SfConnectionConfig } from './sfClient.js';\nimport { executeToolingQuery, executeSoqlQuery } from './sfQueryExecutor.js';\nimport { traverseDependencies, detectCycles } from './sfDependencyTraverser.js';\nimport { enrichWithUsagePills } from './sfDependencyEnrichment.js';\nimport { logInfo, logDebug, logWarn, createTimer } from './lib/loggerStructured.js';\nimport { validate, DiscoverDependenciesOptionsSchema } from './lib/validationSchemas.js';\nimport type {\n  DependencyNode,\n  DependencyEdge,\n  DependencyGraph,\n  DependencyGraphMetadata,\n  DiscoverDependenciesOptions,\n  DiscoveryResult,\n  MetadataType,\n  DependencyRelationship,\n} from './types/sfDependencyTypes.js';\n\n/**\n * Discover all dependencies for a metadata component\n * \n * @param options - Discovery options\n * @param config - Connection config\n * @returns Discovery result with graph and pills\n */\nexport async function discoverDependencies(\n  options: DiscoverDependenciesOptions,\n  config?: SfConnectionConfig\n): Promise<DiscoveryResult> {\n  const timer = createTimer();\n  const validatedOptions = validate(DiscoverDependenciesOptionsSchema, options);\n\n  const { rootType, rootName, maxDepth = 3 } = validatedOptions;\n\n  logInfo(`Discovering dependencies for ${rootType}:${rootName}`, { maxDepth });\n\n  const nodes = new Map<string, DependencyNode>();\n  const edges: DependencyEdge[] = [];\n  const warnings: string[] = [];\n\n  // Create root node\n  const rootId = createNodeId(rootType, rootName);\n  const rootNode: DependencyNode = {\n    id: rootId,\n    name: rootName,\n    type: rootType,\n    apiName: rootName,\n    depth: 0,\n    isLeaf: false,\n  };\n  nodes.set(rootId, rootNode);\n\n  // Discover dependencies based on type\n  try {\n    await discoverForType(\n      rootType,\n      rootName,\n      0,\n      maxDepth,\n      nodes,\n      edges,\n      warnings,\n      validatedOptions,\n      config\n    );\n  } catch (error) {\n    warnings.push(`Error discovering dependencies: ${error instanceof Error ? error.message : String(error)}`);\n  }\n\n  // Detect cycles\n  const cycleResult = detectCycles(nodes, edges, rootId);\n  if (cycleResult.hasCycles) {\n    logWarn(`Circular dependencies detected`, { cycles: cycleResult.cycles });\n    \n    // Mark circular nodes\n    for (const cycle of cycleResult.cycles) {\n      for (const nodeId of cycle) {\n        const node = nodes.get(nodeId);\n        if (node) {\n          node.isCircular = true;\n        }\n      }\n    }\n  }\n\n  // Build graph metadata\n  const metadata: DependencyGraphMetadata = {\n    generatedAt: new Date().toISOString(),\n    rootType,\n    rootName,\n    maxDepth,\n    nodeCount: nodes.size,\n    edgeCount: edges.length,\n    hasCircularDependencies: cycleResult.hasCycles,\n    circularPaths: cycleResult.hasCycles ? cycleResult.cycles : undefined,\n  };\n\n  const graph: DependencyGraph = {\n    nodes,\n    edges,\n    rootId,\n    metadata,\n  };\n\n  // Enrich with usage pills\n  const pills = await enrichWithUsagePills(graph, config);\n\n  const executionTime = timer.elapsed();\n  logInfo(`Dependency discovery complete`, { \n    nodes: nodes.size, \n    edges: edges.length,\n    executionTime \n  });\n\n  return {\n    graph,\n    pills,\n    warnings,\n    executionTime,\n  };\n}\n\n/**\n * Create a unique node ID\n */\nfunction createNodeId(type: MetadataType, name: string): string {\n  return `${type}:${name}`;\n}\n\n/**\n * Discover dependencies for a specific metadata type\n */\nasync function discoverForType(\n  type: MetadataType,\n  name: string,\n  currentDepth: number,\n  maxDepth: number,\n  nodes: Map<string, DependencyNode>,\n  edges: DependencyEdge[],\n  warnings: string[],\n  options: DiscoverDependenciesOptions,\n  config?: SfConnectionConfig\n): Promise<void> {\n  if (currentDepth >= maxDepth) {\n    return;\n  }\n\n  logDebug(`Discovering ${type}:${name} at depth ${currentDepth}`);\n\n  switch (type) {\n    case 'CustomObject':\n      await discoverCustomObjectDependencies(name, currentDepth, maxDepth, nodes, edges, warnings, options, config);\n      break;\n    case 'CustomField':\n      await discoverCustomFieldDependencies(name, currentDepth, maxDepth, nodes, edges, warnings, options, config);\n      break;\n    case 'ApexClass':\n      await discoverApexClassDependencies(name, currentDepth, maxDepth, nodes, edges, warnings, options, config);\n      break;\n    case 'ApexTrigger':\n      await discoverApexTriggerDependencies(name, currentDepth, maxDepth, nodes, edges, warnings, options, config);\n      break;\n    case 'Flow':\n      await discoverFlowDependencies(name, currentDepth, maxDepth, nodes, edges, warnings, options, config);\n      break;\n    default:\n      logDebug(`No specific discovery for type ${type}`);\n  }\n}\n\n/**\n * Discover dependencies for a CustomObject\n */\nasync function discoverCustomObjectDependencies(\n  objectName: string,\n  currentDepth: number,\n  maxDepth: number,\n  nodes: Map<string, DependencyNode>,\n  edges: DependencyEdge[],\n  warnings: string[],\n  options: DiscoverDependenciesOptions,\n  config?: SfConnectionConfig\n): Promise<void> {\n  const sourceId = createNodeId('CustomObject', objectName);\n\n  // Get custom fields (filter by __c suffix since IsCustom isn't available on FieldDefinition)\n  const fieldsQuery = `\n    SELECT QualifiedApiName, DataType, ReferenceTo, RelationshipName\n    FROM FieldDefinition\n    WHERE EntityDefinition.QualifiedApiName = '${objectName}'\n    AND QualifiedApiName LIKE '%__c'\n  `;\n\n  try {\n    const fields = await executeToolingQuery<{\n      QualifiedApiName: string;\n      DataType: string;\n      ReferenceTo: { referenceTo: string[] } | null;\n      RelationshipName: string | null;\n    }>(fieldsQuery, config);\n\n    for (const field of fields.records) {\n      const fieldId = createNodeId('CustomField', `${objectName}.${field.QualifiedApiName}`);\n      \n      if (!nodes.has(fieldId)) {\n        nodes.set(fieldId, {\n          id: fieldId,\n          name: field.QualifiedApiName,\n          type: 'CustomField',\n          apiName: `${objectName}.${field.QualifiedApiName}`,\n          depth: currentDepth + 1,\n          isLeaf: true,\n          parentId: sourceId,\n        });\n      }\n\n      edges.push({\n        sourceId,\n        targetId: fieldId,\n        relationshipType: 'contains',\n      });\n\n      // Track lookup relationships\n      if (field.ReferenceTo?.referenceTo && field.ReferenceTo.referenceTo.length > 0) {\n        for (const refTo of field.ReferenceTo.referenceTo) {\n          if (!options.includeStandardObjects && !refTo.endsWith('__c')) {\n            continue;\n          }\n\n          const refId = createNodeId('CustomObject', refTo);\n          \n          if (!nodes.has(refId)) {\n            nodes.set(refId, {\n              id: refId,\n              name: refTo,\n              type: 'CustomObject',\n              apiName: refTo,\n              depth: currentDepth + 2,\n              isLeaf: currentDepth + 2 >= maxDepth,\n            });\n\n            // Recursively discover if not at max depth\n            if (currentDepth + 2 < maxDepth) {\n              await discoverForType('CustomObject', refTo, currentDepth + 2, maxDepth, nodes, edges, warnings, options, config);\n            }\n          }\n\n          const relType: DependencyRelationship = field.DataType === 'MasterDetail' ? 'masterDetail' : 'lookupTo';\n          edges.push({\n            sourceId: fieldId,\n            targetId: refId,\n            relationshipType: relType,\n          });\n        }\n      }\n    }\n  } catch (error) {\n    warnings.push(`Error querying fields for ${objectName}: ${error instanceof Error ? error.message : String(error)}`);\n  }\n\n  // Get triggers\n  const triggersQuery = `\n    SELECT Name FROM ApexTrigger WHERE TableEnumOrId = '${objectName}'\n  `;\n\n  try {\n    const triggers = await executeToolingQuery<{ Name: string }>(triggersQuery, config);\n    \n    for (const trigger of triggers.records) {\n      const triggerId = createNodeId('ApexTrigger', trigger.Name);\n      \n      if (!nodes.has(triggerId)) {\n        nodes.set(triggerId, {\n          id: triggerId,\n          name: trigger.Name,\n          type: 'ApexTrigger',\n          apiName: trigger.Name,\n          depth: currentDepth + 1,\n          isLeaf: currentDepth + 1 >= maxDepth,\n          parentId: sourceId,\n        });\n      }\n\n      edges.push({\n        sourceId,\n        targetId: triggerId,\n        relationshipType: 'triggers',\n      });\n    }\n  } catch (error) {\n    warnings.push(`Error querying triggers for ${objectName}: ${error instanceof Error ? error.message : String(error)}`);\n  }\n\n  // Get validation rules\n  const validationQuery = `\n    SELECT ValidationName FROM ValidationRule \n    WHERE EntityDefinition.QualifiedApiName = '${objectName}' AND Active = true\n  `;\n\n  try {\n    const validations = await executeToolingQuery<{ ValidationName: string }>(validationQuery, config);\n    \n    for (const rule of validations.records) {\n      const ruleId = createNodeId('ValidationRule', `${objectName}.${rule.ValidationName}`);\n      \n      if (!nodes.has(ruleId)) {\n        nodes.set(ruleId, {\n          id: ruleId,\n          name: rule.ValidationName,\n          type: 'ValidationRule',\n          apiName: `${objectName}.${rule.ValidationName}`,\n          depth: currentDepth + 1,\n          isLeaf: true,\n          parentId: sourceId,\n        });\n      }\n\n      edges.push({\n        sourceId,\n        targetId: ruleId,\n        relationshipType: 'contains',\n      });\n    }\n  } catch (error) {\n    warnings.push(`Error querying validation rules for ${objectName}: ${error instanceof Error ? error.message : String(error)}`);\n  }\n}\n\n/**\n * Discover dependencies for a CustomField\n */\nasync function discoverCustomFieldDependencies(\n  fieldName: string,\n  currentDepth: number,\n  maxDepth: number,\n  nodes: Map<string, DependencyNode>,\n  edges: DependencyEdge[],\n  warnings: string[],\n  options: DiscoverDependenciesOptions,\n  config?: SfConnectionConfig\n): Promise<void> {\n  // Field dependencies are typically handled through the parent object\n  // This would analyze formula fields, lookup references, etc.\n  logDebug(`Field dependency discovery for ${fieldName} - handled via parent object`);\n}\n\n/**\n * Discover dependencies for an ApexClass\n */\nasync function discoverApexClassDependencies(\n  className: string,\n  currentDepth: number,\n  maxDepth: number,\n  nodes: Map<string, DependencyNode>,\n  edges: DependencyEdge[],\n  warnings: string[],\n  options: DiscoverDependenciesOptions,\n  config?: SfConnectionConfig\n): Promise<void> {\n  const sourceId = createNodeId('ApexClass', className);\n\n  // Query for class dependencies using SymbolTable\n  const query = `\n    SELECT Id, Name, SymbolTable \n    FROM ApexClass \n    WHERE Name = '${className}'\n  `;\n\n  try {\n    const result = await executeToolingQuery<{\n      Id: string;\n      Name: string;\n      SymbolTable: { \n        externalReferences?: Array<{ name: string; namespace: string }>;\n      } | null;\n    }>(query, config);\n\n    if (result.records.length > 0 && result.records[0]?.SymbolTable?.externalReferences) {\n      for (const ref of result.records[0].SymbolTable.externalReferences) {\n        // Skip standard references\n        if (!options.includeStandardObjects && !ref.name.endsWith('__c')) {\n          continue;\n        }\n\n        const refId = createNodeId('ApexClass', ref.name);\n        \n        if (!nodes.has(refId) && ref.name !== className) {\n          nodes.set(refId, {\n            id: refId,\n            name: ref.name,\n            type: 'ApexClass',\n            apiName: ref.name,\n            namespace: ref.namespace || undefined,\n            depth: currentDepth + 1,\n            isLeaf: currentDepth + 1 >= maxDepth,\n          });\n\n          edges.push({\n            sourceId,\n            targetId: refId,\n            relationshipType: 'references',\n          });\n        }\n      }\n    }\n  } catch (error) {\n    warnings.push(`Error querying Apex class ${className}: ${error instanceof Error ? error.message : String(error)}`);\n  }\n}\n\n/**\n * Discover dependencies for an ApexTrigger\n */\nasync function discoverApexTriggerDependencies(\n  triggerName: string,\n  currentDepth: number,\n  maxDepth: number,\n  nodes: Map<string, DependencyNode>,\n  edges: DependencyEdge[],\n  warnings: string[],\n  options: DiscoverDependenciesOptions,\n  config?: SfConnectionConfig\n): Promise<void> {\n  const sourceId = createNodeId('ApexTrigger', triggerName);\n\n  // Get the object the trigger is on\n  const query = `\n    SELECT TableEnumOrId FROM ApexTrigger WHERE Name = '${triggerName}'\n  `;\n\n  try {\n    const result = await executeToolingQuery<{ TableEnumOrId: string }>(query, config);\n    \n    if (result.records.length > 0 && result.records[0]) {\n      const objectName = result.records[0].TableEnumOrId;\n      const objectId = createNodeId('CustomObject', objectName);\n\n      if (!nodes.has(objectId)) {\n        nodes.set(objectId, {\n          id: objectId,\n          name: objectName,\n          type: 'CustomObject',\n          apiName: objectName,\n          depth: currentDepth + 1,\n          isLeaf: currentDepth + 1 >= maxDepth,\n        });\n      }\n\n      edges.push({\n        sourceId,\n        targetId: objectId,\n        relationshipType: 'triggers',\n      });\n    }\n  } catch (error) {\n    warnings.push(`Error querying trigger ${triggerName}: ${error instanceof Error ? error.message : String(error)}`);\n  }\n}\n\n/**\n * Discover dependencies for a Flow\n */\nasync function discoverFlowDependencies(\n  flowName: string,\n  currentDepth: number,\n  maxDepth: number,\n  nodes: Map<string, DependencyNode>,\n  edges: DependencyEdge[],\n  warnings: string[],\n  options: DiscoverDependenciesOptions,\n  config?: SfConnectionConfig\n): Promise<void> {\n  const sourceId = createNodeId('Flow', flowName);\n\n  // Get the object the flow triggers on\n  const query = `\n    SELECT TriggerObjectOrEvent FROM Flow \n    WHERE DeveloperName = '${flowName}' AND IsActive = true\n  `;\n\n  try {\n    const result = await executeToolingQuery<{ TriggerObjectOrEvent: string | null }>(query, config);\n    \n    if (result.records.length > 0 && result.records[0]?.TriggerObjectOrEvent) {\n      const objectName = result.records[0].TriggerObjectOrEvent;\n      const objectId = createNodeId('CustomObject', objectName);\n\n      if (!nodes.has(objectId)) {\n        nodes.set(objectId, {\n          id: objectId,\n          name: objectName,\n          type: 'CustomObject',\n          apiName: objectName,\n          depth: currentDepth + 1,\n          isLeaf: currentDepth + 1 >= maxDepth,\n        });\n      }\n\n      edges.push({\n        sourceId,\n        targetId: objectId,\n        relationshipType: 'flowReference',\n      });\n    }\n  } catch (error) {\n    warnings.push(`Error querying flow ${flowName}: ${error instanceof Error ? error.message : String(error)}`);\n  }\n}\n\n/**\n * Export graph to JSON format for visualization\n */\nexport function exportGraphToJson(graph: DependencyGraph): string {\n  const nodes = Array.from(graph.nodes.values());\n  return JSON.stringify({\n    nodes,\n    edges: graph.edges,\n    metadata: graph.metadata,\n  }, null, 2);\n}\n\n/**\n * Export graph to DOT format for Graphviz\n */\nexport function exportGraphToDot(graph: DependencyGraph): string {\n  const lines: string[] = ['digraph Dependencies {'];\n  lines.push('  rankdir=LR;');\n  lines.push('  node [shape=box];');\n  lines.push('');\n\n  // Add nodes\n  for (const node of graph.nodes.values()) {\n    const label = `${node.type}\\\\n${node.name}`;\n    const color = node.isCircular ? 'red' : 'black';\n    lines.push(`  \"${node.id}\" [label=\"${label}\" color=\"${color}\"];`);\n  }\n\n  lines.push('');\n\n  // Add edges\n  for (const edge of graph.edges) {\n    lines.push(`  \"${edge.sourceId}\" -> \"${edge.targetId}\" [label=\"${edge.relationshipType}\"];`);\n  }\n\n  lines.push('}');\n  return lines.join('\\n');\n}\n","/**\n * Salesforce Dependency Analyzers\n * Specialized analyzers for different metadata types\n */\n\nimport { executeToolingQuery, executeSoqlQuery } from './sfQueryExecutor.js';\nimport { logInfo, logDebug, logWarn, createTimer } from './lib/loggerStructured.js';\nimport type { SfConnectionConfig } from './sfClient.js';\nimport type {\n  DependencyNode,\n  DependencyEdge,\n  MetadataType,\n  DependencyRelationship,\n} from './types/sfDependencyTypes.js';\n\n/**\n * Analysis result for a specific component\n */\nexport interface AnalysisResult {\n  nodes: DependencyNode[];\n  edges: DependencyEdge[];\n  warnings: string[];\n}\n\n/**\n * Analyze standard field references in custom objects\n */\nexport async function analyzeStandardFields(\n  objectName: string,\n  config?: SfConnectionConfig\n): Promise<AnalysisResult> {\n  const timer = createTimer();\n  const nodes: DependencyNode[] = [];\n  const edges: DependencyEdge[] = [];\n  const warnings: string[] = [];\n\n  logInfo(`Analyzing standard fields for ${objectName}`);\n\n  try {\n    const query = `\n      SELECT QualifiedApiName, DataType, Label, IsCompound, IsNillable\n      FROM FieldDefinition\n      WHERE EntityDefinition.QualifiedApiName = '${objectName}'\n      AND IsCustom = false\n    `;\n\n    const result = await executeToolingQuery<{\n      QualifiedApiName: string;\n      DataType: string;\n      Label: string;\n      IsCompound: boolean;\n      IsNillable: boolean;\n    }>(query, config);\n\n    for (const field of result.records) {\n      const nodeId = `StandardField:${objectName}.${field.QualifiedApiName}`;\n      \n      nodes.push({\n        id: nodeId,\n        name: field.QualifiedApiName,\n        type: 'CustomField', // Using CustomField type for consistency\n        apiName: `${objectName}.${field.QualifiedApiName}`,\n        depth: 1,\n        isLeaf: true,\n        metadata: {\n          dataType: field.DataType,\n          label: field.Label,\n          isCompound: field.IsCompound,\n          isNillable: field.IsNillable,\n          isStandard: true,\n        },\n      });\n\n      edges.push({\n        sourceId: `CustomObject:${objectName}`,\n        targetId: nodeId,\n        relationshipType: 'contains',\n      });\n    }\n\n    logInfo(`Found ${nodes.length} standard fields for ${objectName}`);\n  } catch (error) {\n    const msg = `Error analyzing standard fields for ${objectName}: ${error instanceof Error ? error.message : String(error)}`;\n    logWarn(msg);\n    warnings.push(msg);\n  }\n\n  timer.log(`analyzeStandardFields(${objectName})`);\n  return { nodes, edges, warnings };\n}\n\n/**\n * Analyze Custom Metadata Type dependencies\n */\nexport async function analyzeCustomMetadata(\n  cmtName: string,\n  config?: SfConnectionConfig\n): Promise<AnalysisResult> {\n  const timer = createTimer();\n  const nodes: DependencyNode[] = [];\n  const edges: DependencyEdge[] = [];\n  const warnings: string[] = [];\n\n  logInfo(`Analyzing Custom Metadata Type: ${cmtName}`);\n\n  try {\n    // Get the CMT definition\n    const entityQuery = `\n      SELECT QualifiedApiName, DeveloperName, MasterLabel, KeyPrefix\n      FROM EntityDefinition\n      WHERE QualifiedApiName = '${cmtName}'\n    `;\n\n    const entityResult = await executeToolingQuery<{\n      QualifiedApiName: string;\n      DeveloperName: string;\n      MasterLabel: string;\n      KeyPrefix: string;\n    }>(entityQuery, config);\n\n    if (entityResult.records.length === 0) {\n      warnings.push(`Custom Metadata Type ${cmtName} not found`);\n      return { nodes, edges, warnings };\n    }\n\n    const entity = entityResult.records[0]!;\n    const rootId = `CustomMetadataType:${cmtName}`;\n\n    nodes.push({\n      id: rootId,\n      name: entity.DeveloperName,\n      type: 'CustomMetadataType',\n      apiName: cmtName,\n      depth: 0,\n      isLeaf: false,\n      metadata: {\n        label: entity.MasterLabel,\n        keyPrefix: entity.KeyPrefix,\n      },\n    });\n\n    // Get fields\n    const fieldsQuery = `\n      SELECT QualifiedApiName, DataType, Label\n      FROM FieldDefinition\n      WHERE EntityDefinition.QualifiedApiName = '${cmtName}'\n      AND IsCustom = true\n    `;\n\n    const fieldsResult = await executeToolingQuery<{\n      QualifiedApiName: string;\n      DataType: string;\n      Label: string;\n    }>(fieldsQuery, config);\n\n    for (const field of fieldsResult.records) {\n      const fieldId = `CustomField:${cmtName}.${field.QualifiedApiName}`;\n      \n      nodes.push({\n        id: fieldId,\n        name: field.QualifiedApiName,\n        type: 'CustomField',\n        apiName: `${cmtName}.${field.QualifiedApiName}`,\n        depth: 1,\n        isLeaf: true,\n        parentId: rootId,\n        metadata: {\n          dataType: field.DataType,\n          label: field.Label,\n        },\n      });\n\n      edges.push({\n        sourceId: rootId,\n        targetId: fieldId,\n        relationshipType: 'contains',\n      });\n    }\n\n    // Get records count\n    try {\n      const recordsQuery = `SELECT COUNT() FROM ${cmtName}`;\n      const recordsResult = await executeSoqlQuery<{ expr0: number }>(recordsQuery, config);\n      \n      if (recordsResult.totalSize > 0) {\n        logDebug(`${cmtName} has ${recordsResult.totalSize} records`);\n      }\n    } catch {\n      // CMT might not be queryable in standard SOQL\n      logDebug(`Could not query records for ${cmtName}`);\n    }\n\n    logInfo(`Analyzed CMT ${cmtName}: ${fieldsResult.records.length} fields`);\n  } catch (error) {\n    const msg = `Error analyzing CMT ${cmtName}: ${error instanceof Error ? error.message : String(error)}`;\n    logWarn(msg);\n    warnings.push(msg);\n  }\n\n  timer.log(`analyzeCustomMetadata(${cmtName})`);\n  return { nodes, edges, warnings };\n}\n\n/**\n * Analyze Workflow Rules for an object\n */\nexport async function analyzeWorkflows(\n  objectName: string,\n  config?: SfConnectionConfig\n): Promise<AnalysisResult> {\n  const timer = createTimer();\n  const nodes: DependencyNode[] = [];\n  const edges: DependencyEdge[] = [];\n  const warnings: string[] = [];\n\n  logInfo(`Analyzing workflows for ${objectName}`);\n\n  const objectNodeId = `CustomObject:${objectName}`;\n\n  try {\n    // Note: WorkflowRule is not directly queryable via Tooling API in all orgs\n    // We'll query related components instead\n\n    // Get Field Updates\n    const fieldUpdatesQuery = `\n      SELECT Id, Name, SourceObject\n      FROM WorkflowFieldUpdate\n      WHERE SourceObject = '${objectName}'\n    `;\n\n    try {\n      const fieldUpdates = await executeToolingQuery<{\n        Id: string;\n        Name: string;\n        SourceObject: string;\n      }>(fieldUpdatesQuery, config);\n\n      for (const update of fieldUpdates.records) {\n        const nodeId = `WorkflowFieldUpdate:${objectName}.${update.Name}`;\n        \n        nodes.push({\n          id: nodeId,\n          name: update.Name,\n          type: 'WorkflowFieldUpdate',\n          apiName: `${objectName}.${update.Name}`,\n          depth: 1,\n          isLeaf: true,\n          parentId: objectNodeId,\n        });\n\n        edges.push({\n          sourceId: objectNodeId,\n          targetId: nodeId,\n          relationshipType: 'workflowUpdate',\n        });\n      }\n\n      logDebug(`Found ${fieldUpdates.records.length} workflow field updates`);\n    } catch (error) {\n      logDebug(`WorkflowFieldUpdate query failed: ${error}`);\n    }\n\n    // Get Email Alerts\n    const emailAlertsQuery = `\n      SELECT Id, DeveloperName, SenderType\n      FROM WorkflowAlert\n    `;\n\n    try {\n      const emailAlerts = await executeToolingQuery<{\n        Id: string;\n        DeveloperName: string;\n        SenderType: string;\n      }>(emailAlertsQuery, config);\n\n      // Filter for object-specific alerts would require more metadata\n      logDebug(`Found ${emailAlerts.records.length} workflow email alerts in org`);\n    } catch (error) {\n      logDebug(`WorkflowAlert query failed: ${error}`);\n    }\n\n  } catch (error) {\n    const msg = `Error analyzing workflows for ${objectName}: ${error instanceof Error ? error.message : String(error)}`;\n    logWarn(msg);\n    warnings.push(msg);\n  }\n\n  timer.log(`analyzeWorkflows(${objectName})`);\n  return { nodes, edges, warnings };\n}\n\n/**\n * Analyze Process Builder processes for an object\n */\nexport async function analyzeProcessBuilders(\n  objectName: string,\n  config?: SfConnectionConfig\n): Promise<AnalysisResult> {\n  const timer = createTimer();\n  const nodes: DependencyNode[] = [];\n  const edges: DependencyEdge[] = [];\n  const warnings: string[] = [];\n\n  logInfo(`Analyzing Process Builders for ${objectName}`);\n\n  const objectNodeId = `CustomObject:${objectName}`;\n\n  try {\n    const query = `\n      SELECT Id, MasterLabel, DeveloperName, ProcessType, Status\n      FROM Flow\n      WHERE TriggerObjectOrEvent = '${objectName}'\n      AND ProcessType = 'Workflow'\n      AND Status = 'Active'\n    `;\n\n    const result = await executeToolingQuery<{\n      Id: string;\n      MasterLabel: string;\n      DeveloperName: string;\n      ProcessType: string;\n      Status: string;\n    }>(query, config);\n\n    for (const process of result.records) {\n      const nodeId = `ProcessBuilder:${process.DeveloperName}`;\n      \n      nodes.push({\n        id: nodeId,\n        name: process.MasterLabel,\n        type: 'ProcessBuilder',\n        apiName: process.DeveloperName,\n        depth: 1,\n        isLeaf: true,\n        parentId: objectNodeId,\n        metadata: {\n          status: process.Status,\n          processType: process.ProcessType,\n        },\n      });\n\n      edges.push({\n        sourceId: objectNodeId,\n        targetId: nodeId,\n        relationshipType: 'triggers',\n      });\n    }\n\n    logInfo(`Found ${result.records.length} Process Builders for ${objectName}`);\n  } catch (error) {\n    const msg = `Error analyzing Process Builders for ${objectName}: ${error instanceof Error ? error.message : String(error)}`;\n    logWarn(msg);\n    warnings.push(msg);\n  }\n\n  timer.log(`analyzeProcessBuilders(${objectName})`);\n  return { nodes, edges, warnings };\n}\n\n/**\n * Analyze Record-Triggered Flows for an object\n */\nexport async function analyzeRecordTriggeredFlows(\n  objectName: string,\n  config?: SfConnectionConfig\n): Promise<AnalysisResult> {\n  const timer = createTimer();\n  const nodes: DependencyNode[] = [];\n  const edges: DependencyEdge[] = [];\n  const warnings: string[] = [];\n\n  logInfo(`Analyzing Record-Triggered Flows for ${objectName}`);\n\n  const objectNodeId = `CustomObject:${objectName}`;\n\n  try {\n    const query = `\n      SELECT Id, MasterLabel, DeveloperName, TriggerType, RecordTriggerType, Status\n      FROM Flow\n      WHERE TriggerObjectOrEvent = '${objectName}'\n      AND ProcessType = 'AutoLaunchedFlow'\n      AND TriggerType = 'RecordAfterSave'\n      AND IsActive = true\n    `;\n\n    const result = await executeToolingQuery<{\n      Id: string;\n      MasterLabel: string;\n      DeveloperName: string;\n      TriggerType: string;\n      RecordTriggerType: string;\n      Status: string;\n    }>(query, config);\n\n    for (const flow of result.records) {\n      const nodeId = `Flow:${flow.DeveloperName}`;\n      \n      nodes.push({\n        id: nodeId,\n        name: flow.MasterLabel,\n        type: 'Flow',\n        apiName: flow.DeveloperName,\n        depth: 1,\n        isLeaf: true,\n        parentId: objectNodeId,\n        metadata: {\n          triggerType: flow.TriggerType,\n          recordTriggerType: flow.RecordTriggerType,\n          status: flow.Status,\n        },\n      });\n\n      edges.push({\n        sourceId: objectNodeId,\n        targetId: nodeId,\n        relationshipType: 'triggers',\n      });\n    }\n\n    logInfo(`Found ${result.records.length} Record-Triggered Flows for ${objectName}`);\n  } catch (error) {\n    const msg = `Error analyzing Record-Triggered Flows for ${objectName}: ${error instanceof Error ? error.message : String(error)}`;\n    logWarn(msg);\n    warnings.push(msg);\n  }\n\n  timer.log(`analyzeRecordTriggeredFlows(${objectName})`);\n  return { nodes, edges, warnings };\n}\n\n/**\n * Analyze sharing rules and settings for an object\n */\nexport async function analyzeSharingSettings(\n  objectName: string,\n  config?: SfConnectionConfig\n): Promise<AnalysisResult> {\n  const timer = createTimer();\n  const nodes: DependencyNode[] = [];\n  const edges: DependencyEdge[] = [];\n  const warnings: string[] = [];\n\n  logInfo(`Analyzing sharing settings for ${objectName}`);\n\n  try {\n    const query = `\n      SELECT InternalSharingModel, ExternalSharingModel\n      FROM EntityDefinition\n      WHERE QualifiedApiName = '${objectName}'\n    `;\n\n    const result = await executeToolingQuery<{\n      InternalSharingModel: string;\n      ExternalSharingModel: string;\n    }>(query, config);\n\n    if (result.records.length > 0) {\n      const entity = result.records[0]!;\n      \n      logInfo(`Sharing for ${objectName}: Internal=${entity.InternalSharingModel}, External=${entity.ExternalSharingModel}`);\n      \n      // Add metadata to the object node if it exists\n      // This is informational - doesn't create new nodes\n    }\n  } catch (error) {\n    const msg = `Error analyzing sharing settings for ${objectName}: ${error instanceof Error ? error.message : String(error)}`;\n    logWarn(msg);\n    warnings.push(msg);\n  }\n\n  timer.log(`analyzeSharingSettings(${objectName})`);\n  return { nodes, edges, warnings };\n}\n\n/**\n * Run all analyzers for an object\n */\nexport async function runAllAnalyzers(\n  objectName: string,\n  config?: SfConnectionConfig\n): Promise<AnalysisResult> {\n  const timer = createTimer();\n  const allNodes: DependencyNode[] = [];\n  const allEdges: DependencyEdge[] = [];\n  const allWarnings: string[] = [];\n\n  logInfo(`Running all analyzers for ${objectName}`);\n\n  // Run analyzers in parallel\n  const results = await Promise.all([\n    analyzeStandardFields(objectName, config),\n    analyzeWorkflows(objectName, config),\n    analyzeProcessBuilders(objectName, config),\n    analyzeRecordTriggeredFlows(objectName, config),\n  ]);\n\n  for (const result of results) {\n    allNodes.push(...result.nodes);\n    allEdges.push(...result.edges);\n    allWarnings.push(...result.warnings);\n  }\n\n  logInfo(`All analyzers complete for ${objectName}: ${allNodes.length} nodes, ${allEdges.length} edges`);\n  timer.log(`runAllAnalyzers(${objectName})`);\n\n  return {\n    nodes: allNodes,\n    edges: allEdges,\n    warnings: allWarnings,\n  };\n}\n","/**\n * Workflow Prepare Ticket\n * Prepares artifacts and context for ticket workflows\n */\n\nimport { existsSync, mkdirSync, writeFileSync } from 'fs';\nimport { resolve } from 'path';\nimport { getWorkItem } from './adoWorkItems.js';\nimport { loadSharedConfig, loadTemplateVariables, resolveTemplate } from './lib/configLoader.js';\nimport { logInfo, logDebug, logError, createTimer } from './lib/loggerStructured.js';\nimport { createState, saveState, loadState, updateVariables, addArtifact } from './workflowState.js';\nimport type { WorkflowState, TemplateVariables, SharedConfig } from './types/configTypes.js';\nimport type { WorkItem } from './types/adoWorkItemTypes.js';\n\n/**\n * Preparation options\n */\nexport interface PrepareOptions {\n  workItemId: number;\n  outputDir?: string;\n  force?: boolean;\n  configPath?: string;\n}\n\n/**\n * Preparation result\n */\nexport interface PrepareResult {\n  success: boolean;\n  state: WorkflowState;\n  workItem: WorkItem;\n  variables: TemplateVariables;\n  artifacts: Record<string, string>;\n  errors: string[];\n}\n\n/**\n * Default output directory\n */\nconst DEFAULT_OUTPUT_DIR = '.ai-artifacts';\n\n/**\n * Prepare ticket artifacts for workflow execution\n * \n * @param options - Preparation options\n * @returns Preparation result\n */\nexport async function prepareTicketArtifacts(\n  options: PrepareOptions\n): Promise<PrepareResult> {\n  const timer = createTimer();\n  const { workItemId, outputDir, force = false, configPath } = options;\n\n  logInfo(`Preparing artifacts for work item ${workItemId}`);\n\n  const errors: string[] = [];\n  let state: WorkflowState;\n  let workItem: WorkItem;\n  let variables: TemplateVariables = {};\n  const artifacts: Record<string, string> = {};\n\n  try {\n    // Check for existing state\n    const existingState = loadState(workItemId);\n    if (existingState && !force) {\n      logInfo('Using existing workflow state', { status: existingState.status });\n      state = existingState;\n    } else {\n      state = createState(workItemId);\n    }\n\n    // Fetch work item\n    logDebug('Fetching work item details');\n    workItem = await getWorkItem(workItemId, { expand: 'All', includeComments: true });\n\n    // Build variables from work item\n    variables = resolveConfig(workItem, configPath);\n    state = updateVariables(state, variables);\n\n    // Create output directory\n    const artifactDir = outputDir ?? resolve(process.cwd(), DEFAULT_OUTPUT_DIR, String(workItemId));\n    if (!existsSync(artifactDir)) {\n      mkdirSync(artifactDir, { recursive: true });\n    }\n\n    // Create work item artifact\n    const workItemPath = resolve(artifactDir, 'work-item.json');\n    writeFileSync(workItemPath, JSON.stringify(workItem, null, 2), 'utf-8');\n    artifacts['work-item'] = workItemPath;\n    state = addArtifact(state, 'work-item', workItemPath);\n\n    // Create variables artifact\n    const variablesPath = resolve(artifactDir, 'variables.json');\n    writeFileSync(variablesPath, JSON.stringify(variables, null, 2), 'utf-8');\n    artifacts['variables'] = variablesPath;\n    state = addArtifact(state, 'variables', variablesPath);\n\n    // Create context artifact (combined info for prompts)\n    const context = buildContext(workItem, variables);\n    const contextPath = resolve(artifactDir, 'context.md');\n    writeFileSync(contextPath, context, 'utf-8');\n    artifacts['context'] = contextPath;\n    state = addArtifact(state, 'context', contextPath);\n\n    // Save state\n    saveState(state);\n\n    timer.log('prepareTicketArtifacts');\n\n    return {\n      success: true,\n      state,\n      workItem,\n      variables,\n      artifacts,\n      errors,\n    };\n  } catch (error) {\n    const errorMsg = error instanceof Error ? error.message : String(error);\n    logError('Failed to prepare ticket artifacts', { error: errorMsg });\n    errors.push(errorMsg);\n\n    return {\n      success: false,\n      state: state!,\n      workItem: workItem!,\n      variables,\n      artifacts,\n      errors,\n    };\n  }\n}\n\n/**\n * Resolve configuration and build template variables\n */\nexport function resolveConfig(\n  workItem: WorkItem,\n  configPath?: string\n): TemplateVariables {\n  logDebug('Resolving configuration');\n\n  // Load base template variables\n  let variables: TemplateVariables;\n  try {\n    variables = loadTemplateVariables(configPath);\n  } catch {\n    variables = {};\n  }\n\n  // Add work item fields\n  const fields = workItem.fields;\n  \n  variables = {\n    ...variables,\n    workItemId: workItem.id,\n    workItemType: fields['System.WorkItemType'] as string,\n    title: fields['System.Title'] as string,\n    description: fields['System.Description'] as string,\n    state: fields['System.State'] as string,\n    areaPath: fields['System.AreaPath'] as string,\n    iterationPath: fields['System.IterationPath'] as string,\n    assignedTo: typeof fields['System.AssignedTo'] === 'object' \n      ? (fields['System.AssignedTo'] as { displayName: string }).displayName \n      : fields['System.AssignedTo'] as string,\n    tags: fields['System.Tags'] as string,\n    storyPoints: fields['Microsoft.VSTS.Scheduling.StoryPoints'] as number,\n    priority: fields['Microsoft.VSTS.Common.Priority'] as number,\n    acceptanceCriteria: fields['Microsoft.VSTS.Common.AcceptanceCriteria'] as string,\n    workClassType: fields['Custom.WorkClassType'] as string,\n    requiresQA: fields['Custom.RequiresQA'] as string,\n    sfComponents: fields['Custom.SFComponents'] as string,\n    technicalNotes: fields['Custom.TechnicalNotes'] as string,\n    timestamp: new Date().toISOString(),\n  };\n\n  return variables;\n}\n\n/**\n * Build context markdown for prompts\n */\nfunction buildContext(workItem: WorkItem, variables: TemplateVariables): string {\n  const fields = workItem.fields;\n  const lines: string[] = [];\n\n  lines.push(`# Work Item Context`);\n  lines.push('');\n  lines.push(`## ${fields['System.WorkItemType']} #${workItem.id}: ${fields['System.Title']}`);\n  lines.push('');\n\n  // Basic info\n  lines.push('### Basic Information');\n  lines.push('');\n  lines.push(`- **State:** ${fields['System.State']}`);\n  lines.push(`- **Assigned To:** ${variables['assignedTo'] ?? 'Unassigned'}`);\n  lines.push(`- **Area Path:** ${fields['System.AreaPath']}`);\n  lines.push(`- **Iteration:** ${fields['System.IterationPath']}`);\n  \n  if (fields['Microsoft.VSTS.Scheduling.StoryPoints']) {\n    lines.push(`- **Story Points:** ${fields['Microsoft.VSTS.Scheduling.StoryPoints']}`);\n  }\n  if (fields['Microsoft.VSTS.Common.Priority']) {\n    lines.push(`- **Priority:** ${fields['Microsoft.VSTS.Common.Priority']}`);\n  }\n  if (fields['Custom.WorkClassType']) {\n    lines.push(`- **Work Class:** ${fields['Custom.WorkClassType']}`);\n  }\n  if (fields['Custom.RequiresQA']) {\n    lines.push(`- **Requires QA:** ${fields['Custom.RequiresQA']}`);\n  }\n  \n  lines.push('');\n\n  // Description\n  if (fields['System.Description']) {\n    lines.push('### Description');\n    lines.push('');\n    lines.push(fields['System.Description'] as string);\n    lines.push('');\n  }\n\n  // Acceptance Criteria\n  if (fields['Microsoft.VSTS.Common.AcceptanceCriteria']) {\n    lines.push('### Acceptance Criteria');\n    lines.push('');\n    lines.push(fields['Microsoft.VSTS.Common.AcceptanceCriteria'] as string);\n    lines.push('');\n  }\n\n  // Technical Notes\n  if (fields['Custom.TechnicalNotes']) {\n    lines.push('### Technical Notes');\n    lines.push('');\n    lines.push(fields['Custom.TechnicalNotes'] as string);\n    lines.push('');\n  }\n\n  // SF Components\n  if (fields['Custom.SFComponents']) {\n    lines.push('### Salesforce Components');\n    lines.push('');\n    lines.push(fields['Custom.SFComponents'] as string);\n    lines.push('');\n  }\n\n  // Tags\n  if (fields['System.Tags']) {\n    lines.push('### Tags');\n    lines.push('');\n    lines.push(`${fields['System.Tags']}`);\n    lines.push('');\n  }\n\n  // Relations\n  if (workItem.relations && workItem.relations.length > 0) {\n    lines.push('### Related Work Items');\n    lines.push('');\n    for (const relation of workItem.relations) {\n      const relType = relation.rel.replace('System.LinkTypes.', '').replace('-', ' ');\n      const idMatch = /\\/(\\d+)$/.exec(relation.url);\n      const relatedId = idMatch ? idMatch[1] : 'Unknown';\n      lines.push(`- ${relType}: #${relatedId}`);\n    }\n    lines.push('');\n  }\n\n  return lines.join('\\n');\n}\n\n/**\n * Get artifact path for a specific artifact type\n */\nexport function getArtifactPath(\n  workItemId: number,\n  artifactName: string,\n  outputDir?: string\n): string {\n  const artifactDir = outputDir ?? resolve(process.cwd(), DEFAULT_OUTPUT_DIR, String(workItemId));\n  return resolve(artifactDir, artifactName);\n}\n\n/**\n * Check if artifacts exist for a work item\n */\nexport function hasArtifacts(workItemId: number, outputDir?: string): boolean {\n  const artifactDir = outputDir ?? resolve(process.cwd(), DEFAULT_OUTPUT_DIR, String(workItemId));\n  return existsSync(resolve(artifactDir, 'work-item.json'));\n}\n\n/**\n * Clean up artifacts for a work item\n */\nexport function cleanupArtifacts(workItemId: number, outputDir?: string): void {\n  const artifactDir = outputDir ?? resolve(process.cwd(), DEFAULT_OUTPUT_DIR, String(workItemId));\n  \n  if (!existsSync(artifactDir)) {\n    return;\n  }\n\n  const { rmSync } = require('fs');\n  \n  try {\n    rmSync(artifactDir, { recursive: true, force: true });\n    logInfo(`Cleaned up artifacts for work item ${workItemId}`);\n  } catch (error) {\n    logError(`Failed to cleanup artifacts for work item ${workItemId}`, { error });\n  }\n}\n","/**\n * Configuration Loader\n * Loads and validates configuration files\n */\n\nimport { readFileSync, existsSync } from 'fs';\nimport { resolve, dirname } from 'path';\nimport { fileURLToPath } from 'url';\nimport type { SharedConfig, TemplateVariables, StepManifest } from '../types/configTypes.js';\n\n/**\n * Get the project root directory (where .github lives)\n */\nexport function getProjectRoot(): string {\n  // Try to find .github relative to cwd or script location\n  const possibleRoots = [\n    process.cwd(),\n    resolve(process.cwd(), '..'),\n    resolve(process.cwd(), '..', '..'),\n    resolve(dirname(fileURLToPath(import.meta.url)), '..', '..', '..', '..'),\n  ];\n  \n  for (const root of possibleRoots) {\n    if (existsSync(resolve(root, 'config', 'shared.json'))) {\n      return root;\n    }\n  }\n  \n  // Default to cwd\n  return process.cwd();\n}\n\n/**\n * Get the base directory for config files\n */\nfunction getConfigDir(): string {\n  return resolve(getProjectRoot(), 'config');\n}\n\n/**\n * Load and parse a JSON file\n */\nfunction loadJsonFile<T>(filePath: string): T {\n  if (!existsSync(filePath)) {\n    throw new Error(`Configuration file not found: ${filePath}`);\n  }\n  \n  try {\n    const content = readFileSync(filePath, 'utf-8');\n    return JSON.parse(content) as T;\n  } catch (error) {\n    if (error instanceof SyntaxError) {\n      throw new Error(`Invalid JSON in ${filePath}: ${error.message}`);\n    }\n    throw error;\n  }\n}\n\n/**\n * Load the shared configuration\n * \n * @param configPath - Optional explicit path to shared.json\n * @returns Shared configuration object\n */\nexport function loadSharedConfig(configPath?: string): SharedConfig {\n  const path = configPath ?? resolve(getConfigDir(), 'shared.json');\n  return loadJsonFile<SharedConfig>(path);\n}\n\n/**\n * Load template variables\n * \n * @param configPath - Optional explicit path to template-variables.json\n * @returns Template variables object\n */\nexport function loadTemplateVariables(configPath?: string): TemplateVariables {\n  const path = configPath ?? resolve(getConfigDir(), 'template-variables.json');\n  \n  // Template variables might not exist, return empty object\n  if (!existsSync(path)) {\n    return {};\n  }\n  \n  return loadJsonFile<TemplateVariables>(path);\n}\n\n/**\n * Load step manifests\n * \n * @param configPath - Optional explicit path to step-manifests.json\n * @returns Array of step manifests\n */\nexport function loadStepManifests(configPath?: string): StepManifest[] {\n  const path = configPath ?? resolve(getConfigDir(), 'step-manifests.json');\n  const data = loadJsonFile<{ steps: StepManifest[] } | StepManifest[]>(path);\n  \n  // Handle both array and object with steps property\n  if (Array.isArray(data)) {\n    return data;\n  }\n  return data.steps;\n}\n\n/**\n * Load a specific step manifest by ID\n * \n * @param stepId - Step ID to find\n * @param configPath - Optional explicit path to step-manifests.json\n * @returns Step manifest or undefined\n */\nexport function loadStepManifest(stepId: string, configPath?: string): StepManifest | undefined {\n  const manifests = loadStepManifests(configPath);\n  return manifests.find(m => m.id === stepId);\n}\n\n/**\n * Get a CLI command from shared config\n * \n * @param commandKey - Key of the command to get\n * @param configPath - Optional explicit path to shared.json\n * @returns Command string\n */\nexport function getCliCommand(\n  commandKey: keyof SharedConfig['cli_commands'],\n  configPath?: string\n): string {\n  const config = loadSharedConfig(configPath);\n  const command = config.cli_commands[commandKey];\n  \n  if (!command) {\n    throw new Error(`CLI command not found: ${commandKey}`);\n  }\n  \n  return command;\n}\n\n/**\n * Resolve template variables in a string\n * \n * @param template - Template string with {{variable}} placeholders\n * @param variables - Variables to substitute\n * @returns Resolved string\n */\nexport function resolveTemplate(template: string, variables: TemplateVariables): string {\n  return template.replace(/\\{\\{(\\w+)\\}\\}/g, (match, key: string) => {\n    const value = variables[key];\n    if (value === undefined) {\n      return match; // Leave unresolved placeholders as-is\n    }\n    return String(value);\n  });\n}\n\n/**\n * Merge template variables with defaults\n * \n * @param base - Base variables\n * @param overrides - Override variables\n * @returns Merged variables\n */\nexport function mergeVariables(\n  base: TemplateVariables,\n  overrides: TemplateVariables\n): TemplateVariables {\n  return { ...base, ...overrides };\n}\n\n/**\n * Get the path to a prompt file\n * \n * @param promptName - Name of the prompt (without extension)\n * @returns Full path to the prompt file\n */\nexport function getPromptPath(promptName: string): string {\n  const promptsDir = resolve(getConfigDir(), '..', 'prompts');\n  return resolve(promptsDir, `${promptName}.prompt.md`);\n}\n\n/**\n * Get the path to a template file\n * \n * @param templateName - Name of the template\n * @returns Full path to the template file\n */\nexport function getTemplatePath(templateName: string): string {\n  // Templates are in .github/templates\n  const templatesDir = resolve(getConfigDir(), '..', 'templates');\n  return resolve(templatesDir, templateName);\n}\n\n/**\n * Get the path to a standards file\n * \n * @param standardName - Name of the standard\n * @returns Full path to the standards file\n */\nexport function getStandardPath(standardName: string): string {\n  // Standards are in .github/standards\n  const standardsDir = resolve(getConfigDir(), '..', 'standards');\n  return resolve(standardsDir, standardName);\n}\n","/**\n * Workflow State Management\n * Manages workflow execution state and persistence\n */\n\nimport { readFileSync, writeFileSync, existsSync, mkdirSync } from 'fs';\nimport { resolve, dirname } from 'path';\nimport { logInfo, logDebug, logWarn } from './lib/loggerStructured.js';\nimport type {\n  WorkflowState,\n  WorkflowStatus,\n  TemplateVariables,\n} from './types/configTypes.js';\n\n/**\n * Default state directory\n */\nconst DEFAULT_STATE_DIR = '.github/state';\n\n/**\n * Get the state file path for a work item\n */\nfunction getStateFilePath(workItemId: number, stateDir?: string): string {\n  const dir = stateDir ?? resolve(process.cwd(), DEFAULT_STATE_DIR);\n  return resolve(dir, `workflow-${workItemId}.json`);\n}\n\n/**\n * Ensure state directory exists\n */\nfunction ensureStateDir(stateDir?: string): void {\n  const dir = stateDir ?? resolve(process.cwd(), DEFAULT_STATE_DIR);\n  if (!existsSync(dir)) {\n    mkdirSync(dir, { recursive: true });\n  }\n}\n\n/**\n * Create a new workflow state\n */\nexport function createState(workItemId: number): WorkflowState {\n  return {\n    workItemId,\n    currentPhase: '',\n    currentStep: '',\n    completedSteps: [],\n    skippedSteps: [],\n    artifacts: {},\n    variables: { workItemId },\n    startedAt: new Date().toISOString(),\n    lastUpdated: new Date().toISOString(),\n    status: 'pending',\n  };\n}\n\n/**\n * Load workflow state from disk\n * \n * @param workItemId - Work item ID\n * @param stateDir - Optional state directory\n * @returns Workflow state or undefined if not found\n */\nexport function loadState(\n  workItemId: number,\n  stateDir?: string\n): WorkflowState | undefined {\n  const filePath = getStateFilePath(workItemId, stateDir);\n  \n  logDebug(`Loading state from ${filePath}`);\n\n  if (!existsSync(filePath)) {\n    logDebug(`No state file found for work item ${workItemId}`);\n    return undefined;\n  }\n\n  try {\n    const content = readFileSync(filePath, 'utf-8');\n    const state = JSON.parse(content) as WorkflowState;\n    logInfo(`Loaded state for work item ${workItemId}`, { status: state.status });\n    return state;\n  } catch (error) {\n    logWarn(`Error loading state for work item ${workItemId}`, { error });\n    return undefined;\n  }\n}\n\n/**\n * Save workflow state to disk\n * \n * @param state - Workflow state to save\n * @param stateDir - Optional state directory\n */\nexport function saveState(state: WorkflowState, stateDir?: string): void {\n  ensureStateDir(stateDir);\n  const filePath = getStateFilePath(state.workItemId, stateDir);\n\n  // Update timestamp\n  state.lastUpdated = new Date().toISOString();\n\n  logDebug(`Saving state to ${filePath}`);\n\n  try {\n    const content = JSON.stringify(state, null, 2);\n    writeFileSync(filePath, content, 'utf-8');\n    logDebug(`State saved for work item ${state.workItemId}`);\n  } catch (error) {\n    logWarn(`Error saving state for work item ${state.workItemId}`, { error });\n    throw error;\n  }\n}\n\n/**\n * Reset workflow state\n * \n * @param workItemId - Work item ID\n * @param stateDir - Optional state directory\n */\nexport function resetState(workItemId: number, stateDir?: string): void {\n  const filePath = getStateFilePath(workItemId, stateDir);\n\n  logInfo(`Resetting state for work item ${workItemId}`);\n\n  if (existsSync(filePath)) {\n    // Create backup before resetting\n    const backupPath = `${filePath}.backup`;\n    const content = readFileSync(filePath, 'utf-8');\n    writeFileSync(backupPath, content, 'utf-8');\n    logDebug(`Backed up state to ${backupPath}`);\n  }\n\n  // Create fresh state\n  const newState = createState(workItemId);\n  saveState(newState, stateDir);\n}\n\n/**\n * Update workflow status\n */\nexport function updateStatus(\n  state: WorkflowState,\n  status: WorkflowStatus,\n  error?: string\n): WorkflowState {\n  return {\n    ...state,\n    status,\n    error: error ?? state.error,\n    lastUpdated: new Date().toISOString(),\n  };\n}\n\n/**\n * Mark a step as completed\n */\nexport function completeStep(\n  state: WorkflowState,\n  stepId: string\n): WorkflowState {\n  if (state.completedSteps.includes(stepId)) {\n    return state;\n  }\n\n  return {\n    ...state,\n    completedSteps: [...state.completedSteps, stepId],\n    currentStep: '',\n    lastUpdated: new Date().toISOString(),\n  };\n}\n\n/**\n * Mark a step as skipped\n */\nexport function skipStep(\n  state: WorkflowState,\n  stepId: string\n): WorkflowState {\n  if (state.skippedSteps.includes(stepId)) {\n    return state;\n  }\n\n  return {\n    ...state,\n    skippedSteps: [...state.skippedSteps, stepId],\n    currentStep: '',\n    lastUpdated: new Date().toISOString(),\n  };\n}\n\n/**\n * Set current step\n */\nexport function setCurrentStep(\n  state: WorkflowState,\n  phase: string,\n  step: string\n): WorkflowState {\n  return {\n    ...state,\n    currentPhase: phase,\n    currentStep: step,\n    status: 'in_progress',\n    lastUpdated: new Date().toISOString(),\n  };\n}\n\n/**\n * Add an artifact to state\n */\nexport function addArtifact(\n  state: WorkflowState,\n  name: string,\n  path: string\n): WorkflowState {\n  return {\n    ...state,\n    artifacts: {\n      ...state.artifacts,\n      [name]: path,\n    },\n    lastUpdated: new Date().toISOString(),\n  };\n}\n\n/**\n * Update variables in state\n */\nexport function updateVariables(\n  state: WorkflowState,\n  variables: Partial<TemplateVariables>\n): WorkflowState {\n  return {\n    ...state,\n    variables: {\n      ...state.variables,\n      ...variables,\n    },\n    lastUpdated: new Date().toISOString(),\n  };\n}\n\n/**\n * Check if a step is completed\n */\nexport function isStepCompleted(state: WorkflowState, stepId: string): boolean {\n  return state.completedSteps.includes(stepId);\n}\n\n/**\n * Check if a step is skipped\n */\nexport function isStepSkipped(state: WorkflowState, stepId: string): boolean {\n  return state.skippedSteps.includes(stepId);\n}\n\n/**\n * Check if workflow can be resumed\n */\nexport function canResume(state: WorkflowState): boolean {\n  return state.status === 'in_progress' || state.status === 'paused';\n}\n\n/**\n * Get workflow progress percentage\n */\nexport function getProgress(state: WorkflowState, totalSteps: number): number {\n  if (totalSteps === 0) return 0;\n  const completed = state.completedSteps.length + state.skippedSteps.length;\n  return Math.round((completed / totalSteps) * 100);\n}\n\n/**\n * Get workflow summary\n */\nexport function getStateSummary(state: WorkflowState): StateSummary {\n  return {\n    workItemId: state.workItemId,\n    status: state.status,\n    currentPhase: state.currentPhase,\n    currentStep: state.currentStep,\n    completedCount: state.completedSteps.length,\n    skippedCount: state.skippedSteps.length,\n    artifactCount: Object.keys(state.artifacts).length,\n    startedAt: state.startedAt,\n    lastUpdated: state.lastUpdated,\n    error: state.error,\n  };\n}\n\n/**\n * State summary interface\n */\nexport interface StateSummary {\n  workItemId: number;\n  status: WorkflowStatus;\n  currentPhase: string;\n  currentStep: string;\n  completedCount: number;\n  skippedCount: number;\n  artifactCount: number;\n  startedAt: string;\n  lastUpdated: string;\n  error?: string;\n}\n\n/**\n * List all workflow states\n */\nexport function listStates(stateDir?: string): WorkflowState[] {\n  const dir = stateDir ?? resolve(process.cwd(), DEFAULT_STATE_DIR);\n  \n  if (!existsSync(dir)) {\n    return [];\n  }\n\n  const { readdirSync } = require('fs');\n  const files = readdirSync(dir) as string[];\n  const states: WorkflowState[] = [];\n\n  for (const file of files) {\n    if (file.startsWith('workflow-') && file.endsWith('.json')) {\n      try {\n        const content = readFileSync(resolve(dir, file), 'utf-8');\n        const state = JSON.parse(content) as WorkflowState;\n        states.push(state);\n      } catch {\n        // Skip invalid files\n      }\n    }\n  }\n\n  return states;\n}\n\n/**\n * Clean up old workflow states\n */\nexport function cleanupOldStates(\n  maxAgeDays: number = 30,\n  stateDir?: string\n): number {\n  const states = listStates(stateDir);\n  const cutoffDate = new Date();\n  cutoffDate.setDate(cutoffDate.getDate() - maxAgeDays);\n  \n  let cleaned = 0;\n  const { unlinkSync } = require('fs');\n\n  for (const state of states) {\n    const lastUpdated = new Date(state.lastUpdated);\n    if (lastUpdated < cutoffDate && state.status === 'completed') {\n      const filePath = getStateFilePath(state.workItemId, stateDir);\n      try {\n        unlinkSync(filePath);\n        cleaned++;\n        logDebug(`Cleaned up state for work item ${state.workItemId}`);\n      } catch {\n        // Ignore errors\n      }\n    }\n  }\n\n  if (cleaned > 0) {\n    logInfo(`Cleaned up ${cleaned} old workflow states`);\n  }\n\n  return cleaned;\n}\n","/**\n * Workflow Runner\n * Orchestrates workflow execution across phases and steps\n */\n\nimport { loadStepManifests, loadSharedConfig } from './lib/configLoader.js';\nimport { \n  loadState, \n  saveState, \n  createState, \n  setCurrentStep, \n  completeStep, \n  skipStep, \n  updateStatus,\n  getProgress,\n} from './workflowState.js';\nimport { prepareTicketArtifacts } from './workflowPrepareTicket.js';\nimport { logInfo, logDebug, logWarn, logError, createTimer } from './lib/loggerStructured.js';\nimport type {\n  WorkflowState,\n  WorkflowExecutionOptions,\n  WorkflowExecutionResult,\n  WorkflowLogEntry,\n  StepManifest,\n  StepCondition,\n} from './types/configTypes.js';\n\n/**\n * Run a workflow for a work item\n * \n * @param options - Execution options\n * @returns Execution result\n */\nexport async function runWorkflow(\n  options: WorkflowExecutionOptions\n): Promise<WorkflowExecutionResult> {\n  const timer = createTimer();\n  const { workItemId, phases, steps, dryRun = false, verbose = false, continueOnError = false } = options;\n\n  logInfo(`Starting workflow for work item ${workItemId}`, { dryRun, phases, steps });\n\n  const logs: WorkflowLogEntry[] = [];\n  const executedSteps: string[] = [];\n  const failedSteps: string[] = [];\n  const outputs: Record<string, unknown> = {};\n\n  // Load or create state\n  let state = loadState(workItemId) ?? createState(workItemId);\n  state = updateStatus(state, 'in_progress');\n  \n  if (!dryRun) {\n    saveState(state);\n  }\n\n  // Load step manifests\n  let manifests: StepManifest[];\n  try {\n    manifests = loadStepManifests();\n  } catch (error) {\n    const errorMsg = `Failed to load step manifests: ${error instanceof Error ? error.message : String(error)}`;\n    logError(errorMsg);\n    \n    return {\n      success: false,\n      state: updateStatus(state, 'failed', errorMsg),\n      executedSteps,\n      failedSteps,\n      outputs,\n      executionTime: timer.elapsed(),\n      logs,\n    };\n  }\n\n  // Filter manifests by phases/steps if specified\n  let filteredManifests = manifests;\n  \n  if (phases && phases.length > 0) {\n    filteredManifests = manifests.filter(m => phases.includes(m.phase));\n  }\n  \n  if (steps && steps.length > 0) {\n    filteredManifests = filteredManifests.filter(m => steps.includes(m.id));\n  }\n\n  // Sort by phase and order\n  filteredManifests.sort((a, b) => {\n    if (a.phase !== b.phase) {\n      return a.phase.localeCompare(b.phase);\n    }\n    return a.order - b.order;\n  });\n\n  logInfo(`Executing ${filteredManifests.length} steps`);\n\n  // Execute each step\n  for (const manifest of filteredManifests) {\n    const stepLog = (level: WorkflowLogEntry['level'], message: string, data?: unknown): void => {\n      const entry: WorkflowLogEntry = {\n        timestamp: new Date().toISOString(),\n        level,\n        step: manifest.id,\n        message,\n        data,\n      };\n      logs.push(entry);\n      \n      if (verbose) {\n        console.log(`[${level.toUpperCase()}] ${manifest.id}: ${message}`);\n      }\n    };\n\n    // Check if step is already completed\n    if (state.completedSteps.includes(manifest.id)) {\n      stepLog('info', 'Step already completed, skipping');\n      continue;\n    }\n\n    // Check conditions\n    if (manifest.conditions && manifest.conditions.length > 0) {\n      const conditionsMet = evaluateConditions(manifest.conditions, state);\n      if (!conditionsMet) {\n        stepLog('info', 'Step conditions not met, skipping');\n        state = skipStep(state, manifest.id);\n        if (!dryRun) {\n          saveState(state);\n        }\n        continue;\n      }\n    }\n\n    // Check dependencies\n    if (manifest.dependencies && manifest.dependencies.length > 0) {\n      const missingDeps = manifest.dependencies.filter(\n        dep => !state.completedSteps.includes(dep)\n      );\n      \n      if (missingDeps.length > 0) {\n        stepLog('warn', `Missing dependencies: ${missingDeps.join(', ')}`);\n        \n        if (!continueOnError) {\n          failedSteps.push(manifest.id);\n          state = updateStatus(state, 'failed', `Missing dependencies: ${missingDeps.join(', ')}`);\n          break;\n        }\n        \n        state = skipStep(state, manifest.id);\n        if (!dryRun) {\n          saveState(state);\n        }\n        continue;\n      }\n    }\n\n    // Set current step\n    state = setCurrentStep(state, manifest.phase, manifest.id);\n    if (!dryRun) {\n      saveState(state);\n    }\n\n    stepLog('info', `Starting step: ${manifest.name}`);\n\n    try {\n      if (dryRun) {\n        stepLog('info', '[DRY RUN] Would execute step');\n        executedSteps.push(manifest.id);\n        state = completeStep(state, manifest.id);\n      } else {\n        // Execute the step\n        const result = await executeStep(manifest, state);\n        \n        if (result.success) {\n          stepLog('info', 'Step completed successfully');\n          executedSteps.push(manifest.id);\n          state = completeStep(state, manifest.id);\n          \n          if (result.outputs) {\n            Object.assign(outputs, result.outputs);\n          }\n        } else {\n          stepLog('error', `Step failed: ${result.error}`);\n          failedSteps.push(manifest.id);\n          \n          if (!continueOnError) {\n            state = updateStatus(state, 'failed', result.error);\n            saveState(state);\n            break;\n          }\n        }\n        \n        saveState(state);\n      }\n    } catch (error) {\n      const errorMsg = error instanceof Error ? error.message : String(error);\n      stepLog('error', `Step threw exception: ${errorMsg}`);\n      failedSteps.push(manifest.id);\n      \n      if (!continueOnError) {\n        state = updateStatus(state, 'failed', errorMsg);\n        if (!dryRun) {\n          saveState(state);\n        }\n        break;\n      }\n    }\n  }\n\n  // Update final status\n  if (failedSteps.length === 0) {\n    state = updateStatus(state, 'completed');\n  } else if (state.status !== 'failed') {\n    state = updateStatus(state, 'completed'); // Completed with some failures\n  }\n\n  if (!dryRun) {\n    saveState(state);\n  }\n\n  const executionTime = timer.elapsed();\n  logInfo(`Workflow completed in ${executionTime}ms`, {\n    executed: executedSteps.length,\n    failed: failedSteps.length,\n  });\n\n  return {\n    success: failedSteps.length === 0,\n    state,\n    executedSteps,\n    failedSteps,\n    outputs,\n    executionTime,\n    logs,\n  };\n}\n\n/**\n * Execute a single step\n */\nasync function executeStep(\n  manifest: StepManifest,\n  state: WorkflowState\n): Promise<StepExecutionResult> {\n  logDebug(`Executing step: ${manifest.id}`);\n\n  // For now, steps are executed via their script_alternative if present\n  // In a full implementation, this would integrate with the prompt system\n  \n  if (manifest.script_alternative) {\n    // Execute script alternative\n    try {\n      // This would execute the CLI command\n      logInfo(`Would execute: ${manifest.script_alternative}`);\n      \n      return {\n        success: true,\n        outputs: {},\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : String(error),\n      };\n    }\n  }\n\n  // No script alternative - this step requires manual/prompt execution\n  logDebug(`Step ${manifest.id} requires prompt execution`);\n  \n  return {\n    success: true,\n    outputs: {},\n  };\n}\n\n/**\n * Step execution result\n */\ninterface StepExecutionResult {\n  success: boolean;\n  error?: string;\n  outputs?: Record<string, unknown>;\n}\n\n/**\n * Evaluate step conditions\n */\nfunction evaluateConditions(\n  conditions: StepCondition[],\n  state: WorkflowState\n): boolean {\n  for (const condition of conditions) {\n    const fieldValue = state.variables[condition.field];\n    \n    switch (condition.operator) {\n      case 'equals':\n        if (fieldValue !== condition.value) return false;\n        break;\n      case 'notEquals':\n        if (fieldValue === condition.value) return false;\n        break;\n      case 'contains':\n        if (typeof fieldValue !== 'string' || !fieldValue.includes(String(condition.value))) {\n          return false;\n        }\n        break;\n      case 'exists':\n        if (fieldValue === undefined || fieldValue === null) return false;\n        break;\n      case 'notExists':\n        if (fieldValue !== undefined && fieldValue !== null) return false;\n        break;\n    }\n  }\n  \n  return true;\n}\n\n/**\n * Generate a workflow execution plan\n */\nexport function generateWorkflowPlan(\n  options: WorkflowExecutionOptions\n): WorkflowPlan {\n  const { workItemId, phases, steps } = options;\n\n  logInfo(`Generating workflow plan for work item ${workItemId}`);\n\n  // Load manifests\n  let manifests: StepManifest[];\n  try {\n    manifests = loadStepManifests();\n  } catch {\n    manifests = [];\n  }\n\n  // Filter and sort\n  let filteredManifests = manifests;\n  \n  if (phases && phases.length > 0) {\n    filteredManifests = manifests.filter(m => phases.includes(m.phase));\n  }\n  \n  if (steps && steps.length > 0) {\n    filteredManifests = filteredManifests.filter(m => steps.includes(m.id));\n  }\n\n  filteredManifests.sort((a, b) => {\n    if (a.phase !== b.phase) {\n      return a.phase.localeCompare(b.phase);\n    }\n    return a.order - b.order;\n  });\n\n  // Group by phase\n  const phaseGroups = new Map<string, StepManifest[]>();\n  \n  for (const manifest of filteredManifests) {\n    if (!phaseGroups.has(manifest.phase)) {\n      phaseGroups.set(manifest.phase, []);\n    }\n    phaseGroups.get(manifest.phase)!.push(manifest);\n  }\n\n  // Build plan\n  const planPhases: WorkflowPlanPhase[] = [];\n  \n  for (const [phaseName, phaseSteps] of phaseGroups) {\n    planPhases.push({\n      name: phaseName,\n      steps: phaseSteps.map(s => ({\n        id: s.id,\n        name: s.name,\n        description: s.description,\n        dependencies: s.dependencies ?? [],\n        hasScriptAlternative: !!s.script_alternative,\n      })),\n    });\n  }\n\n  return {\n    workItemId,\n    totalSteps: filteredManifests.length,\n    phases: planPhases,\n  };\n}\n\n/**\n * Workflow plan interface\n */\nexport interface WorkflowPlan {\n  workItemId: number;\n  totalSteps: number;\n  phases: WorkflowPlanPhase[];\n}\n\n/**\n * Workflow plan phase\n */\nexport interface WorkflowPlanPhase {\n  name: string;\n  steps: WorkflowPlanStep[];\n}\n\n/**\n * Workflow plan step\n */\nexport interface WorkflowPlanStep {\n  id: string;\n  name: string;\n  description: string;\n  dependencies: string[];\n  hasScriptAlternative: boolean;\n}\n\n/**\n * Get available phases\n */\nexport function getAvailablePhases(): string[] {\n  try {\n    const manifests = loadStepManifests();\n    const phases = new Set(manifests.map(m => m.phase));\n    return Array.from(phases).sort();\n  } catch {\n    return [];\n  }\n}\n\n/**\n * Get steps for a phase\n */\nexport function getStepsForPhase(phase: string): StepManifest[] {\n  try {\n    const manifests = loadStepManifests();\n    return manifests\n      .filter(m => m.phase === phase)\n      .sort((a, b) => a.order - b.order);\n  } catch {\n    return [];\n  }\n}\n","/**\n * Workflow Executor\n * Low-level execution of workflow phases and steps\n */\n\nimport { execSync, spawn, type ChildProcess } from 'child_process';\nimport { existsSync, readFileSync } from 'fs';\nimport { resolve } from 'path';\nimport { logInfo, logDebug, logWarn, logError, createTimer } from './lib/loggerStructured.js';\nimport type { StepManifest, WorkflowState, WorkflowLogEntry } from './types/configTypes.js';\n\n/**\n * Phase execution options\n */\nexport interface PhaseExecutionOptions {\n  phaseName: string;\n  steps: StepManifest[];\n  state: WorkflowState;\n  dryRun?: boolean;\n  verbose?: boolean;\n  timeout?: number;\n}\n\n/**\n * Phase execution result\n */\nexport interface PhaseExecutionResult {\n  success: boolean;\n  phaseName: string;\n  executedSteps: string[];\n  failedSteps: string[];\n  logs: WorkflowLogEntry[];\n  duration: number;\n}\n\n/**\n * Step execution options\n */\nexport interface StepExecutionOptions {\n  manifest: StepManifest;\n  state: WorkflowState;\n  dryRun?: boolean;\n  verbose?: boolean;\n  timeout?: number;\n}\n\n/**\n * Step execution result\n */\nexport interface StepExecutionResult {\n  success: boolean;\n  stepId: string;\n  output?: string;\n  error?: string;\n  duration: number;\n}\n\n/**\n * Execute a workflow phase\n */\nexport async function executePhase(\n  options: PhaseExecutionOptions\n): Promise<PhaseExecutionResult> {\n  const timer = createTimer();\n  const { phaseName, steps, state, dryRun = false, verbose = false } = options;\n\n  logInfo(`Executing phase: ${phaseName}`, { stepCount: steps.length });\n\n  const executedSteps: string[] = [];\n  const failedSteps: string[] = [];\n  const logs: WorkflowLogEntry[] = [];\n\n  for (const step of steps) {\n    const log = (level: WorkflowLogEntry['level'], message: string): void => {\n      logs.push({\n        timestamp: new Date().toISOString(),\n        level,\n        step: step.id,\n        message,\n      });\n      \n      if (verbose) {\n        console.log(`[${phaseName}/${step.id}] ${message}`);\n      }\n    };\n\n    log('info', `Starting step: ${step.name}`);\n\n    try {\n      const result = await executeStep({\n        manifest: step,\n        state,\n        dryRun,\n        verbose,\n        timeout: options.timeout,\n      });\n\n      if (result.success) {\n        log('info', 'Step completed');\n        executedSteps.push(step.id);\n      } else {\n        log('error', `Step failed: ${result.error}`);\n        failedSteps.push(step.id);\n      }\n    } catch (error) {\n      log('error', `Step threw exception: ${error instanceof Error ? error.message : String(error)}`);\n      failedSteps.push(step.id);\n    }\n  }\n\n  const duration = timer.elapsed();\n  logInfo(`Phase ${phaseName} completed in ${duration}ms`, {\n    executed: executedSteps.length,\n    failed: failedSteps.length,\n  });\n\n  return {\n    success: failedSteps.length === 0,\n    phaseName,\n    executedSteps,\n    failedSteps,\n    logs,\n    duration,\n  };\n}\n\n/**\n * Execute a single workflow step\n */\nexport async function executeStep(\n  options: StepExecutionOptions\n): Promise<StepExecutionResult> {\n  const timer = createTimer();\n  const { manifest, state, dryRun = false, verbose = false, timeout = 300000 } = options;\n\n  logDebug(`Executing step: ${manifest.id}`);\n\n  if (dryRun) {\n    logDebug(`[DRY RUN] Would execute: ${manifest.name}`);\n    return {\n      success: true,\n      stepId: manifest.id,\n      output: '[DRY RUN] Step would be executed',\n      duration: timer.elapsed(),\n    };\n  }\n\n  // Check for script alternative\n  if (manifest.script_alternative) {\n    return executeScriptAlternative(manifest, state, timeout);\n  }\n\n  // Step requires prompt-based execution\n  logDebug(`Step ${manifest.id} requires prompt-based execution`);\n  \n  return {\n    success: true,\n    stepId: manifest.id,\n    output: 'Step requires prompt-based execution',\n    duration: timer.elapsed(),\n  };\n}\n\n/**\n * Execute a script alternative command\n */\nasync function executeScriptAlternative(\n  manifest: StepManifest,\n  state: WorkflowState,\n  timeout: number\n): Promise<StepExecutionResult> {\n  const timer = createTimer();\n  const command = manifest.script_alternative!;\n\n  logInfo(`Executing script: ${command}`);\n\n  try {\n    // Replace variables in command\n    let resolvedCommand = command;\n    \n    for (const [key, value] of Object.entries(state.variables)) {\n      if (value !== undefined && value !== null) {\n        resolvedCommand = resolvedCommand.replace(\n          new RegExp(`\\\\{\\\\{${key}\\\\}\\\\}`, 'g'),\n          String(value)\n        );\n      }\n    }\n\n    logDebug(`Resolved command: ${resolvedCommand}`);\n\n    const output = execSync(resolvedCommand, {\n      encoding: 'utf-8',\n      timeout,\n      cwd: process.cwd(),\n      env: {\n        ...process.env,\n        WORK_ITEM_ID: String(state.workItemId),\n      },\n    });\n\n    return {\n      success: true,\n      stepId: manifest.id,\n      output: output.trim(),\n      duration: timer.elapsed(),\n    };\n  } catch (error) {\n    const errorMsg = error instanceof Error ? error.message : String(error);\n    logError(`Script failed: ${errorMsg}`);\n\n    return {\n      success: false,\n      stepId: manifest.id,\n      error: errorMsg,\n      duration: timer.elapsed(),\n    };\n  }\n}\n\n/**\n * Execute a command asynchronously with streaming output\n */\nexport function executeCommandAsync(\n  command: string,\n  args: string[],\n  options: {\n    cwd?: string;\n    env?: Record<string, string>;\n    onStdout?: (data: string) => void;\n    onStderr?: (data: string) => void;\n    timeout?: number;\n  } = {}\n): Promise<{ exitCode: number; stdout: string; stderr: string }> {\n  return new Promise((resolve, reject) => {\n    const { cwd, env, onStdout, onStderr, timeout = 300000 } = options;\n\n    let stdout = '';\n    let stderr = '';\n    let killed = false;\n\n    const proc: ChildProcess = spawn(command, args, {\n      cwd,\n      env: { ...process.env, ...env },\n      shell: true,\n    });\n\n    // Set timeout\n    const timeoutId = setTimeout(() => {\n      killed = true;\n      proc.kill('SIGTERM');\n    }, timeout);\n\n    proc.stdout?.on('data', (data: Buffer) => {\n      const text = data.toString();\n      stdout += text;\n      if (onStdout) onStdout(text);\n    });\n\n    proc.stderr?.on('data', (data: Buffer) => {\n      const text = data.toString();\n      stderr += text;\n      if (onStderr) onStderr(text);\n    });\n\n    proc.on('close', (exitCode) => {\n      clearTimeout(timeoutId);\n      \n      if (killed) {\n        reject(new Error('Command timed out'));\n      } else {\n        resolve({\n          exitCode: exitCode ?? 1,\n          stdout,\n          stderr,\n        });\n      }\n    });\n\n    proc.on('error', (error) => {\n      clearTimeout(timeoutId);\n      reject(error);\n    });\n  });\n}\n\n/**\n * Check if inputs are available for a step\n */\nexport function checkStepInputs(\n  manifest: StepManifest,\n  state: WorkflowState\n): { available: boolean; missing: string[] } {\n  const missing: string[] = [];\n\n  for (const input of manifest.inputs) {\n    if (!input.required) continue;\n\n    // Check variables\n    if (input.source?.startsWith('variable:')) {\n      const varName = input.source.replace('variable:', '');\n      if (state.variables[varName] === undefined) {\n        missing.push(input.name);\n      }\n      continue;\n    }\n\n    // Check artifacts\n    if (input.source?.startsWith('artifact:')) {\n      const artifactName = input.source.replace('artifact:', '');\n      if (!state.artifacts[artifactName]) {\n        missing.push(input.name);\n      }\n      continue;\n    }\n\n    // Check files\n    if (input.type === 'file') {\n      const filePath = state.artifacts[input.name];\n      if (!filePath || !existsSync(filePath)) {\n        missing.push(input.name);\n      }\n    }\n  }\n\n  return {\n    available: missing.length === 0,\n    missing,\n  };\n}\n\n/**\n * Collect step outputs and update state\n */\nexport function collectStepOutputs(\n  manifest: StepManifest,\n  result: StepExecutionResult,\n  state: WorkflowState\n): Record<string, unknown> {\n  const outputs: Record<string, unknown> = {};\n\n  for (const output of manifest.outputs) {\n    if (output.type === 'file' && output.path) {\n      const filePath = resolve(process.cwd(), output.path);\n      if (existsSync(filePath)) {\n        outputs[output.name] = filePath;\n        \n        // Also try to read content for JSON outputs\n        if (output.type === 'json') {\n          try {\n            const content = readFileSync(filePath, 'utf-8');\n            outputs[`${output.name}_content`] = JSON.parse(content);\n          } catch {\n            // Ignore parse errors\n          }\n        }\n      }\n    } else if (output.type === 'string' && result.output) {\n      outputs[output.name] = result.output;\n    }\n  }\n\n  return outputs;\n}\n\n/**\n * Format step result for logging\n */\nexport function formatStepResult(result: StepExecutionResult): string {\n  const status = result.success ? 'SUCCESS' : 'FAILED';\n  const duration = `${result.duration}ms`;\n  \n  let message = `[${status}] ${result.stepId} (${duration})`;\n  \n  if (!result.success && result.error) {\n    message += `\\n  Error: ${result.error}`;\n  }\n  \n  if (result.output) {\n    const truncatedOutput = result.output.length > 200 \n      ? `${result.output.substring(0, 200)}...` \n      : result.output;\n    message += `\\n  Output: ${truncatedOutput}`;\n  }\n  \n  return message;\n}\n"],"mappings":"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","names":["config","resolve","config","conn","Operation","config","Operation","config","config","config","config","config","current","config","config","config","process","config","existsSync","mkdirSync","writeFileSync","resolve","readFileSync","readFileSync","existsSync","resolve","resolve","existsSync","readFileSync","resolve","existsSync","mkdirSync","writeFileSync","resolve","existsSync","execSync","existsSync","readFileSync","resolve","executeStep","output","execSync","resolve","existsSync","readFileSync"]}