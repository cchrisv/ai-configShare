{"version":3,"sources":["../../cli/sf-tools.ts","../../src/lib/authSalesforceCli.ts","../../src/types/sfMetadataTypes.ts","../../src/lib/loggerStructured.ts","../../src/sfClient.ts","../../src/lib/retryWithBackoff.ts","../../src/lib/validationSchemas.ts","../../src/sfQueryExecutor.ts","../../src/sfMetadataDescriber.ts","../../src/sfDependencyTraverser.ts","../../src/sfDependencyEnrichment.ts","../../src/sfDependencyDiscovery.ts"],"sourcesContent":["#!/usr/bin/env node\n/**\n * SF Tools CLI\n * Command-line interface for Salesforce operations\n */\n\nimport { Command } from 'commander';\nimport { executeSoqlQuery, executeToolingQuery, queryAll } from '../src/sfQueryExecutor.js';\nimport { \n  describeObject, \n  describeField,\n  getApexClasses,\n  getApexTriggers,\n  getValidationRules,\n  getFlows,\n  getCustomObjects,\n} from '../src/sfMetadataDescriber.js';\nimport { discoverDependencies, exportGraphToJson } from '../src/sfDependencyDiscovery.js';\nimport { configureLogger } from '../src/lib/loggerStructured.js';\nimport type { MetadataType } from '../src/types/sfDependencyTypes.js';\n\nconst program = new Command();\n\nprogram\n  .name('sf-tools')\n  .description('Salesforce query and metadata operations')\n  .version('2.0.0');\n\n// Query command\nprogram\n  .command('query <soql>')\n  .description('Execute a SOQL query')\n  .option('--tooling', 'Use Tooling API')\n  .option('--all', 'Fetch all records (handle pagination)')\n  .option('-o, --org <alias>', 'Org alias (uses default org if not specified)')\n  .option('--json', 'Output as JSON (default)')\n  .option('-v, --verbose', 'Verbose output')\n  .action(async (soql: string, options) => {\n    try {\n      // Silence logs when outputting JSON to keep stdout clean\n      if (options.json || !options.verbose) {\n        configureLogger({ silent: true });\n      } else if (options.verbose) {\n        configureLogger({ minLevel: 'debug' });\n      }\n\n      let result;\n      \n      if (options.all && !options.tooling) {\n        // Use queryAll for full pagination\n        result = await queryAll(soql, { alias: options.org });\n        console.log(JSON.stringify({ totalSize: result.length, records: result }, null, 2));\n      } else if (options.tooling) {\n        result = await executeToolingQuery(soql, { alias: options.org });\n        console.log(JSON.stringify(result, null, 2));\n      } else {\n        result = await executeSoqlQuery(soql, { alias: options.org });\n        console.log(JSON.stringify(result, null, 2));\n      }\n    } catch (error) {\n      console.error('Error:', error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\n// Describe command\nprogram\n  .command('describe <objectName>')\n  .description('Describe an SObject')\n  .option('-f, --field <fieldName>', 'Describe a specific field')\n  .option('--fields-only', 'Only output field information')\n  .option('-o, --org <alias>', 'Org alias (uses default org if not specified)')\n  .option('--json', 'Output as JSON (default)')\n  .option('-v, --verbose', 'Verbose output')\n  .action(async (objectName: string, options) => {\n    try {\n      // Silence logs by default for clean JSON output, unless verbose\n      if (options.verbose) {\n        configureLogger({ minLevel: 'debug' });\n      } else {\n        configureLogger({ silent: true });\n      }\n\n      if (options.field) {\n        // Describe specific field\n        const field = await describeField(objectName, options.field, { alias: options.org });\n        console.log(JSON.stringify(field, null, 2));\n      } else {\n        // Describe object\n        const describe = await describeObject(objectName, { alias: options.org });\n        \n        if (options.fieldsOnly) {\n          console.log(JSON.stringify(describe.fields, null, 2));\n        } else {\n          console.log(JSON.stringify(describe, null, 2));\n        }\n      }\n    } catch (error) {\n      console.error('Error:', error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\n// Discover command\nprogram\n  .command('discover')\n  .description('Discover metadata dependencies')\n  .requiredOption('--type <type>', 'Metadata type (CustomObject, CustomField, ApexClass, etc.)')\n  .requiredOption('--name <name>', 'Component name')\n  .option('--depth <n>', 'Maximum traversal depth', parseInt, 3)\n  .option('--include-standard', 'Include standard objects')\n  .option('-o, --org <alias>', 'Org alias (uses default org if not specified)')\n  .option('--json', 'Output as JSON (default)')\n  .option('-v, --verbose', 'Verbose output')\n  .action(async (options) => {\n    try {\n      // Silence logs by default for clean JSON output, unless verbose\n      if (options.verbose) {\n        configureLogger({ minLevel: 'debug' });\n      } else {\n        configureLogger({ silent: true });\n      }\n\n      const result = await discoverDependencies(\n        {\n          rootType: options.type as MetadataType,\n          rootName: options.name,\n          maxDepth: options.depth,\n          includeStandardObjects: options.includeStandard,\n        },\n        { alias: options.org }\n      );\n\n      // Convert graph to JSON-serializable format\n      const output = {\n        graph: JSON.parse(exportGraphToJson(result.graph)),\n        pills: result.pills,\n        warnings: result.warnings,\n        executionTime: result.executionTime,\n      };\n\n      console.log(JSON.stringify(output, null, 2));\n    } catch (error) {\n      console.error('Error:', error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\n// Apex classes command\nprogram\n  .command('apex-classes')\n  .description('List Apex classes')\n  .option('--pattern <pattern>', 'Name pattern (use % for wildcard)')\n  .option('-o, --org <alias>', 'Org alias (uses default org if not specified)')\n  .option('--json', 'Output as JSON (default)')\n  .option('-v, --verbose', 'Verbose output')\n  .action(async (options) => {\n    try {\n      // Silence logs by default for clean JSON output, unless verbose\n      if (options.verbose) {\n        configureLogger({ minLevel: 'debug' });\n      } else {\n        configureLogger({ silent: true });\n      }\n\n      const classes = await getApexClasses(options.pattern, { alias: options.org });\n      console.log(JSON.stringify(classes, null, 2));\n    } catch (error) {\n      console.error('Error:', error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\n// Apex triggers command\nprogram\n  .command('apex-triggers')\n  .description('List Apex triggers')\n  .option('--object <name>', 'Filter by object name')\n  .option('-o, --org <alias>', 'Org alias (uses default org if not specified)')\n  .option('--json', 'Output as JSON (default)')\n  .option('-v, --verbose', 'Verbose output')\n  .action(async (options) => {\n    try {\n      // Silence logs by default for clean JSON output, unless verbose\n      if (options.verbose) {\n        configureLogger({ minLevel: 'debug' });\n      } else {\n        configureLogger({ silent: true });\n      }\n\n      const triggers = await getApexTriggers(options.object, { alias: options.org });\n      console.log(JSON.stringify(triggers, null, 2));\n    } catch (error) {\n      console.error('Error:', error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\n// Validation rules command\nprogram\n  .command('validation-rules <objectName>')\n  .description('List validation rules for an object')\n  .option('--all', 'Include inactive rules')\n  .option('-o, --org <alias>', 'Org alias (uses default org if not specified)')\n  .option('--json', 'Output as JSON (default)')\n  .option('-v, --verbose', 'Verbose output')\n  .action(async (objectName: string, options) => {\n    try {\n      // Silence logs by default for clean JSON output, unless verbose\n      if (options.verbose) {\n        configureLogger({ minLevel: 'debug' });\n      } else {\n        configureLogger({ silent: true });\n      }\n\n      const rules = await getValidationRules(objectName, !options.all, { alias: options.org });\n      console.log(JSON.stringify(rules, null, 2));\n    } catch (error) {\n      console.error('Error:', error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\n// Flows command\nprogram\n  .command('flows')\n  .description('List flows')\n  .option('--object <name>', 'Filter by trigger object')\n  .option('--all', 'Include inactive flows')\n  .option('-o, --org <alias>', 'Org alias (uses default org if not specified)')\n  .option('--json', 'Output as JSON (default)')\n  .option('-v, --verbose', 'Verbose output')\n  .action(async (options) => {\n    try {\n      // Silence logs by default for clean JSON output, unless verbose\n      if (options.verbose) {\n        configureLogger({ minLevel: 'debug' });\n      } else {\n        configureLogger({ silent: true });\n      }\n\n      const flows = await getFlows(options.object, !options.all, { alias: options.org });\n      console.log(JSON.stringify(flows, null, 2));\n    } catch (error) {\n      console.error('Error:', error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\n// Custom objects command\nprogram\n  .command('custom-objects')\n  .description('List custom objects')\n  .option('-o, --org <alias>', 'Org alias (uses default org if not specified)')\n  .option('--json', 'Output as JSON (default)')\n  .option('-v, --verbose', 'Verbose output')\n  .action(async (options) => {\n    try {\n      // Silence logs by default for clean JSON output, unless verbose\n      if (options.verbose) {\n        configureLogger({ minLevel: 'debug' });\n      } else {\n        configureLogger({ silent: true });\n      }\n\n      const objects = await getCustomObjects({ alias: options.org });\n      console.log(JSON.stringify(objects, null, 2));\n    } catch (error) {\n      console.error('Error:', error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\nprogram.parse();\n","/**\n * Salesforce CLI Authentication\n * Reuses existing SF CLI authentication sessions\n */\n\nimport { AuthInfo, Connection, Org, ConfigAggregator } from '@salesforce/core';\n\n/**\n * Connection cache to avoid repeated auth lookups\n */\nconst connectionCache = new Map<string, Connection>();\n\n/**\n * Get the default org alias/username from SF CLI config\n * \n * @returns The default org alias or undefined if not set\n */\nasync function getDefaultOrgAlias(): Promise<string | undefined> {\n  try {\n    const configAggregator = await ConfigAggregator.create();\n    const targetOrg = configAggregator.getPropertyValue('target-org');\n    return typeof targetOrg === 'string' ? targetOrg : undefined;\n  } catch {\n    return undefined;\n  }\n}\n\n/**\n * Get a Salesforce connection using existing SF CLI authentication\n * \n * @param aliasOrUsername - Org alias or username (if not provided, uses default org)\n * @returns Salesforce Connection instance\n * @throws Error if not authenticated to the specified org\n */\nexport async function getSfConnection(aliasOrUsername?: string): Promise<Connection> {\n  // If no alias provided, get the default org\n  let targetAlias = aliasOrUsername;\n  if (!targetAlias) {\n    targetAlias = await getDefaultOrgAlias();\n    if (!targetAlias) {\n      throw new Error(\n        'No default Salesforce org is set. Please run: sf config set target-org <alias>'\n      );\n    }\n  }\n\n  // Check cache first\n  const cached = connectionCache.get(targetAlias);\n  if (cached) {\n    // Verify connection is still valid\n    try {\n      await cached.identity();\n      return cached;\n    } catch {\n      // Connection expired, remove from cache\n      connectionCache.delete(targetAlias);\n    }\n  }\n\n  try {\n    // Use Org.create which handles alias resolution automatically\n    const org = await Org.create({ aliasOrUsername: targetAlias });\n    const connection = org.getConnection();\n\n    // Cache the connection using the alias/username that was requested\n    connectionCache.set(targetAlias, connection);\n\n    return connection;\n  } catch (error) {\n    if (error instanceof Error) {\n      if (error.message.includes('No authorization found') ||\n          error.message.includes('NamedOrgNotFound') ||\n          error.message.includes('No authorization information')) {\n        throw new Error(\n          `Salesforce org '${targetAlias}' is not authenticated. Please run: sf org login web -a ${targetAlias}`\n        );\n      }\n      throw new Error(`Failed to connect to Salesforce: ${error.message}`);\n    }\n    throw error;\n  }\n}\n\n/**\n * Validate that SF CLI is authenticated to the specified org\n * \n * @param alias - Org alias or username to validate (uses default if not provided)\n * @throws Error if not authenticated\n */\nexport async function validateSfAuth(alias?: string): Promise<void> {\n  let targetAlias = alias;\n  if (!targetAlias) {\n    targetAlias = await getDefaultOrgAlias();\n    if (!targetAlias) {\n      throw new Error('No default Salesforce org is set.');\n    }\n  }\n\n  const auths = await AuthInfo.listAllAuthorizations();\n  \n  const found = auths.some(auth => \n    auth.username === targetAlias || \n    auth.aliases?.includes(targetAlias!)\n  );\n\n  if (!found) {\n    throw new Error(\n      `Salesforce org '${targetAlias}' is not authenticated. Please run: sf org login web -a ${targetAlias}`\n    );\n  }\n}\n\n/**\n * List all authenticated Salesforce orgs\n * \n * @returns Array of org information\n */\nexport async function listSfOrgs(): Promise<SfOrgInfo[]> {\n  const auths = await AuthInfo.listAllAuthorizations();\n  \n  return auths.map(auth => ({\n    username: auth.username,\n    aliases: auth.aliases ?? [],\n    instanceUrl: auth.instanceUrl ?? '',\n    orgId: auth.orgId ?? '',\n    isDefaultUsername: auth.isDefaultUsername ?? false,\n    isDefaultDevhubUsername: auth.isDefaultDevhubUsername ?? false,\n  }));\n}\n\n/**\n * Get detailed org information\n * \n * @param alias - Org alias or username (uses default if not provided)\n * @returns Org details\n */\nexport async function getSfOrgInfo(alias?: string): Promise<SfOrgDetails> {\n  const connection = await getSfConnection(alias);\n  const org = await Org.create({ connection });\n  \n  const identity = await connection.identity();\n  \n  return {\n    username: identity.username,\n    orgId: identity.organization_id,\n    userId: identity.user_id,\n    instanceUrl: connection.instanceUrl,\n    apiVersion: connection.version,\n    accessToken: connection.accessToken ?? '',\n  };\n}\n\n/**\n * Salesforce org information\n */\nexport interface SfOrgInfo {\n  username: string;\n  aliases: string[];\n  instanceUrl: string;\n  orgId: string;\n  isDefaultUsername: boolean;\n  isDefaultDevhubUsername: boolean;\n}\n\n/**\n * Detailed Salesforce org information\n */\nexport interface SfOrgDetails {\n  username: string;\n  orgId: string;\n  userId: string;\n  instanceUrl: string;\n  apiVersion: string;\n  accessToken: string;\n}\n\n/**\n * Clear the connection cache\n */\nexport function clearConnectionCache(): void {\n  connectionCache.clear();\n}\n\n/**\n * Remove a specific connection from cache\n */\nexport function removeFromCache(alias: string): void {\n  connectionCache.delete(alias);\n}\n","/**\n * Salesforce Metadata Types\n * Type definitions for Salesforce metadata operations\n */\n\n/**\n * Entity Definition from Tooling API\n */\nexport interface EntityDefinition {\n  Id: string;\n  DurableId: string;\n  QualifiedApiName: string;\n  NamespacePrefix: string | null;\n  DeveloperName: string;\n  MasterLabel: string;\n  Label: string;\n  PluralLabel: string;\n  KeyPrefix: string;\n  IsCustomSetting: boolean;\n  IsCustomizable: boolean;\n  IsApexTriggerable: boolean;\n  IsWorkflowEnabled: boolean;\n  IsProcessEnabled: boolean;\n  IsLayoutable: boolean;\n  IsCompactLayoutable: boolean;\n  DeploymentStatus: string;\n  IsSearchable: boolean;\n  IsQueryable: boolean;\n  IsIdEnabled: boolean;\n  IsReplicateable: boolean;\n  IsRetrieveable: boolean;\n  IsCreateable: boolean;\n  IsUpdateable: boolean;\n  IsDeletable: boolean;\n  IsUndeletable: boolean;\n  IsMergeable: boolean;\n  InternalSharingModel: string;\n  ExternalSharingModel: string;\n  RunningUserEntityAccessId: string | null;\n  PublisherId: string;\n}\n\n/**\n * Field Definition from Tooling API\n */\nexport interface FieldDefinition {\n  Id: string;\n  DurableId: string;\n  QualifiedApiName: string;\n  EntityDefinitionId: string;\n  NamespacePrefix: string | null;\n  DeveloperName: string;\n  MasterLabel: string;\n  Label: string;\n  Length: number;\n  DataType: string;\n  ValueTypeId: string;\n  ReferenceTo: {\n    referenceTo: string[];\n  } | null;\n  ReferenceTargetField: string | null;\n  IsCompound: boolean;\n  IsHighScaleNumber: boolean;\n  IsHtmlFormatted: boolean;\n  IsNameField: boolean;\n  IsNillable: boolean;\n  IsCalculated: boolean;\n  IsApiFilterable: boolean;\n  IsApiSortable: boolean;\n  IsApiGroupable: boolean;\n  IsPolymorphicForeignKey: boolean;\n  IsAiPredictionField: boolean;\n  IsCompactLayoutable: boolean;\n  Precision: number;\n  Scale: number;\n  IsFieldHistoryTracked: boolean;\n  IsIndexed: boolean;\n  IsUnique: boolean;\n  IsDeprecatedAndHidden: boolean;\n  ControllingFieldDefinitionId: string | null;\n  BusinessOwnerId: string | null;\n  BusinessStatus: string | null;\n  ComplianceGroup: string | null;\n  SecurityClassification: string | null;\n  Description: string | null;\n  InlineHelpText: string | null;\n  RelationshipName: string | null;\n  LastModifiedDate: string;\n  LastModifiedById: string;\n  PublisherId: string;\n  RunningUserFieldAccessId: string | null;\n}\n\n/**\n * Custom Field from Tooling API\n */\nexport interface CustomField {\n  Id: string;\n  DeveloperName: string;\n  NamespacePrefix: string | null;\n  TableEnumOrId: string;\n  FullName: string;\n  Metadata: CustomFieldMetadata;\n}\n\n/**\n * Custom Field Metadata\n */\nexport interface CustomFieldMetadata {\n  fullName: string;\n  label: string;\n  description: string | null;\n  type: string;\n  length?: number;\n  precision?: number;\n  scale?: number;\n  required?: boolean;\n  unique?: boolean;\n  externalId?: boolean;\n  trackHistory?: boolean;\n  trackFeedHistory?: boolean;\n  inlineHelpText?: string | null;\n  defaultValue?: string | null;\n  formula?: string | null;\n  referenceTo?: string;\n  relationshipLabel?: string;\n  relationshipName?: string;\n  deleteConstraint?: string;\n  valueSet?: ValueSet;\n}\n\n/**\n * Value Set for picklists\n */\nexport interface ValueSet {\n  restricted?: boolean;\n  valueSetDefinition?: {\n    sorted: boolean;\n    value: PicklistValue[];\n  };\n  controllingField?: string;\n}\n\n/**\n * Picklist Value\n */\nexport interface PicklistValue {\n  fullName: string;\n  label: string;\n  default?: boolean;\n  isActive?: boolean;\n  color?: string;\n  description?: string;\n}\n\n/**\n * Apex Class metadata\n */\nexport interface ApexClass {\n  Id: string;\n  Name: string;\n  NamespacePrefix: string | null;\n  ApiVersion: number;\n  Status: string;\n  IsValid: boolean;\n  LengthWithoutComments: number;\n  Body?: string;\n  SymbolTable?: SymbolTable;\n}\n\n/**\n * Symbol Table from Apex Class\n */\nexport interface SymbolTable {\n  name: string;\n  tableDeclaration: {\n    name: string;\n    modifiers: string[];\n    type: string;\n  };\n  variables: SymbolTableVariable[];\n  methods: SymbolTableMethod[];\n  innerClasses?: SymbolTable[];\n}\n\n/**\n * Symbol Table Variable\n */\nexport interface SymbolTableVariable {\n  name: string;\n  type: string;\n  modifiers: string[];\n}\n\n/**\n * Symbol Table Method\n */\nexport interface SymbolTableMethod {\n  name: string;\n  returnType: string;\n  modifiers: string[];\n  parameters: Array<{\n    name: string;\n    type: string;\n  }>;\n}\n\n/**\n * Apex Trigger metadata\n */\nexport interface ApexTrigger {\n  Id: string;\n  Name: string;\n  NamespacePrefix: string | null;\n  TableEnumOrId: string;\n  ApiVersion: number;\n  Status: string;\n  IsValid: boolean;\n  LengthWithoutComments: number;\n  UsageBeforeInsert: boolean;\n  UsageAfterInsert: boolean;\n  UsageBeforeUpdate: boolean;\n  UsageAfterUpdate: boolean;\n  UsageBeforeDelete: boolean;\n  UsageAfterDelete: boolean;\n  UsageAfterUndelete: boolean;\n  UsageIsBulk: boolean;\n  Body?: string;\n}\n\n/**\n * Validation Rule\n */\nexport interface ValidationRule {\n  Id: string;\n  ValidationName: string;\n  EntityDefinitionId: string;\n  Active: boolean;\n  Description: string | null;\n  ErrorDisplayField: string | null;\n  ErrorMessage: string;\n  FullName: string;\n  Metadata: {\n    active: boolean;\n    description: string | null;\n    errorConditionFormula: string;\n    errorDisplayField: string | null;\n    errorMessage: string;\n    fullName: string;\n  };\n}\n\n/**\n * Flow metadata\n */\nexport interface Flow {\n  Id: string;\n  DeveloperName: string;\n  MasterLabel: string;\n  NamespacePrefix: string | null;\n  ApiVersion: number;\n  ProcessType: string;\n  Status: string;\n  Description: string | null;\n  TriggerType: string | null;\n  TriggerObjectOrEvent: string | null;\n  RecordTriggerType: string | null;\n  IsActive: boolean;\n  IsTemplate: boolean;\n  RunInMode: string;\n  LastModifiedDate: string;\n  LastModifiedById: string;\n}\n\n/**\n * Describe SObject result\n */\nexport interface DescribeSObjectResult {\n  name: string;\n  label: string;\n  labelPlural: string;\n  keyPrefix: string;\n  custom: boolean;\n  customSetting: boolean;\n  createable: boolean;\n  updateable: boolean;\n  deletable: boolean;\n  queryable: boolean;\n  searchable: boolean;\n  layoutable: boolean;\n  triggerable: boolean;\n  fields: DescribeFieldResult[];\n  recordTypeInfos?: RecordTypeInfo[];\n  childRelationships?: ChildRelationship[];\n}\n\n/**\n * Describe Field result\n */\nexport interface DescribeFieldResult {\n  name: string;\n  label: string;\n  type: string;\n  length: number;\n  precision?: number;\n  scale?: number;\n  nillable: boolean;\n  unique: boolean;\n  createable: boolean;\n  updateable: boolean;\n  filterable: boolean;\n  sortable: boolean;\n  groupable: boolean;\n  custom: boolean;\n  calculated: boolean;\n  formulaTreatNullNumberAsZero?: boolean;\n  defaultValue?: unknown;\n  inlineHelpText?: string;\n  picklistValues?: PicklistEntry[];\n  referenceTo?: string[];\n  relationshipName?: string;\n  relationshipOrder?: number;\n}\n\n/**\n * Picklist Entry\n */\nexport interface PicklistEntry {\n  value: string;\n  label: string;\n  active: boolean;\n  defaultValue: boolean;\n}\n\n/**\n * Record Type Info\n */\nexport interface RecordTypeInfo {\n  recordTypeId: string;\n  name: string;\n  developerName: string;\n  available: boolean;\n  master: boolean;\n  defaultRecordTypeMapping: boolean;\n}\n\n/**\n * Child Relationship\n */\nexport interface ChildRelationship {\n  childSObject: string;\n  field: string;\n  relationshipName: string;\n  cascadeDelete: boolean;\n  deprecatedAndHidden: boolean;\n  junctionIdListNames?: string[];\n  junctionReferenceTo?: string[];\n  restrictedDelete: boolean;\n}\n\n/**\n * Salesforce defaults\n */\nexport const SF_DEFAULTS = {\n  ORG_ALIAS: 'production',\n  API_VERSION: '59.0',\n} as const;\n","/**\n * Structured Logger\n * JSON-based logging for consistent output\n */\n\n/**\n * Log levels\n */\nexport type LogLevel = 'debug' | 'info' | 'warn' | 'error';\n\n/**\n * Log entry structure\n */\nexport interface LogEntry {\n  timestamp: string;\n  level: LogLevel;\n  message: string;\n  data?: unknown;\n  context?: LogContext;\n}\n\n/**\n * Log context for tracking operations\n */\nexport interface LogContext {\n  operation?: string;\n  workItemId?: number;\n  sfOrg?: string;\n  duration?: number;\n  [key: string]: unknown;\n}\n\n/**\n * Logger configuration\n */\nexport interface LoggerConfig {\n  minLevel: LogLevel;\n  jsonOutput: boolean;\n  includeTimestamp: boolean;\n  context?: LogContext;\n  /** When true, suppress all log output (useful for CLI --json mode) */\n  silent: boolean;\n  /** When true, output to stderr instead of stdout */\n  useStderr: boolean;\n}\n\n/**\n * Log level priority (higher = more important)\n */\nconst LOG_LEVEL_PRIORITY: Record<LogLevel, number> = {\n  debug: 0,\n  info: 1,\n  warn: 2,\n  error: 3,\n};\n\n/**\n * Default logger configuration\n */\nlet config: LoggerConfig = {\n  minLevel: 'info',\n  jsonOutput: false,\n  includeTimestamp: true,\n  silent: false,\n  useStderr: false,\n};\n\n/**\n * Configure the logger\n */\nexport function configureLogger(newConfig: Partial<LoggerConfig>): void {\n  config = { ...config, ...newConfig };\n}\n\n/**\n * Get current logger configuration\n */\nexport function getLoggerConfig(): LoggerConfig {\n  return { ...config };\n}\n\n/**\n * Check if a log level should be output\n */\nfunction shouldLog(level: LogLevel): boolean {\n  if (config.silent) return false;\n  return LOG_LEVEL_PRIORITY[level] >= LOG_LEVEL_PRIORITY[config.minLevel];\n}\n\n/**\n * Output a log message to the appropriate stream\n */\nfunction output(level: LogLevel, message: string): void {\n  if (config.useStderr) {\n    console.error(message);\n  } else {\n    switch (level) {\n      case 'debug':\n        console.debug(message);\n        break;\n      case 'info':\n        console.info(message);\n        break;\n      case 'warn':\n        console.warn(message);\n        break;\n      case 'error':\n        console.error(message);\n        break;\n    }\n  }\n}\n\n/**\n * Format a log entry\n */\nfunction formatEntry(entry: LogEntry): string {\n  if (config.jsonOutput) {\n    return JSON.stringify(entry);\n  }\n\n  const parts: string[] = [];\n\n  if (config.includeTimestamp) {\n    parts.push(`[${entry.timestamp}]`);\n  }\n\n  parts.push(`[${entry.level.toUpperCase()}]`);\n  parts.push(entry.message);\n\n  if (entry.data !== undefined) {\n    if (typeof entry.data === 'object') {\n      parts.push(JSON.stringify(entry.data, null, 2));\n    } else {\n      parts.push(String(entry.data));\n    }\n  }\n\n  return parts.join(' ');\n}\n\n/**\n * Create a log entry\n */\nfunction createEntry(level: LogLevel, message: string, data?: unknown, context?: LogContext): LogEntry {\n  return {\n    timestamp: new Date().toISOString(),\n    level,\n    message,\n    data,\n    context: context ?? config.context,\n  };\n}\n\n/**\n * Log a debug message\n */\nexport function logDebug(message: string, data?: unknown, context?: LogContext): void {\n  if (!shouldLog('debug')) return;\n  const entry = createEntry('debug', message, data, context);\n  output('debug', formatEntry(entry));\n}\n\n/**\n * Log an info message\n */\nexport function logInfo(message: string, data?: unknown, context?: LogContext): void {\n  if (!shouldLog('info')) return;\n  const entry = createEntry('info', message, data, context);\n  output('info', formatEntry(entry));\n}\n\n/**\n * Log a warning message\n */\nexport function logWarn(message: string, data?: unknown, context?: LogContext): void {\n  if (!shouldLog('warn')) return;\n  const entry = createEntry('warn', message, data, context);\n  output('warn', formatEntry(entry));\n}\n\n/**\n * Log an error message\n */\nexport function logError(message: string, data?: unknown, context?: LogContext): void {\n  if (!shouldLog('error')) return;\n  const entry = createEntry('error', message, data, context);\n  output('error', formatEntry(entry));\n}\n\n/**\n * Log an event (always info level, but with structured event data)\n */\nexport function logEvent(event: string, data?: Record<string, unknown>, context?: LogContext): void {\n  if (!shouldLog('info')) return;\n  const entry = createEntry('info', `[EVENT] ${event}`, data, context);\n  output('info', formatEntry(entry));\n}\n\n/**\n * Create a child logger with additional context\n */\nexport function createChildLogger(additionalContext: LogContext): ChildLogger {\n  return {\n    debug: (message: string, data?: unknown) => logDebug(message, data, additionalContext),\n    info: (message: string, data?: unknown) => logInfo(message, data, additionalContext),\n    warn: (message: string, data?: unknown) => logWarn(message, data, additionalContext),\n    error: (message: string, data?: unknown) => logError(message, data, additionalContext),\n    event: (event: string, data?: Record<string, unknown>) => logEvent(event, data, additionalContext),\n  };\n}\n\n/**\n * Child logger interface\n */\nexport interface ChildLogger {\n  debug: (message: string, data?: unknown) => void;\n  info: (message: string, data?: unknown) => void;\n  warn: (message: string, data?: unknown) => void;\n  error: (message: string, data?: unknown) => void;\n  event: (event: string, data?: Record<string, unknown>) => void;\n}\n\n/**\n * Timer utility for measuring operation duration\n */\nexport function createTimer(): Timer {\n  const startTime = Date.now();\n  return {\n    elapsed: () => Date.now() - startTime,\n    elapsedSeconds: () => (Date.now() - startTime) / 1000,\n    log: (operation: string, level: LogLevel = 'info') => {\n      const duration = Date.now() - startTime;\n      const message = `${operation} completed in ${duration}ms`;\n      const context: LogContext = { operation, duration };\n      \n      switch (level) {\n        case 'debug': logDebug(message, undefined, context); break;\n        case 'info': logInfo(message, undefined, context); break;\n        case 'warn': logWarn(message, undefined, context); break;\n        case 'error': logError(message, undefined, context); break;\n      }\n    },\n  };\n}\n\n/**\n * Timer interface\n */\nexport interface Timer {\n  elapsed: () => number;\n  elapsedSeconds: () => number;\n  log: (operation: string, level?: LogLevel) => void;\n}\n","/**\n * Salesforce Client\n * Creates authenticated connections to Salesforce using SF CLI\n */\n\nimport { Connection } from '@salesforce/core';\nimport { getSfConnection, validateSfAuth, type SfOrgDetails } from './lib/authSalesforceCli.js';\nimport { SF_DEFAULTS } from './types/sfMetadataTypes.js';\nimport { logInfo, logDebug } from './lib/loggerStructured.js';\n\n/**\n * SF connection configuration\n */\nexport interface SfConnectionConfig {\n  /** Org alias or username (uses default org if not provided) */\n  alias?: string;\n  /** API version to use */\n  apiVersion?: string;\n  /** Skip auth validation */\n  skipAuthValidation?: boolean;\n}\n\n/**\n * SF connection wrapper with additional helpers\n */\nexport interface SfConnectionWrapper {\n  /** The underlying jsforce Connection */\n  connection: Connection;\n  /** Org alias */\n  alias: string;\n  /** API version */\n  apiVersion: string;\n  /** Instance URL */\n  instanceUrl: string;\n}\n\n/**\n * Create an authenticated Salesforce connection\n * \n * @param config - Connection configuration\n * @returns SF connection wrapper\n */\nexport async function createSfConnection(\n  config: SfConnectionConfig = {}\n): Promise<SfConnectionWrapper> {\n  const apiVersion = config.apiVersion ?? SF_DEFAULTS.API_VERSION;\n\n  logInfo(`Creating SF connection${config.alias ? ` to ${config.alias}` : ' (using default org)'}`);\n\n  // Validate SF CLI auth (getSfConnection handles default org resolution)\n  if (!config.skipAuthValidation) {\n    await validateSfAuth(config.alias);\n  }\n\n  // Get connection using SF CLI auth (will use default org if alias not specified)\n  const connection = await getSfConnection(config.alias);\n\n  // Set API version if different from default\n  if (apiVersion !== connection.version) {\n    logDebug(`Setting API version to ${apiVersion}`);\n    connection.version = apiVersion;\n  }\n\n  logDebug(`SF connection created: ${connection.instanceUrl}`);\n\n  // Get the actual username from the connection for the wrapper\n  const identity = await connection.identity();\n\n  return {\n    connection,\n    alias: config.alias ?? identity.username,\n    apiVersion: connection.version,\n    instanceUrl: connection.instanceUrl,\n  };\n}\n\n/**\n * Get the jsforce Connection object directly\n * Convenience function for when you need the raw connection\n */\nexport async function getConnection(\n  config?: SfConnectionConfig\n): Promise<Connection> {\n  const wrapper = await createSfConnection(config);\n  return wrapper.connection;\n}\n\n/**\n * Execute a SOQL query\n * Convenience wrapper that creates connection if needed\n */\nexport async function query<T = Record<string, unknown>>(\n  soql: string,\n  config?: SfConnectionConfig\n): Promise<T[]> {\n  const conn = await getConnection(config);\n  const result = await conn.query<T>(soql);\n  return result.records;\n}\n\n/**\n * Execute a Tooling API query\n * Convenience wrapper that creates connection if needed\n */\nexport async function toolingQuery<T = Record<string, unknown>>(\n  soql: string,\n  config?: SfConnectionConfig\n): Promise<T[]> {\n  const conn = await getConnection(config);\n  const result = await conn.tooling.query<T>(soql);\n  return result.records;\n}\n\n/**\n * Get the identity of the authenticated user\n */\nexport async function getIdentity(\n  config?: SfConnectionConfig\n): Promise<SfIdentity> {\n  const conn = await getConnection(config);\n  const identity = await conn.identity();\n  \n  return {\n    userId: identity.user_id,\n    username: identity.username,\n    organizationId: identity.organization_id,\n    displayName: identity.display_name,\n    email: identity.email,\n  };\n}\n\n/**\n * SF identity information\n */\nexport interface SfIdentity {\n  userId: string;\n  username: string;\n  organizationId: string;\n  displayName: string;\n  email: string;\n}\n\n/**\n * Get organization limits\n */\nexport async function getOrgLimits(\n  config?: SfConnectionConfig\n): Promise<Record<string, OrgLimit>> {\n  const conn = await getConnection(config);\n  const limits = await conn.limits();\n  return limits as Record<string, OrgLimit>;\n}\n\n/**\n * Org limit information\n */\nexport interface OrgLimit {\n  Max: number;\n  Remaining: number;\n}\n\n/**\n * Test connection to Salesforce\n */\nexport async function testConnection(\n  config?: SfConnectionConfig\n): Promise<ConnectionTestResult> {\n  try {\n    const start = Date.now();\n    const identity = await getIdentity(config);\n    const duration = Date.now() - start;\n\n    return {\n      success: true,\n      username: identity.username,\n      organizationId: identity.organizationId,\n      responseTimeMs: duration,\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : String(error),\n    };\n  }\n}\n\n/**\n * Connection test result\n */\nexport interface ConnectionTestResult {\n  success: boolean;\n  username?: string;\n  organizationId?: string;\n  responseTimeMs?: number;\n  error?: string;\n}\n","/**\n * Retry with Exponential Backoff\n * Provides resilient API calls with configurable retry logic\n */\n\nimport { logWarn, logError, logDebug } from './loggerStructured.js';\n\n/**\n * Retry options\n */\nexport interface RetryOptions {\n  /** Maximum number of retry attempts (default: 3) */\n  maxRetries?: number;\n  /** Initial delay in milliseconds (default: 1000) */\n  initialDelayMs?: number;\n  /** Maximum delay in milliseconds (default: 30000) */\n  maxDelayMs?: number;\n  /** Backoff multiplier (default: 2) */\n  backoffMultiplier?: number;\n  /** Jitter factor 0-1 to randomize delay (default: 0.1) */\n  jitterFactor?: number;\n  /** Custom function to determine if error is retryable */\n  isRetryable?: (error: unknown) => boolean;\n  /** Callback before each retry attempt */\n  onRetry?: (attempt: number, error: unknown, delayMs: number) => void;\n  /** Operation name for logging */\n  operationName?: string;\n}\n\n/**\n * Default retry options\n */\nconst DEFAULT_OPTIONS: Required<Omit<RetryOptions, 'isRetryable' | 'onRetry' | 'operationName'>> = {\n  maxRetries: 3,\n  initialDelayMs: 1000,\n  maxDelayMs: 30000,\n  backoffMultiplier: 2,\n  jitterFactor: 0.1,\n};\n\n/**\n * Calculate exponential delay with optional jitter\n */\nexport function exponentialDelay(\n  attempt: number,\n  initialDelayMs: number,\n  backoffMultiplier: number,\n  maxDelayMs: number,\n  jitterFactor: number\n): number {\n  // Calculate base delay with exponential backoff\n  const baseDelay = initialDelayMs * Math.pow(backoffMultiplier, attempt - 1);\n  \n  // Cap at max delay\n  const cappedDelay = Math.min(baseDelay, maxDelayMs);\n  \n  // Add jitter\n  const jitter = cappedDelay * jitterFactor * (Math.random() * 2 - 1);\n  \n  return Math.max(0, Math.round(cappedDelay + jitter));\n}\n\n/**\n * Default function to determine if an error is retryable\n */\nfunction defaultIsRetryable(error: unknown): boolean {\n  if (error instanceof Error) {\n    const message = error.message.toLowerCase();\n    const name = error.name.toLowerCase();\n    \n    // Network errors\n    if (message.includes('network') || \n        message.includes('timeout') ||\n        message.includes('econnreset') ||\n        message.includes('econnrefused') ||\n        message.includes('socket hang up')) {\n      return true;\n    }\n    \n    // Rate limiting\n    if (message.includes('rate limit') ||\n        message.includes('too many requests') ||\n        message.includes('429')) {\n      return true;\n    }\n    \n    // Temporary server errors\n    if (message.includes('502') ||\n        message.includes('503') ||\n        message.includes('504') ||\n        message.includes('service unavailable') ||\n        message.includes('internal server error')) {\n      return true;\n    }\n    \n    // Transient errors\n    if (name.includes('transient') ||\n        message.includes('temporarily')) {\n      return true;\n    }\n  }\n  \n  // Check for HTTP status codes on response objects\n  if (typeof error === 'object' && error !== null) {\n    const statusCode = (error as Record<string, unknown>)['statusCode'] ?? \n                       (error as Record<string, unknown>)['status'];\n    if (typeof statusCode === 'number') {\n      // Retry on 429, 502, 503, 504\n      return [429, 502, 503, 504].includes(statusCode);\n    }\n  }\n  \n  return false;\n}\n\n/**\n * Sleep for a specified duration\n */\nfunction sleep(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n/**\n * Execute a function with retry and exponential backoff\n * \n * @param fn - Async function to execute\n * @param options - Retry options\n * @returns Result of the function\n * @throws Last error if all retries fail\n */\nexport async function retryWithBackoff<T>(\n  fn: () => Promise<T>,\n  options: RetryOptions = {}\n): Promise<T> {\n  const {\n    maxRetries = DEFAULT_OPTIONS.maxRetries,\n    initialDelayMs = DEFAULT_OPTIONS.initialDelayMs,\n    maxDelayMs = DEFAULT_OPTIONS.maxDelayMs,\n    backoffMultiplier = DEFAULT_OPTIONS.backoffMultiplier,\n    jitterFactor = DEFAULT_OPTIONS.jitterFactor,\n    isRetryable = defaultIsRetryable,\n    onRetry,\n    operationName = 'operation',\n  } = options;\n\n  let lastError: unknown;\n  \n  for (let attempt = 1; attempt <= maxRetries + 1; attempt++) {\n    try {\n      logDebug(`${operationName}: attempt ${attempt}/${maxRetries + 1}`);\n      return await fn();\n    } catch (error) {\n      lastError = error;\n      \n      // Check if we've exhausted retries\n      if (attempt > maxRetries) {\n        logError(`${operationName}: all ${maxRetries} retries exhausted`, {\n          error: error instanceof Error ? error.message : String(error),\n        });\n        break;\n      }\n      \n      // Check if error is retryable\n      if (!isRetryable(error)) {\n        logError(`${operationName}: non-retryable error`, {\n          error: error instanceof Error ? error.message : String(error),\n        });\n        break;\n      }\n      \n      // Calculate delay\n      const delayMs = exponentialDelay(\n        attempt,\n        initialDelayMs,\n        backoffMultiplier,\n        maxDelayMs,\n        jitterFactor\n      );\n      \n      logWarn(`${operationName}: attempt ${attempt} failed, retrying in ${delayMs}ms`, {\n        error: error instanceof Error ? error.message : String(error),\n        attempt,\n        delayMs,\n      });\n      \n      // Call onRetry callback if provided\n      if (onRetry) {\n        onRetry(attempt, error, delayMs);\n      }\n      \n      // Wait before retrying\n      await sleep(delayMs);\n    }\n  }\n  \n  throw lastError;\n}\n\n/**\n * Create a retry wrapper for a function\n */\nexport function withRetry<T extends unknown[], R>(\n  fn: (...args: T) => Promise<R>,\n  options: RetryOptions = {}\n): (...args: T) => Promise<R> {\n  return (...args: T) => retryWithBackoff(() => fn(...args), options);\n}\n\n/**\n * Retry decorator options for specific error types\n */\nexport const RETRY_PRESETS = {\n  /** Quick retry for transient network issues */\n  quick: {\n    maxRetries: 2,\n    initialDelayMs: 500,\n    maxDelayMs: 2000,\n    backoffMultiplier: 2,\n  } satisfies RetryOptions,\n  \n  /** Standard retry for API calls */\n  standard: {\n    maxRetries: 3,\n    initialDelayMs: 1000,\n    maxDelayMs: 10000,\n    backoffMultiplier: 2,\n  } satisfies RetryOptions,\n  \n  /** Aggressive retry for critical operations */\n  aggressive: {\n    maxRetries: 5,\n    initialDelayMs: 1000,\n    maxDelayMs: 60000,\n    backoffMultiplier: 2,\n  } satisfies RetryOptions,\n  \n  /** Rate limit specific retry (longer delays) */\n  rateLimit: {\n    maxRetries: 3,\n    initialDelayMs: 5000,\n    maxDelayMs: 60000,\n    backoffMultiplier: 3,\n  } satisfies RetryOptions,\n} as const;\n","/**\n * Validation Schemas\n * Zod schemas for runtime validation of inputs\n */\n\nimport { z } from 'zod';\n\n// ============================================\n// Azure DevOps Schemas\n// ============================================\n\n/**\n * Work Class Type enum\n */\nexport const WorkClassTypeSchema = z.enum([\n  'Critical/Escalation',\n  'Development',\n  'Fixed Date Delivery',\n  'Maintenance/Recurring Tasks',\n  'Standard',\n]);\n\n/**\n * Requires QA enum\n */\nexport const RequiresQASchema = z.enum(['Yes', 'No']);\n\n/**\n * Priority enum\n */\nexport const PrioritySchema = z.union([\n  z.literal(1),\n  z.literal(2),\n  z.literal(3),\n  z.literal(4),\n]);\n\n/**\n * Work item type enum\n */\nexport const WorkItemTypeSchema = z.enum([\n  'User Story',\n  'Task',\n  'Bug',\n  'Feature',\n  'Epic',\n  'Issue',\n  'Test Case',\n  'Test Plan',\n  'Test Suite',\n]);\n\n/**\n * Link type alias enum\n */\nexport const LinkTypeAliasSchema = z.enum([\n  'parent',\n  'child',\n  'related',\n  'predecessor',\n  'successor',\n  'duplicate',\n  'affects',\n]);\n\n/**\n * Work item fields schema (partial - only commonly used fields)\n */\nexport const WorkItemFieldsSchema = z.object({\n  // System fields\n  'System.Title': z.string().optional(),\n  'System.Description': z.string().optional(),\n  'System.State': z.string().optional(),\n  'System.AreaPath': z.string().optional(),\n  'System.IterationPath': z.string().optional(),\n  'System.AssignedTo': z.string().optional(),\n  'System.Tags': z.string().optional(),\n  // Microsoft VSTS Common fields\n  'Microsoft.VSTS.Scheduling.StoryPoints': z.number().optional(),\n  'Microsoft.VSTS.Common.Priority': PrioritySchema.optional(),\n  'Microsoft.VSTS.Common.AcceptanceCriteria': z.string().optional(),\n  // Microsoft VSTS TCM fields (Bug-specific)\n  'Microsoft.VSTS.TCM.ReproSteps': z.string().optional(),\n  'Microsoft.VSTS.TCM.SystemInfo': z.string().optional(),\n  // Custom fields\n  'Custom.WorkClassType': WorkClassTypeSchema.optional(),\n  'Custom.RequiresQA': RequiresQASchema.optional(),\n  'Custom.SFComponents': z.string().optional(),\n  'Custom.TechnicalNotes': z.string().optional(),\n  'Custom.RootCauseDetail': z.string().optional(),\n}).passthrough(); // Allow additional fields\n\n/**\n * Get work item options schema\n */\nexport const GetWorkItemOptionsSchema = z.object({\n  expand: z.enum(['None', 'Relations', 'Fields', 'Links', 'All']).optional(),\n  includeComments: z.boolean().optional(),\n  fields: z.array(z.string()).optional(),\n});\n\n/**\n * Create work item options schema\n */\nexport const CreateWorkItemOptionsSchema = z.object({\n  type: WorkItemTypeSchema,\n  title: z.string().min(1),\n  description: z.string().optional(),\n  parentId: z.number().positive().optional(),\n  areaPath: z.string().optional(),\n  iterationPath: z.string().optional(),\n  assignedTo: z.string().optional(),\n  tags: z.array(z.string()).optional(),\n  additionalFields: WorkItemFieldsSchema.optional(),\n});\n\n/**\n * Update work item options schema\n */\nexport const UpdateWorkItemOptionsSchema = z.object({\n  fields: WorkItemFieldsSchema.optional(),\n  comment: z.string().optional(),\n});\n\n/**\n * Search work items options schema\n */\nexport const SearchWorkItemsOptionsSchema = z.object({\n  searchText: z.string().optional(),\n  wiql: z.string().optional(),\n  workItemType: WorkItemTypeSchema.optional(),\n  state: z.string().optional(),\n  assignedTo: z.string().optional(),\n  areaPath: z.string().optional(),\n  iterationPath: z.string().optional(),\n  tags: z.array(z.string()).optional(),\n  top: z.number().positive().optional(),\n});\n\n/**\n * Link work items options schema\n */\nexport const LinkWorkItemsOptionsSchema = z.object({\n  sourceId: z.number().positive(),\n  targetId: z.number().positive(),\n  linkType: LinkTypeAliasSchema,\n  comment: z.string().optional(),\n});\n\n// ============================================\n// Salesforce Schemas\n// ============================================\n\n/**\n * Query options schema\n */\nexport const QueryOptionsSchema = z.object({\n  query: z.string().min(1),\n  useToolingApi: z.boolean().optional(),\n  allRows: z.boolean().optional(),\n  maxRecords: z.number().positive().optional(),\n});\n\n/**\n * Dependency discovery options schema\n */\nexport const MetadataTypeSchema = z.enum([\n  'CustomObject',\n  'CustomField',\n  'ApexClass',\n  'ApexTrigger',\n  'ApexPage',\n  'ApexComponent',\n  'AuraDefinitionBundle',\n  'LightningComponentBundle',\n  'Flow',\n  'FlowDefinition',\n  'ValidationRule',\n  'WorkflowRule',\n  'WorkflowFieldUpdate',\n  'WorkflowAlert',\n  'ProcessBuilder',\n  'CustomMetadataType',\n  'CustomSetting',\n  'CustomLabel',\n  'Layout',\n  'RecordType',\n  'FieldSet',\n  'CompactLayout',\n  'ListView',\n  'Report',\n  'Dashboard',\n  'PermissionSet',\n  'Profile',\n  'Unknown',\n]);\n\nexport const DiscoverDependenciesOptionsSchema = z.object({\n  rootType: MetadataTypeSchema,\n  rootName: z.string().min(1),\n  maxDepth: z.number().positive().optional(),\n  includeStandardObjects: z.boolean().optional(),\n  includeNamespaced: z.boolean().optional(),\n  excludeTypes: z.array(MetadataTypeSchema).optional(),\n  parallelQueries: z.number().positive().optional(),\n});\n\n// ============================================\n// Workflow Schemas\n// ============================================\n\n/**\n * Workflow status schema\n */\nexport const WorkflowStatusSchema = z.enum([\n  'pending',\n  'in_progress',\n  'paused',\n  'completed',\n  'failed',\n  'cancelled',\n]);\n\n/**\n * Workflow execution options schema\n */\nexport const WorkflowExecutionOptionsSchema = z.object({\n  workItemId: z.number().positive(),\n  phases: z.array(z.string()).optional(),\n  steps: z.array(z.string()).optional(),\n  dryRun: z.boolean().optional(),\n  verbose: z.boolean().optional(),\n  continueOnError: z.boolean().optional(),\n});\n\n// ============================================\n// Validation Helpers\n// ============================================\n\n/**\n * Validate data against a schema and return typed result\n */\nexport function validate<T>(schema: z.ZodSchema<T>, data: unknown): T {\n  return schema.parse(data);\n}\n\n/**\n * Safely validate data, returning result or undefined\n */\nexport function safeValidate<T>(schema: z.ZodSchema<T>, data: unknown): T | undefined {\n  const result = schema.safeParse(data);\n  return result.success ? result.data : undefined;\n}\n\n/**\n * Get validation errors as a formatted string\n */\nexport function getValidationErrors(schema: z.ZodSchema, data: unknown): string[] {\n  const result = schema.safeParse(data);\n  if (result.success) {\n    return [];\n  }\n  return result.error.errors.map(e => `${e.path.join('.')}: ${e.message}`);\n}\n","/**\n * Salesforce Query Executor\n * Executes SOQL and Tooling API queries\n */\n\nimport { createSfConnection, type SfConnectionConfig } from './sfClient.js';\nimport { retryWithBackoff, RETRY_PRESETS } from './lib/retryWithBackoff.js';\nimport { logInfo, logDebug, logError, createTimer } from './lib/loggerStructured.js';\nimport { validate, QueryOptionsSchema } from './lib/validationSchemas.js';\nimport type {\n  QueryResult,\n  ToolingQueryResult,\n  QueryOptions,\n  QueryExecutionResult,\n  BatchQueryRequest,\n  BatchQueryResult,\n} from './types/sfQueryTypes.js';\n\n/**\n * Execute a SOQL query\n * \n * @param query - SOQL query string\n * @param config - Connection config\n * @returns Query result with records\n */\nexport async function executeSoqlQuery<T = Record<string, unknown>>(\n  query: string,\n  config?: SfConnectionConfig\n): Promise<QueryResult<T>> {\n  const timer = createTimer();\n  \n  logInfo('Executing SOQL query');\n  logDebug('Query', { query });\n\n  const { connection } = await createSfConnection(config);\n\n  const result = await retryWithBackoff(\n    async () => {\n      const queryResult = await connection.query<T>(query);\n      return {\n        done: queryResult.done,\n        totalSize: queryResult.totalSize,\n        records: queryResult.records,\n        nextRecordsUrl: queryResult.nextRecordsUrl,\n      };\n    },\n    { ...RETRY_PRESETS.standard, operationName: 'executeSoqlQuery' }\n  );\n\n  logInfo(`Query returned ${result.totalSize} records`);\n  timer.log('executeSoqlQuery');\n  \n  return result;\n}\n\n/**\n * Execute a Tooling API query\n * \n * @param query - SOQL query string for Tooling API\n * @param config - Connection config\n * @returns Query result with records\n */\nexport async function executeToolingQuery<T = Record<string, unknown>>(\n  query: string,\n  config?: SfConnectionConfig\n): Promise<ToolingQueryResult<T>> {\n  const timer = createTimer();\n  \n  logInfo('Executing Tooling API query');\n  logDebug('Query', { query });\n\n  const { connection } = await createSfConnection(config);\n\n  const result = await retryWithBackoff(\n    async () => {\n      const queryResult = await connection.tooling.query<T>(query);\n      return {\n        done: queryResult.done,\n        totalSize: queryResult.totalSize,\n        records: queryResult.records,\n        nextRecordsUrl: queryResult.nextRecordsUrl,\n        entityTypeName: queryResult.entityTypeName,\n      };\n    },\n    { ...RETRY_PRESETS.standard, operationName: 'executeToolingQuery' }\n  );\n\n  logInfo(`Tooling query returned ${result.totalSize} records`);\n  timer.log('executeToolingQuery');\n  \n  return result;\n}\n\n/**\n * Execute a query with full options\n * \n * @param options - Query options\n * @param config - Connection config\n * @returns Query execution result with metadata\n */\nexport async function executeQuery<T = Record<string, unknown>>(\n  options: QueryOptions,\n  config?: SfConnectionConfig\n): Promise<QueryExecutionResult<T>> {\n  const timer = createTimer();\n  const validatedOptions = validate(QueryOptionsSchema, options);\n\n  logInfo('Executing query', { useToolingApi: validatedOptions.useToolingApi });\n\n  try {\n    let result: QueryResult<T>;\n\n    if (validatedOptions.useToolingApi) {\n      result = await executeToolingQuery<T>(validatedOptions.query, config);\n    } else {\n      result = await executeSoqlQuery<T>(validatedOptions.query, config);\n    }\n\n    // Limit records if maxRecords is specified\n    if (validatedOptions.maxRecords && result.records.length > validatedOptions.maxRecords) {\n      result.records = result.records.slice(0, validatedOptions.maxRecords);\n    }\n\n    return {\n      success: true,\n      data: result,\n      executionTime: timer.elapsed(),\n    };\n  } catch (error) {\n    logError('Query execution failed', { \n      error: error instanceof Error ? error.message : String(error) \n    });\n\n    return {\n      success: false,\n      data: { done: true, totalSize: 0, records: [] },\n      error: error instanceof Error ? error.message : String(error),\n      executionTime: timer.elapsed(),\n    };\n  }\n}\n\n/**\n * Execute multiple queries in batch\n * \n * @param request - Batch query request\n * @param config - Connection config\n * @returns Batch query results\n */\nexport async function executeBatchQueries(\n  request: BatchQueryRequest,\n  config?: SfConnectionConfig\n): Promise<BatchQueryResult> {\n  const timer = createTimer();\n  \n  logInfo(`Executing batch of ${request.queries.length} queries`);\n\n  const results: Record<string, QueryExecutionResult> = {};\n  const errors: Array<{ name: string; error: string }> = [];\n\n  // Execute queries in parallel with concurrency limit\n  const CONCURRENCY = 5;\n  const queries = [...request.queries];\n  \n  while (queries.length > 0) {\n    const batch = queries.splice(0, CONCURRENCY);\n    \n    await Promise.all(\n      batch.map(async (queryDef) => {\n        try {\n          const result = await executeQuery(\n            {\n              query: queryDef.query,\n              useToolingApi: queryDef.useToolingApi,\n            },\n            config\n          );\n          results[queryDef.name] = result;\n        } catch (error) {\n          const errorMsg = error instanceof Error ? error.message : String(error);\n          errors.push({ name: queryDef.name, error: errorMsg });\n          results[queryDef.name] = {\n            success: false,\n            data: { done: true, totalSize: 0, records: [] },\n            error: errorMsg,\n          };\n        }\n      })\n    );\n  }\n\n  const totalTime = timer.elapsed();\n  logInfo(`Batch execution completed in ${totalTime}ms`, {\n    successful: Object.values(results).filter(r => r.success).length,\n    failed: errors.length,\n  });\n\n  return {\n    results,\n    totalExecutionTime: totalTime,\n    errors,\n  };\n}\n\n/**\n * Execute a query and get all records (handles pagination)\n * \n * @param query - SOQL query string\n * @param config - Connection config\n * @returns All records from query\n */\nexport async function queryAll<T = Record<string, unknown>>(\n  query: string,\n  config?: SfConnectionConfig\n): Promise<T[]> {\n  const timer = createTimer();\n  \n  logInfo('Executing queryAll');\n  logDebug('Query', { query });\n\n  const { connection } = await createSfConnection(config);\n\n  const allRecords: T[] = [];\n  \n  const result = await retryWithBackoff(\n    () => connection.query<T>(query),\n    { ...RETRY_PRESETS.standard, operationName: 'queryAll-initial' }\n  );\n\n  allRecords.push(...result.records);\n\n  // Fetch additional records if there are more\n  let nextRecordsUrl = result.nextRecordsUrl;\n  while (nextRecordsUrl) {\n    logDebug(`Fetching more records from ${nextRecordsUrl}`);\n    \n    const moreResult = await retryWithBackoff(\n      () => connection.queryMore<T>(nextRecordsUrl as string),\n      { ...RETRY_PRESETS.standard, operationName: 'queryAll-more' }\n    );\n\n    allRecords.push(...moreResult.records);\n    nextRecordsUrl = moreResult.nextRecordsUrl;\n  }\n\n  logInfo(`queryAll returned ${allRecords.length} total records`);\n  timer.log('queryAll');\n\n  return allRecords;\n}\n\n/**\n * Count records matching a query\n * \n * @param objectName - SObject name\n * @param whereClause - Optional WHERE clause (without WHERE keyword)\n * @param config - Connection config\n * @returns Record count\n */\nexport async function countRecords(\n  objectName: string,\n  whereClause?: string,\n  config?: SfConnectionConfig\n): Promise<number> {\n  const query = whereClause\n    ? `SELECT COUNT() FROM ${objectName} WHERE ${whereClause}`\n    : `SELECT COUNT() FROM ${objectName}`;\n\n  const result = await executeSoqlQuery<{ expr0: number }>(query, config);\n  return result.totalSize;\n}\n\n/**\n * Check if any records exist matching criteria\n * \n * @param objectName - SObject name\n * @param whereClause - WHERE clause (without WHERE keyword)\n * @param config - Connection config\n * @returns True if records exist\n */\nexport async function recordsExist(\n  objectName: string,\n  whereClause: string,\n  config?: SfConnectionConfig\n): Promise<boolean> {\n  const query = `SELECT Id FROM ${objectName} WHERE ${whereClause} LIMIT 1`;\n  const result = await executeSoqlQuery(query, config);\n  return result.totalSize > 0;\n}\n","/**\n * Salesforce Metadata Describer\n * Describes objects, fields, and metadata\n */\n\nimport { createSfConnection, type SfConnectionConfig } from './sfClient.js';\nimport { executeToolingQuery } from './sfQueryExecutor.js';\nimport { retryWithBackoff, RETRY_PRESETS } from './lib/retryWithBackoff.js';\nimport { logInfo, logDebug, createTimer } from './lib/loggerStructured.js';\nimport type {\n  DescribeSObjectResult,\n  DescribeFieldResult,\n  EntityDefinition,\n  FieldDefinition,\n  ApexClass,\n  ApexTrigger,\n  ValidationRule,\n  Flow,\n} from './types/sfMetadataTypes.js';\n\n/**\n * Describe an SObject\n * \n * @param objectName - API name of the object\n * @param config - Connection config\n * @returns Object describe result\n */\nexport async function describeObject(\n  objectName: string,\n  config?: SfConnectionConfig\n): Promise<DescribeSObjectResult> {\n  const timer = createTimer();\n  \n  logInfo(`Describing object: ${objectName}`);\n\n  const { connection } = await createSfConnection(config);\n\n  const result = await retryWithBackoff(\n    () => connection.describe(objectName),\n    { ...RETRY_PRESETS.standard, operationName: `describeObject(${objectName})` }\n  );\n\n  // Convert to our type\n  const describe: DescribeSObjectResult = {\n    name: result.name,\n    label: result.label,\n    labelPlural: result.labelPlural,\n    keyPrefix: result.keyPrefix ?? '',\n    custom: result.custom,\n    customSetting: result.customSetting,\n    createable: result.createable,\n    updateable: result.updateable,\n    deletable: result.deletable,\n    queryable: result.queryable,\n    searchable: result.searchable,\n    layoutable: result.layoutable,\n    triggerable: result.triggerable,\n    fields: result.fields.map(f => ({\n      name: f.name,\n      label: f.label,\n      type: f.type,\n      length: f.length,\n      precision: f.precision,\n      scale: f.scale,\n      nillable: f.nillable,\n      unique: f.unique,\n      createable: f.createable,\n      updateable: f.updateable,\n      filterable: f.filterable,\n      sortable: f.sortable,\n      groupable: f.groupable,\n      custom: f.custom,\n      calculated: f.calculated,\n      defaultValue: f.defaultValue,\n      inlineHelpText: f.inlineHelpText ?? undefined,\n      picklistValues: f.picklistValues?.map(p => ({\n        value: p.value,\n        label: p.label,\n        active: p.active,\n        defaultValue: p.defaultValue,\n      })),\n      referenceTo: f.referenceTo,\n      relationshipName: f.relationshipName ?? undefined,\n    })),\n    recordTypeInfos: result.recordTypeInfos?.map(rt => ({\n      recordTypeId: rt.recordTypeId ?? '',\n      name: rt.name,\n      developerName: rt.developerName ?? '',\n      available: rt.available,\n      master: rt.master,\n      defaultRecordTypeMapping: rt.defaultRecordTypeMapping,\n    })),\n    childRelationships: result.childRelationships?.map(cr => ({\n      childSObject: cr.childSObject,\n      field: cr.field,\n      relationshipName: cr.relationshipName ?? '',\n      cascadeDelete: cr.cascadeDelete,\n      deprecatedAndHidden: cr.deprecatedAndHidden,\n      restrictedDelete: cr.restrictedDelete,\n    })),\n  };\n\n  logInfo(`Described ${objectName}: ${describe.fields.length} fields`);\n  timer.log(`describeObject(${objectName})`);\n\n  return describe;\n}\n\n/**\n * Describe a specific field\n * \n * @param objectName - Object API name\n * @param fieldName - Field API name\n * @param config - Connection config\n * @returns Field describe result\n */\nexport async function describeField(\n  objectName: string,\n  fieldName: string,\n  config?: SfConnectionConfig\n): Promise<DescribeFieldResult> {\n  const timer = createTimer();\n  \n  logInfo(`Describing field: ${objectName}.${fieldName}`);\n\n  const objectDescribe = await describeObject(objectName, config);\n  \n  const field = objectDescribe.fields.find(\n    f => f.name.toLowerCase() === fieldName.toLowerCase()\n  );\n\n  if (!field) {\n    throw new Error(`Field ${fieldName} not found on ${objectName}`);\n  }\n\n  timer.log(`describeField(${objectName}.${fieldName})`);\n  return field;\n}\n\n/**\n * Get entity definition from Tooling API\n * \n * @param objectName - Object API name\n * @param config - Connection config\n * @returns Entity definition\n */\nexport async function getEntityDefinition(\n  objectName: string,\n  config?: SfConnectionConfig\n): Promise<EntityDefinition | undefined> {\n  const timer = createTimer();\n  \n  logInfo(`Getting entity definition: ${objectName}`);\n\n  const query = `\n    SELECT Id, DurableId, QualifiedApiName, NamespacePrefix, DeveloperName,\n           MasterLabel, Label, PluralLabel, KeyPrefix, IsCustomSetting,\n           IsCustomizable, IsApexTriggerable, IsWorkflowEnabled, IsProcessEnabled,\n           IsLayoutable, IsCompactLayoutable, DeploymentStatus, IsSearchable,\n           IsQueryable, IsIdEnabled, IsReplicateable, IsRetrieveable,\n           IsCreateable, IsUpdateable, IsDeletable, IsUndeletable, IsMergeable,\n           InternalSharingModel, ExternalSharingModel, PublisherId\n    FROM EntityDefinition\n    WHERE QualifiedApiName = '${objectName}'\n  `;\n\n  const result = await executeToolingQuery<EntityDefinition>(query, config);\n  \n  timer.log(`getEntityDefinition(${objectName})`);\n  return result.records[0];\n}\n\n/**\n * Get field definitions for an object from Tooling API\n * \n * @param objectName - Object API name\n * @param config - Connection config\n * @returns Array of field definitions\n */\nexport async function getFieldDefinitions(\n  objectName: string,\n  config?: SfConnectionConfig\n): Promise<FieldDefinition[]> {\n  const timer = createTimer();\n  \n  logInfo(`Getting field definitions for: ${objectName}`);\n\n  // First get the EntityDefinition to get its DurableId\n  const entity = await getEntityDefinition(objectName, config);\n  if (!entity) {\n    throw new Error(`Entity ${objectName} not found`);\n  }\n\n  const query = `\n    SELECT Id, DurableId, QualifiedApiName, EntityDefinitionId, NamespacePrefix,\n           DeveloperName, MasterLabel, Label, Length, DataType, ValueTypeId,\n           ReferenceTo, ReferenceTargetField, IsCompound, IsHighScaleNumber,\n           IsHtmlFormatted, IsNameField, IsNillable, IsCalculated,\n           IsApiFilterable, IsApiSortable, IsApiGroupable, IsPolymorphicForeignKey,\n           IsCompactLayoutable, Precision, Scale, IsFieldHistoryTracked,\n           IsIndexed, IsUnique, IsDeprecatedAndHidden, Description,\n           InlineHelpText, RelationshipName, LastModifiedDate, PublisherId\n    FROM FieldDefinition\n    WHERE EntityDefinitionId = '${entity.DurableId}'\n  `;\n\n  const result = await executeToolingQuery<FieldDefinition>(query, config);\n  \n  logInfo(`Got ${result.records.length} field definitions for ${objectName}`);\n  timer.log(`getFieldDefinitions(${objectName})`);\n  \n  return result.records;\n}\n\n/**\n * Get Apex classes\n * \n * @param namePattern - Optional name pattern (use % for wildcard)\n * @param config - Connection config\n * @returns Array of Apex classes\n */\nexport async function getApexClasses(\n  namePattern?: string,\n  config?: SfConnectionConfig\n): Promise<ApexClass[]> {\n  const timer = createTimer();\n  \n  logInfo('Getting Apex classes', { namePattern });\n\n  let query = `\n    SELECT Id, Name, NamespacePrefix, ApiVersion, Status, IsValid, LengthWithoutComments\n    FROM ApexClass\n  `;\n\n  if (namePattern) {\n    query += ` WHERE Name LIKE '${namePattern}'`;\n  }\n\n  query += ' ORDER BY Name';\n\n  const result = await executeToolingQuery<ApexClass>(query, config);\n  \n  logInfo(`Got ${result.records.length} Apex classes`);\n  timer.log('getApexClasses');\n  \n  return result.records;\n}\n\n/**\n * Get Apex triggers for an object\n * \n * @param objectName - Object API name (optional)\n * @param config - Connection config\n * @returns Array of Apex triggers\n */\nexport async function getApexTriggers(\n  objectName?: string,\n  config?: SfConnectionConfig\n): Promise<ApexTrigger[]> {\n  const timer = createTimer();\n  \n  logInfo('Getting Apex triggers', { objectName });\n\n  let query = `\n    SELECT Id, Name, NamespacePrefix, TableEnumOrId, ApiVersion, Status, IsValid,\n           LengthWithoutComments, UsageBeforeInsert, UsageAfterInsert,\n           UsageBeforeUpdate, UsageAfterUpdate, UsageBeforeDelete,\n           UsageAfterDelete, UsageAfterUndelete, UsageIsBulk\n    FROM ApexTrigger\n  `;\n\n  if (objectName) {\n    query += ` WHERE TableEnumOrId = '${objectName}'`;\n  }\n\n  query += ' ORDER BY Name';\n\n  const result = await executeToolingQuery<ApexTrigger>(query, config);\n  \n  logInfo(`Got ${result.records.length} Apex triggers`);\n  timer.log('getApexTriggers');\n  \n  return result.records;\n}\n\n/**\n * Get validation rules for an object\n * \n * @param objectName - Object API name\n * @param activeOnly - Only return active rules\n * @param config - Connection config\n * @returns Array of validation rules\n */\nexport async function getValidationRules(\n  objectName: string,\n  activeOnly = true,\n  config?: SfConnectionConfig\n): Promise<ValidationRule[]> {\n  const timer = createTimer();\n  \n  logInfo(`Getting validation rules for: ${objectName}`);\n\n  // Get entity definition first\n  const entity = await getEntityDefinition(objectName, config);\n  if (!entity) {\n    throw new Error(`Entity ${objectName} not found`);\n  }\n\n  let query = `\n    SELECT Id, ValidationName, EntityDefinitionId, Active, Description,\n           ErrorDisplayField, ErrorMessage, FullName, Metadata\n    FROM ValidationRule\n    WHERE EntityDefinitionId = '${entity.DurableId}'\n  `;\n\n  if (activeOnly) {\n    query += ' AND Active = true';\n  }\n\n  const result = await executeToolingQuery<ValidationRule>(query, config);\n  \n  logInfo(`Got ${result.records.length} validation rules for ${objectName}`);\n  timer.log(`getValidationRules(${objectName})`);\n  \n  return result.records;\n}\n\n/**\n * Get flows related to an object\n * \n * @param objectName - Object API name (optional)\n * @param activeOnly - Only return active flows\n * @param config - Connection config\n * @returns Array of flows\n */\nexport async function getFlows(\n  objectName?: string,\n  activeOnly = true,\n  config?: SfConnectionConfig\n): Promise<Flow[]> {\n  const timer = createTimer();\n  \n  logInfo('Getting flows', { objectName, activeOnly });\n\n  let query = `\n    SELECT Id, DeveloperName, MasterLabel, NamespacePrefix, ApiVersion,\n           ProcessType, Status, Description, TriggerType, TriggerObjectOrEvent,\n           RecordTriggerType, IsActive, IsTemplate, RunInMode,\n           LastModifiedDate, LastModifiedById\n    FROM Flow\n  `;\n\n  const conditions: string[] = [];\n\n  if (objectName) {\n    conditions.push(`TriggerObjectOrEvent = '${objectName}'`);\n  }\n\n  if (activeOnly) {\n    conditions.push('IsActive = true');\n  }\n\n  if (conditions.length > 0) {\n    query += ` WHERE ${conditions.join(' AND ')}`;\n  }\n\n  query += ' ORDER BY MasterLabel';\n\n  const result = await executeToolingQuery<Flow>(query, config);\n  \n  logInfo(`Got ${result.records.length} flows`);\n  timer.log('getFlows');\n  \n  return result.records;\n}\n\n/**\n * Get all custom objects\n * \n * @param config - Connection config\n * @returns Array of custom object names\n */\nexport async function getCustomObjects(\n  config?: SfConnectionConfig\n): Promise<string[]> {\n  const timer = createTimer();\n  \n  logInfo('Getting custom objects');\n\n  const query = `\n    SELECT QualifiedApiName\n    FROM EntityDefinition\n    WHERE IsCustomizable = true AND IsCustomSetting = false\n    ORDER BY QualifiedApiName\n  `;\n\n  const result = await executeToolingQuery<{ QualifiedApiName: string }>(query, config);\n  \n  const customObjects = result.records\n    .map(r => r.QualifiedApiName)\n    .filter(name => name.endsWith('__c'));\n\n  logInfo(`Got ${customObjects.length} custom objects`);\n  timer.log('getCustomObjects');\n  \n  return customObjects;\n}\n","/**\n * Salesforce Dependency Traverser\n * Traverses and analyzes dependency graphs\n */\n\nimport { logDebug, logWarn } from './lib/loggerStructured.js';\nimport type {\n  DependencyNode,\n  DependencyEdge,\n  DependencyGraph,\n  TraversalOptions,\n  CycleDetectionResult,\n} from './types/sfDependencyTypes.js';\n\n/**\n * Traverse dependencies using depth-first search\n * \n * @param graph - Dependency graph to traverse\n * @param options - Traversal options\n * @returns Visited nodes in order\n */\nexport function traverseDependencies(\n  graph: DependencyGraph,\n  options: TraversalOptions\n): DependencyNode[] {\n  const visited = new Set<string>();\n  const result: DependencyNode[] = [];\n  const stack: string[] = [];\n\n  function dfs(nodeId: string, depth: number): void {\n    if (depth > options.maxDepth) {\n      return;\n    }\n\n    if (visited.has(nodeId)) {\n      if (options.detectCycles && stack.includes(nodeId)) {\n        const cycleStart = stack.indexOf(nodeId);\n        const cyclePath = [...stack.slice(cycleStart), nodeId];\n        \n        logWarn('Cycle detected', { path: cyclePath });\n        \n        if (options.onCycleDetected) {\n          options.onCycleDetected(cyclePath);\n        }\n      }\n      return;\n    }\n\n    visited.add(nodeId);\n    stack.push(nodeId);\n\n    const node = graph.nodes.get(nodeId);\n    if (node) {\n      result.push(node);\n      \n      if (options.onNodeVisit) {\n        options.onNodeVisit(node);\n      }\n\n      // Find outgoing edges\n      const outgoingEdges = graph.edges.filter(e => e.sourceId === nodeId);\n      \n      for (const edge of outgoingEdges) {\n        dfs(edge.targetId, depth + 1);\n      }\n    }\n\n    stack.pop();\n  }\n\n  dfs(graph.rootId, 0);\n  return result;\n}\n\n/**\n * Detect cycles in the dependency graph\n * \n * @param nodes - Map of nodes\n * @param edges - Array of edges\n * @param startNodeId - Starting node ID\n * @returns Cycle detection result\n */\nexport function detectCycles(\n  nodes: Map<string, DependencyNode>,\n  edges: DependencyEdge[],\n  startNodeId: string\n): CycleDetectionResult {\n  const visited = new Set<string>();\n  const recursionStack = new Set<string>();\n  const cycles: string[][] = [];\n\n  // Build adjacency list\n  const adjacencyList = new Map<string, string[]>();\n  for (const edge of edges) {\n    if (!adjacencyList.has(edge.sourceId)) {\n      adjacencyList.set(edge.sourceId, []);\n    }\n    adjacencyList.get(edge.sourceId)!.push(edge.targetId);\n  }\n\n  function dfs(nodeId: string, path: string[]): void {\n    visited.add(nodeId);\n    recursionStack.add(nodeId);\n    path.push(nodeId);\n\n    const neighbors = adjacencyList.get(nodeId) ?? [];\n    \n    for (const neighbor of neighbors) {\n      if (!visited.has(neighbor)) {\n        dfs(neighbor, [...path]);\n      } else if (recursionStack.has(neighbor)) {\n        // Cycle found\n        const cycleStart = path.indexOf(neighbor);\n        if (cycleStart !== -1) {\n          const cycle = path.slice(cycleStart);\n          cycle.push(neighbor); // Complete the cycle\n          cycles.push(cycle);\n        }\n      }\n    }\n\n    recursionStack.delete(nodeId);\n  }\n\n  // Start DFS from all nodes to catch disconnected components\n  for (const nodeId of nodes.keys()) {\n    if (!visited.has(nodeId)) {\n      dfs(nodeId, []);\n    }\n  }\n\n  return {\n    hasCycles: cycles.length > 0,\n    cycles,\n    visitedNodes: visited,\n  };\n}\n\n/**\n * Get all nodes at a specific depth\n * \n * @param graph - Dependency graph\n * @param depth - Target depth\n * @returns Nodes at the specified depth\n */\nexport function getNodesAtDepth(\n  graph: DependencyGraph,\n  depth: number\n): DependencyNode[] {\n  return Array.from(graph.nodes.values()).filter(n => n.depth === depth);\n}\n\n/**\n * Get all leaf nodes (nodes with no outgoing edges)\n * \n * @param graph - Dependency graph\n * @returns Leaf nodes\n */\nexport function getLeafNodes(graph: DependencyGraph): DependencyNode[] {\n  const nodesWithOutgoing = new Set(graph.edges.map(e => e.sourceId));\n  \n  return Array.from(graph.nodes.values()).filter(\n    n => !nodesWithOutgoing.has(n.id)\n  );\n}\n\n/**\n * Get all root nodes (nodes with no incoming edges)\n * \n * @param graph - Dependency graph\n * @returns Root nodes\n */\nexport function getRootNodes(graph: DependencyGraph): DependencyNode[] {\n  const nodesWithIncoming = new Set(graph.edges.map(e => e.targetId));\n  \n  return Array.from(graph.nodes.values()).filter(\n    n => !nodesWithIncoming.has(n.id)\n  );\n}\n\n/**\n * Get the path from root to a specific node\n * \n * @param graph - Dependency graph\n * @param targetNodeId - Target node ID\n * @returns Path of node IDs from root to target\n */\nexport function getPathToNode(\n  graph: DependencyGraph,\n  targetNodeId: string\n): string[] | null {\n  const visited = new Set<string>();\n  const parent = new Map<string, string>();\n\n  function bfs(): boolean {\n    const queue: string[] = [graph.rootId];\n    visited.add(graph.rootId);\n\n    while (queue.length > 0) {\n      const current = queue.shift()!;\n      \n      if (current === targetNodeId) {\n        return true;\n      }\n\n      const outgoingEdges = graph.edges.filter(e => e.sourceId === current);\n      \n      for (const edge of outgoingEdges) {\n        if (!visited.has(edge.targetId)) {\n          visited.add(edge.targetId);\n          parent.set(edge.targetId, current);\n          queue.push(edge.targetId);\n        }\n      }\n    }\n\n    return false;\n  }\n\n  if (!bfs()) {\n    return null;\n  }\n\n  // Reconstruct path\n  const path: string[] = [];\n  let current: string | undefined = targetNodeId;\n  \n  while (current !== undefined) {\n    path.unshift(current);\n    current = parent.get(current);\n  }\n\n  return path;\n}\n\n/**\n * Get all dependencies of a node (direct and transitive)\n * \n * @param graph - Dependency graph\n * @param nodeId - Node ID\n * @returns Set of dependency node IDs\n */\nexport function getAllDependencies(\n  graph: DependencyGraph,\n  nodeId: string\n): Set<string> {\n  const dependencies = new Set<string>();\n  const visited = new Set<string>();\n\n  function collect(currentId: string): void {\n    if (visited.has(currentId)) return;\n    visited.add(currentId);\n\n    const outgoingEdges = graph.edges.filter(e => e.sourceId === currentId);\n    \n    for (const edge of outgoingEdges) {\n      dependencies.add(edge.targetId);\n      collect(edge.targetId);\n    }\n  }\n\n  collect(nodeId);\n  return dependencies;\n}\n\n/**\n * Get all dependents of a node (nodes that depend on this node)\n * \n * @param graph - Dependency graph\n * @param nodeId - Node ID\n * @returns Set of dependent node IDs\n */\nexport function getAllDependents(\n  graph: DependencyGraph,\n  nodeId: string\n): Set<string> {\n  const dependents = new Set<string>();\n  const visited = new Set<string>();\n\n  function collect(currentId: string): void {\n    if (visited.has(currentId)) return;\n    visited.add(currentId);\n\n    const incomingEdges = graph.edges.filter(e => e.targetId === currentId);\n    \n    for (const edge of incomingEdges) {\n      dependents.add(edge.sourceId);\n      collect(edge.sourceId);\n    }\n  }\n\n  collect(nodeId);\n  return dependents;\n}\n\n/**\n * Calculate the impact score for a node\n * Higher score = more components depend on this node\n * \n * @param graph - Dependency graph\n * @param nodeId - Node ID\n * @returns Impact score\n */\nexport function calculateImpactScore(\n  graph: DependencyGraph,\n  nodeId: string\n): number {\n  const dependents = getAllDependents(graph, nodeId);\n  return dependents.size;\n}\n\n/**\n * Sort nodes by impact score (most impactful first)\n * \n * @param graph - Dependency graph\n * @returns Sorted array of nodes with scores\n */\nexport function sortByImpact(\n  graph: DependencyGraph\n): Array<{ node: DependencyNode; score: number }> {\n  const results: Array<{ node: DependencyNode; score: number }> = [];\n\n  for (const node of graph.nodes.values()) {\n    const score = calculateImpactScore(graph, node.id);\n    results.push({ node, score });\n  }\n\n  return results.sort((a, b) => b.score - a.score);\n}\n\n/**\n * Get subgraph for a specific node and its dependencies\n * \n * @param graph - Original dependency graph\n * @param nodeId - Node ID to extract subgraph for\n * @param includeDepth - How many levels of dependencies to include\n * @returns Subgraph\n */\nexport function extractSubgraph(\n  graph: DependencyGraph,\n  nodeId: string,\n  includeDepth: number = Infinity\n): DependencyGraph {\n  const subNodes = new Map<string, DependencyNode>();\n  const subEdges: DependencyEdge[] = [];\n  const visited = new Set<string>();\n\n  function collect(currentId: string, depth: number): void {\n    if (visited.has(currentId) || depth > includeDepth) return;\n    visited.add(currentId);\n\n    const node = graph.nodes.get(currentId);\n    if (node) {\n      subNodes.set(currentId, { ...node, depth });\n    }\n\n    const outgoingEdges = graph.edges.filter(e => e.sourceId === currentId);\n    \n    for (const edge of outgoingEdges) {\n      subEdges.push(edge);\n      collect(edge.targetId, depth + 1);\n    }\n  }\n\n  collect(nodeId, 0);\n\n  return {\n    nodes: subNodes,\n    edges: subEdges,\n    rootId: nodeId,\n    metadata: {\n      ...graph.metadata,\n      rootName: graph.nodes.get(nodeId)?.name ?? nodeId,\n      nodeCount: subNodes.size,\n      edgeCount: subEdges.length,\n    },\n  };\n}\n","/**\n * Salesforce Dependency Enrichment\n * Enriches dependency graphs with usage information and pills\n */\n\nimport { executeToolingQuery } from './sfQueryExecutor.js';\nimport { logInfo, logDebug, createTimer } from './lib/loggerStructured.js';\nimport type { SfConnectionConfig } from './sfClient.js';\nimport type {\n  DependencyGraph,\n  DependencyNode,\n  UsagePill,\n  UsagePillType,\n  UsageSeverity,\n  EnrichmentOptions,\n  EnrichmentResult,\n} from './types/sfDependencyTypes.js';\n\n/**\n * Default enrichment options\n */\nconst DEFAULT_ENRICHMENT_OPTIONS: EnrichmentOptions = {\n  includeApexUsage: true,\n  includeFlowUsage: true,\n  includeValidationUsage: true,\n  includeWorkflowUsage: true,\n  includeFormulaUsage: false,\n  includeLayoutUsage: false,\n  includeReportUsage: false,\n};\n\n/**\n * Enrich a dependency graph with usage pills\n * \n * @param graph - Dependency graph to enrich\n * @param config - Connection config\n * @param options - Enrichment options\n * @returns Array of usage pills\n */\nexport async function enrichWithUsagePills(\n  graph: DependencyGraph,\n  config?: SfConnectionConfig,\n  options: EnrichmentOptions = DEFAULT_ENRICHMENT_OPTIONS\n): Promise<UsagePill[]> {\n  const timer = createTimer();\n  const pills: UsagePill[] = [];\n\n  logInfo('Enriching graph with usage pills');\n\n  // Collect all field and object names for querying\n  const objectNames = new Set<string>();\n  const fieldNames = new Set<string>();\n\n  for (const node of graph.nodes.values()) {\n    if (node.type === 'CustomObject') {\n      objectNames.add(node.apiName);\n    } else if (node.type === 'CustomField') {\n      fieldNames.add(node.apiName);\n    }\n  }\n\n  // Enrich with Apex usage\n  if (options.includeApexUsage && (objectNames.size > 0 || fieldNames.size > 0)) {\n    const apexPills = await analyzeApexUsage(objectNames, fieldNames, config);\n    pills.push(...apexPills);\n  }\n\n  // Enrich with Flow usage\n  if (options.includeFlowUsage && objectNames.size > 0) {\n    const flowPills = await analyzeFlowUsage(objectNames, config);\n    pills.push(...flowPills);\n  }\n\n  // Enrich with Validation Rule usage\n  if (options.includeValidationUsage && fieldNames.size > 0) {\n    const validationPills = await analyzeValidationUsage(fieldNames, config);\n    pills.push(...validationPills);\n  }\n\n  logInfo(`Created ${pills.length} usage pills`);\n  timer.log('enrichWithUsagePills');\n\n  return pills;\n}\n\n/**\n * Analyze Apex code for field/object usage\n */\nasync function analyzeApexUsage(\n  objectNames: Set<string>,\n  fieldNames: Set<string>,\n  config?: SfConnectionConfig\n): Promise<UsagePill[]> {\n  const pills: UsagePill[] = [];\n\n  if (objectNames.size === 0 && fieldNames.size === 0) {\n    return pills;\n  }\n\n  logDebug('Analyzing Apex usage');\n\n  // Query Apex classes that might reference these objects\n  for (const objectName of objectNames) {\n    try {\n      const query = `\n        SELECT Id, Name FROM ApexClass \n        WHERE Status = 'Active'\n        LIMIT 100\n      `;\n      \n      const result = await executeToolingQuery<{ Id: string; Name: string }>(query, config);\n      \n      // For each class, we would ideally parse the body to find references\n      // For now, create a general pill indicating potential Apex usage\n      if (result.records.length > 0) {\n        pills.push(createPill({\n          type: 'apex_usage',\n          label: `${objectName} Apex Usage`,\n          description: `${result.records.length} Apex classes in org may reference this object`,\n          severity: 'info',\n          affectedComponents: result.records.slice(0, 10).map(r => r.Name),\n          recommendation: 'Review Apex classes for direct object references before making schema changes',\n        }));\n      }\n    } catch (error) {\n      logDebug(`Error analyzing Apex for ${objectName}: ${error}`);\n    }\n  }\n\n  return pills;\n}\n\n/**\n * Analyze Flows for object usage\n */\nasync function analyzeFlowUsage(\n  objectNames: Set<string>,\n  config?: SfConnectionConfig\n): Promise<UsagePill[]> {\n  const pills: UsagePill[] = [];\n\n  logDebug('Analyzing Flow usage');\n\n  for (const objectName of objectNames) {\n    try {\n      const query = `\n        SELECT Id, MasterLabel, ProcessType, Status\n        FROM Flow\n        WHERE TriggerObjectOrEvent = '${objectName}'\n        AND IsActive = true\n      `;\n      \n      const result = await executeToolingQuery<{\n        Id: string;\n        MasterLabel: string;\n        ProcessType: string;\n        Status: string;\n      }>(query, config);\n      \n      if (result.records.length > 0) {\n        const severity: UsageSeverity = result.records.length > 3 ? 'warning' : 'info';\n        \n        pills.push(createPill({\n          type: 'flow_usage',\n          label: `${objectName} Flow Usage`,\n          description: `${result.records.length} active Flow(s) trigger on this object`,\n          severity,\n          affectedComponents: result.records.map(r => r.MasterLabel),\n          recommendation: severity === 'warning' \n            ? 'Multiple flows may cause performance issues or conflicts'\n            : 'Review flows before making changes to this object',\n        }));\n      }\n    } catch (error) {\n      logDebug(`Error analyzing Flows for ${objectName}: ${error}`);\n    }\n  }\n\n  return pills;\n}\n\n/**\n * Analyze Validation Rules for field usage\n */\nasync function analyzeValidationUsage(\n  fieldNames: Set<string>,\n  config?: SfConnectionConfig\n): Promise<UsagePill[]> {\n  const pills: UsagePill[] = [];\n\n  logDebug('Analyzing Validation Rule usage');\n\n  // Group fields by object\n  const fieldsByObject = new Map<string, string[]>();\n  \n  for (const fieldName of fieldNames) {\n    const parts = fieldName.split('.');\n    if (parts.length === 2) {\n      const objectName = parts[0];\n      const field = parts[1];\n      \n      if (!fieldsByObject.has(objectName!)) {\n        fieldsByObject.set(objectName!, []);\n      }\n      fieldsByObject.get(objectName!)!.push(field!);\n    }\n  }\n\n  for (const [objectName, fields] of fieldsByObject) {\n    try {\n      const query = `\n        SELECT Id, ValidationName, ErrorMessage, Active\n        FROM ValidationRule\n        WHERE EntityDefinition.QualifiedApiName = '${objectName}'\n        AND Active = true\n      `;\n      \n      const result = await executeToolingQuery<{\n        Id: string;\n        ValidationName: string;\n        ErrorMessage: string;\n        Active: boolean;\n      }>(query, config);\n      \n      if (result.records.length > 0) {\n        pills.push(createPill({\n          type: 'validation_usage',\n          label: `${objectName} Validation Rules`,\n          description: `${result.records.length} active validation rule(s) on this object`,\n          severity: 'info',\n          affectedComponents: result.records.map(r => r.ValidationName),\n          recommendation: 'Review validation rules when modifying fields on this object',\n        }));\n      }\n    } catch (error) {\n      logDebug(`Error analyzing Validation Rules for ${objectName}: ${error}`);\n    }\n  }\n\n  return pills;\n}\n\n/**\n * Create a usage pill with a unique ID\n */\nexport function createPill(options: Omit<UsagePill, 'id'>): UsagePill {\n  return {\n    id: `pill_${Date.now()}_${Math.random().toString(36).substring(7)}`,\n    ...options,\n  };\n}\n\n/**\n * Filter pills by severity\n */\nexport function filterPillsBySeverity(\n  pills: UsagePill[],\n  minSeverity: UsageSeverity\n): UsagePill[] {\n  const severityOrder: Record<UsageSeverity, number> = {\n    info: 0,\n    warning: 1,\n    critical: 2,\n  };\n\n  const minLevel = severityOrder[minSeverity];\n  return pills.filter(p => severityOrder[p.severity] >= minLevel);\n}\n\n/**\n * Filter pills by type\n */\nexport function filterPillsByType(\n  pills: UsagePill[],\n  types: UsagePillType[]\n): UsagePill[] {\n  return pills.filter(p => types.includes(p.type));\n}\n\n/**\n * Group pills by severity\n */\nexport function groupPillsBySeverity(\n  pills: UsagePill[]\n): Record<UsageSeverity, UsagePill[]> {\n  const result: Record<UsageSeverity, UsagePill[]> = {\n    info: [],\n    warning: [],\n    critical: [],\n  };\n\n  for (const pill of pills) {\n    result[pill.severity].push(pill);\n  }\n\n  return result;\n}\n\n/**\n * Get summary of pills\n */\nexport function getPillsSummary(pills: UsagePill[]): PillsSummary {\n  const grouped = groupPillsBySeverity(pills);\n  \n  return {\n    total: pills.length,\n    byCategory: {\n      info: grouped.info.length,\n      warning: grouped.warning.length,\n      critical: grouped.critical.length,\n    },\n    topRecommendations: pills\n      .filter(p => p.recommendation)\n      .slice(0, 5)\n      .map(p => p.recommendation!),\n  };\n}\n\n/**\n * Pills summary interface\n */\nexport interface PillsSummary {\n  total: number;\n  byCategory: Record<UsageSeverity, number>;\n  topRecommendations: string[];\n}\n\n/**\n * Format pills for display\n */\nexport function formatPillsForDisplay(pills: UsagePill[]): string {\n  const lines: string[] = [];\n  const grouped = groupPillsBySeverity(pills);\n\n  if (grouped.critical.length > 0) {\n    lines.push(' CRITICAL:');\n    for (const pill of grouped.critical) {\n      lines.push(`  - ${pill.label}: ${pill.description}`);\n    }\n    lines.push('');\n  }\n\n  if (grouped.warning.length > 0) {\n    lines.push(' WARNINGS:');\n    for (const pill of grouped.warning) {\n      lines.push(`  - ${pill.label}: ${pill.description}`);\n    }\n    lines.push('');\n  }\n\n  if (grouped.info.length > 0) {\n    lines.push(' INFO:');\n    for (const pill of grouped.info) {\n      lines.push(`  - ${pill.label}: ${pill.description}`);\n    }\n  }\n\n  return lines.join('\\n');\n}\n","/**\n * Salesforce Dependency Discovery\n * Discovers metadata dependencies for a given component\n */\n\nimport { createSfConnection, type SfConnectionConfig } from './sfClient.js';\nimport { executeToolingQuery, executeSoqlQuery } from './sfQueryExecutor.js';\nimport { traverseDependencies, detectCycles } from './sfDependencyTraverser.js';\nimport { enrichWithUsagePills } from './sfDependencyEnrichment.js';\nimport { logInfo, logDebug, logWarn, createTimer } from './lib/loggerStructured.js';\nimport { validate, DiscoverDependenciesOptionsSchema } from './lib/validationSchemas.js';\nimport type {\n  DependencyNode,\n  DependencyEdge,\n  DependencyGraph,\n  DependencyGraphMetadata,\n  DiscoverDependenciesOptions,\n  DiscoveryResult,\n  MetadataType,\n  DependencyRelationship,\n} from './types/sfDependencyTypes.js';\n\n/**\n * Discover all dependencies for a metadata component\n * \n * @param options - Discovery options\n * @param config - Connection config\n * @returns Discovery result with graph and pills\n */\nexport async function discoverDependencies(\n  options: DiscoverDependenciesOptions,\n  config?: SfConnectionConfig\n): Promise<DiscoveryResult> {\n  const timer = createTimer();\n  const validatedOptions = validate(DiscoverDependenciesOptionsSchema, options);\n\n  const { rootType, rootName, maxDepth = 3 } = validatedOptions;\n\n  logInfo(`Discovering dependencies for ${rootType}:${rootName}`, { maxDepth });\n\n  const nodes = new Map<string, DependencyNode>();\n  const edges: DependencyEdge[] = [];\n  const warnings: string[] = [];\n\n  // Create root node\n  const rootId = createNodeId(rootType, rootName);\n  const rootNode: DependencyNode = {\n    id: rootId,\n    name: rootName,\n    type: rootType,\n    apiName: rootName,\n    depth: 0,\n    isLeaf: false,\n  };\n  nodes.set(rootId, rootNode);\n\n  // Discover dependencies based on type\n  try {\n    await discoverForType(\n      rootType,\n      rootName,\n      0,\n      maxDepth,\n      nodes,\n      edges,\n      warnings,\n      validatedOptions,\n      config\n    );\n  } catch (error) {\n    warnings.push(`Error discovering dependencies: ${error instanceof Error ? error.message : String(error)}`);\n  }\n\n  // Detect cycles\n  const cycleResult = detectCycles(nodes, edges, rootId);\n  if (cycleResult.hasCycles) {\n    logWarn(`Circular dependencies detected`, { cycles: cycleResult.cycles });\n    \n    // Mark circular nodes\n    for (const cycle of cycleResult.cycles) {\n      for (const nodeId of cycle) {\n        const node = nodes.get(nodeId);\n        if (node) {\n          node.isCircular = true;\n        }\n      }\n    }\n  }\n\n  // Build graph metadata\n  const metadata: DependencyGraphMetadata = {\n    generatedAt: new Date().toISOString(),\n    rootType,\n    rootName,\n    maxDepth,\n    nodeCount: nodes.size,\n    edgeCount: edges.length,\n    hasCircularDependencies: cycleResult.hasCycles,\n    circularPaths: cycleResult.hasCycles ? cycleResult.cycles : undefined,\n  };\n\n  const graph: DependencyGraph = {\n    nodes,\n    edges,\n    rootId,\n    metadata,\n  };\n\n  // Enrich with usage pills\n  const pills = await enrichWithUsagePills(graph, config);\n\n  const executionTime = timer.elapsed();\n  logInfo(`Dependency discovery complete`, { \n    nodes: nodes.size, \n    edges: edges.length,\n    executionTime \n  });\n\n  return {\n    graph,\n    pills,\n    warnings,\n    executionTime,\n  };\n}\n\n/**\n * Create a unique node ID\n */\nfunction createNodeId(type: MetadataType, name: string): string {\n  return `${type}:${name}`;\n}\n\n/**\n * Discover dependencies for a specific metadata type\n */\nasync function discoverForType(\n  type: MetadataType,\n  name: string,\n  currentDepth: number,\n  maxDepth: number,\n  nodes: Map<string, DependencyNode>,\n  edges: DependencyEdge[],\n  warnings: string[],\n  options: DiscoverDependenciesOptions,\n  config?: SfConnectionConfig\n): Promise<void> {\n  if (currentDepth >= maxDepth) {\n    return;\n  }\n\n  logDebug(`Discovering ${type}:${name} at depth ${currentDepth}`);\n\n  switch (type) {\n    case 'CustomObject':\n      await discoverCustomObjectDependencies(name, currentDepth, maxDepth, nodes, edges, warnings, options, config);\n      break;\n    case 'CustomField':\n      await discoverCustomFieldDependencies(name, currentDepth, maxDepth, nodes, edges, warnings, options, config);\n      break;\n    case 'ApexClass':\n      await discoverApexClassDependencies(name, currentDepth, maxDepth, nodes, edges, warnings, options, config);\n      break;\n    case 'ApexTrigger':\n      await discoverApexTriggerDependencies(name, currentDepth, maxDepth, nodes, edges, warnings, options, config);\n      break;\n    case 'Flow':\n      await discoverFlowDependencies(name, currentDepth, maxDepth, nodes, edges, warnings, options, config);\n      break;\n    default:\n      logDebug(`No specific discovery for type ${type}`);\n  }\n}\n\n/**\n * Discover dependencies for a CustomObject\n */\nasync function discoverCustomObjectDependencies(\n  objectName: string,\n  currentDepth: number,\n  maxDepth: number,\n  nodes: Map<string, DependencyNode>,\n  edges: DependencyEdge[],\n  warnings: string[],\n  options: DiscoverDependenciesOptions,\n  config?: SfConnectionConfig\n): Promise<void> {\n  const sourceId = createNodeId('CustomObject', objectName);\n\n  // Get custom fields (filter by __c suffix since IsCustom isn't available on FieldDefinition)\n  const fieldsQuery = `\n    SELECT QualifiedApiName, DataType, ReferenceTo, RelationshipName\n    FROM FieldDefinition\n    WHERE EntityDefinition.QualifiedApiName = '${objectName}'\n    AND QualifiedApiName LIKE '%__c'\n  `;\n\n  try {\n    const fields = await executeToolingQuery<{\n      QualifiedApiName: string;\n      DataType: string;\n      ReferenceTo: { referenceTo: string[] } | null;\n      RelationshipName: string | null;\n    }>(fieldsQuery, config);\n\n    for (const field of fields.records) {\n      const fieldId = createNodeId('CustomField', `${objectName}.${field.QualifiedApiName}`);\n      \n      if (!nodes.has(fieldId)) {\n        nodes.set(fieldId, {\n          id: fieldId,\n          name: field.QualifiedApiName,\n          type: 'CustomField',\n          apiName: `${objectName}.${field.QualifiedApiName}`,\n          depth: currentDepth + 1,\n          isLeaf: true,\n          parentId: sourceId,\n        });\n      }\n\n      edges.push({\n        sourceId,\n        targetId: fieldId,\n        relationshipType: 'contains',\n      });\n\n      // Track lookup relationships\n      if (field.ReferenceTo?.referenceTo && field.ReferenceTo.referenceTo.length > 0) {\n        for (const refTo of field.ReferenceTo.referenceTo) {\n          if (!options.includeStandardObjects && !refTo.endsWith('__c')) {\n            continue;\n          }\n\n          const refId = createNodeId('CustomObject', refTo);\n          \n          if (!nodes.has(refId)) {\n            nodes.set(refId, {\n              id: refId,\n              name: refTo,\n              type: 'CustomObject',\n              apiName: refTo,\n              depth: currentDepth + 2,\n              isLeaf: currentDepth + 2 >= maxDepth,\n            });\n\n            // Recursively discover if not at max depth\n            if (currentDepth + 2 < maxDepth) {\n              await discoverForType('CustomObject', refTo, currentDepth + 2, maxDepth, nodes, edges, warnings, options, config);\n            }\n          }\n\n          const relType: DependencyRelationship = field.DataType === 'MasterDetail' ? 'masterDetail' : 'lookupTo';\n          edges.push({\n            sourceId: fieldId,\n            targetId: refId,\n            relationshipType: relType,\n          });\n        }\n      }\n    }\n  } catch (error) {\n    warnings.push(`Error querying fields for ${objectName}: ${error instanceof Error ? error.message : String(error)}`);\n  }\n\n  // Get triggers\n  const triggersQuery = `\n    SELECT Name FROM ApexTrigger WHERE TableEnumOrId = '${objectName}'\n  `;\n\n  try {\n    const triggers = await executeToolingQuery<{ Name: string }>(triggersQuery, config);\n    \n    for (const trigger of triggers.records) {\n      const triggerId = createNodeId('ApexTrigger', trigger.Name);\n      \n      if (!nodes.has(triggerId)) {\n        nodes.set(triggerId, {\n          id: triggerId,\n          name: trigger.Name,\n          type: 'ApexTrigger',\n          apiName: trigger.Name,\n          depth: currentDepth + 1,\n          isLeaf: currentDepth + 1 >= maxDepth,\n          parentId: sourceId,\n        });\n      }\n\n      edges.push({\n        sourceId,\n        targetId: triggerId,\n        relationshipType: 'triggers',\n      });\n    }\n  } catch (error) {\n    warnings.push(`Error querying triggers for ${objectName}: ${error instanceof Error ? error.message : String(error)}`);\n  }\n\n  // Get validation rules\n  const validationQuery = `\n    SELECT ValidationName FROM ValidationRule \n    WHERE EntityDefinition.QualifiedApiName = '${objectName}' AND Active = true\n  `;\n\n  try {\n    const validations = await executeToolingQuery<{ ValidationName: string }>(validationQuery, config);\n    \n    for (const rule of validations.records) {\n      const ruleId = createNodeId('ValidationRule', `${objectName}.${rule.ValidationName}`);\n      \n      if (!nodes.has(ruleId)) {\n        nodes.set(ruleId, {\n          id: ruleId,\n          name: rule.ValidationName,\n          type: 'ValidationRule',\n          apiName: `${objectName}.${rule.ValidationName}`,\n          depth: currentDepth + 1,\n          isLeaf: true,\n          parentId: sourceId,\n        });\n      }\n\n      edges.push({\n        sourceId,\n        targetId: ruleId,\n        relationshipType: 'contains',\n      });\n    }\n  } catch (error) {\n    warnings.push(`Error querying validation rules for ${objectName}: ${error instanceof Error ? error.message : String(error)}`);\n  }\n}\n\n/**\n * Discover dependencies for a CustomField\n */\nasync function discoverCustomFieldDependencies(\n  fieldName: string,\n  currentDepth: number,\n  maxDepth: number,\n  nodes: Map<string, DependencyNode>,\n  edges: DependencyEdge[],\n  warnings: string[],\n  options: DiscoverDependenciesOptions,\n  config?: SfConnectionConfig\n): Promise<void> {\n  // Field dependencies are typically handled through the parent object\n  // This would analyze formula fields, lookup references, etc.\n  logDebug(`Field dependency discovery for ${fieldName} - handled via parent object`);\n}\n\n/**\n * Discover dependencies for an ApexClass\n */\nasync function discoverApexClassDependencies(\n  className: string,\n  currentDepth: number,\n  maxDepth: number,\n  nodes: Map<string, DependencyNode>,\n  edges: DependencyEdge[],\n  warnings: string[],\n  options: DiscoverDependenciesOptions,\n  config?: SfConnectionConfig\n): Promise<void> {\n  const sourceId = createNodeId('ApexClass', className);\n\n  // Query for class dependencies using SymbolTable\n  const query = `\n    SELECT Id, Name, SymbolTable \n    FROM ApexClass \n    WHERE Name = '${className}'\n  `;\n\n  try {\n    const result = await executeToolingQuery<{\n      Id: string;\n      Name: string;\n      SymbolTable: { \n        externalReferences?: Array<{ name: string; namespace: string }>;\n      } | null;\n    }>(query, config);\n\n    if (result.records.length > 0 && result.records[0]?.SymbolTable?.externalReferences) {\n      for (const ref of result.records[0].SymbolTable.externalReferences) {\n        // Skip standard references\n        if (!options.includeStandardObjects && !ref.name.endsWith('__c')) {\n          continue;\n        }\n\n        const refId = createNodeId('ApexClass', ref.name);\n        \n        if (!nodes.has(refId) && ref.name !== className) {\n          nodes.set(refId, {\n            id: refId,\n            name: ref.name,\n            type: 'ApexClass',\n            apiName: ref.name,\n            namespace: ref.namespace || undefined,\n            depth: currentDepth + 1,\n            isLeaf: currentDepth + 1 >= maxDepth,\n          });\n\n          edges.push({\n            sourceId,\n            targetId: refId,\n            relationshipType: 'references',\n          });\n        }\n      }\n    }\n  } catch (error) {\n    warnings.push(`Error querying Apex class ${className}: ${error instanceof Error ? error.message : String(error)}`);\n  }\n}\n\n/**\n * Discover dependencies for an ApexTrigger\n */\nasync function discoverApexTriggerDependencies(\n  triggerName: string,\n  currentDepth: number,\n  maxDepth: number,\n  nodes: Map<string, DependencyNode>,\n  edges: DependencyEdge[],\n  warnings: string[],\n  options: DiscoverDependenciesOptions,\n  config?: SfConnectionConfig\n): Promise<void> {\n  const sourceId = createNodeId('ApexTrigger', triggerName);\n\n  // Get the object the trigger is on\n  const query = `\n    SELECT TableEnumOrId FROM ApexTrigger WHERE Name = '${triggerName}'\n  `;\n\n  try {\n    const result = await executeToolingQuery<{ TableEnumOrId: string }>(query, config);\n    \n    if (result.records.length > 0 && result.records[0]) {\n      const objectName = result.records[0].TableEnumOrId;\n      const objectId = createNodeId('CustomObject', objectName);\n\n      if (!nodes.has(objectId)) {\n        nodes.set(objectId, {\n          id: objectId,\n          name: objectName,\n          type: 'CustomObject',\n          apiName: objectName,\n          depth: currentDepth + 1,\n          isLeaf: currentDepth + 1 >= maxDepth,\n        });\n      }\n\n      edges.push({\n        sourceId,\n        targetId: objectId,\n        relationshipType: 'triggers',\n      });\n    }\n  } catch (error) {\n    warnings.push(`Error querying trigger ${triggerName}: ${error instanceof Error ? error.message : String(error)}`);\n  }\n}\n\n/**\n * Discover dependencies for a Flow\n */\nasync function discoverFlowDependencies(\n  flowName: string,\n  currentDepth: number,\n  maxDepth: number,\n  nodes: Map<string, DependencyNode>,\n  edges: DependencyEdge[],\n  warnings: string[],\n  options: DiscoverDependenciesOptions,\n  config?: SfConnectionConfig\n): Promise<void> {\n  const sourceId = createNodeId('Flow', flowName);\n\n  // Get the object the flow triggers on\n  const query = `\n    SELECT TriggerObjectOrEvent FROM Flow \n    WHERE DeveloperName = '${flowName}' AND IsActive = true\n  `;\n\n  try {\n    const result = await executeToolingQuery<{ TriggerObjectOrEvent: string | null }>(query, config);\n    \n    if (result.records.length > 0 && result.records[0]?.TriggerObjectOrEvent) {\n      const objectName = result.records[0].TriggerObjectOrEvent;\n      const objectId = createNodeId('CustomObject', objectName);\n\n      if (!nodes.has(objectId)) {\n        nodes.set(objectId, {\n          id: objectId,\n          name: objectName,\n          type: 'CustomObject',\n          apiName: objectName,\n          depth: currentDepth + 1,\n          isLeaf: currentDepth + 1 >= maxDepth,\n        });\n      }\n\n      edges.push({\n        sourceId,\n        targetId: objectId,\n        relationshipType: 'flowReference',\n      });\n    }\n  } catch (error) {\n    warnings.push(`Error querying flow ${flowName}: ${error instanceof Error ? error.message : String(error)}`);\n  }\n}\n\n/**\n * Export graph to JSON format for visualization\n */\nexport function exportGraphToJson(graph: DependencyGraph): string {\n  const nodes = Array.from(graph.nodes.values());\n  return JSON.stringify({\n    nodes,\n    edges: graph.edges,\n    metadata: graph.metadata,\n  }, null, 2);\n}\n\n/**\n * Export graph to DOT format for Graphviz\n */\nexport function exportGraphToDot(graph: DependencyGraph): string {\n  const lines: string[] = ['digraph Dependencies {'];\n  lines.push('  rankdir=LR;');\n  lines.push('  node [shape=box];');\n  lines.push('');\n\n  // Add nodes\n  for (const node of graph.nodes.values()) {\n    const label = `${node.type}\\\\n${node.name}`;\n    const color = node.isCircular ? 'red' : 'black';\n    lines.push(`  \"${node.id}\" [label=\"${label}\" color=\"${color}\"];`);\n  }\n\n  lines.push('');\n\n  // Add edges\n  for (const edge of graph.edges) {\n    lines.push(`  \"${edge.sourceId}\" -> \"${edge.targetId}\" [label=\"${edge.relationshipType}\"];`);\n  }\n\n  lines.push('}');\n  return lines.join('\\n');\n}\n"],"mappings":"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","names":["config","config","config","config","config","config","config","output"]}