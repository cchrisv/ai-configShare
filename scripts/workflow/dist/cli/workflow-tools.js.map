{"version":3,"sources":["../../cli/workflow-tools.ts","../../src/lib/loggerStructured.ts","../../src/adoWorkItems.ts","../../src/adoClient.ts","../../src/lib/authAzureCli.ts","../../src/types/adoFieldTypes.ts","../../src/lib/retryWithBackoff.ts","../../src/lib/validationSchemas.ts","../../src/lib/configLoader.ts"],"sourcesContent":["#!/usr/bin/env node\n/**\n * Workflow Tools CLI\n * Command-line interface for workflow automation\n */\n\nimport { Command } from 'commander';\nimport { existsSync, mkdirSync, writeFileSync, readFileSync, readdirSync, rmSync } from 'fs';\nimport { resolve } from 'path';\nimport { configureLogger } from '../src/lib/loggerStructured.js';\nimport { getWorkItem } from '../src/adoWorkItems.js';\nimport { loadSharedConfig, getProjectRoot } from '../src/lib/configLoader.js';\n\nconst program = new Command();\n\nprogram\n  .name('workflow-tools')\n  .description('Workflow automation operations')\n  .version('2.0.0');\n\n// Prepare command\nprogram\n  .command('prepare')\n  .description('Initialize workflow artifacts for a work item')\n  .requiredOption('-w, --work-item <id>', 'Work item ID', parseInt)\n  .option('--force', 'Overwrite existing run state')\n  .option('--json', 'Output as JSON')\n  .option('-v, --verbose', 'Verbose output')\n  .action(async (options) => {\n    try {\n      if (options.verbose) {\n        configureLogger({ minLevel: 'debug' });\n      }\n\n      const workItemId = options.workItem;\n      \n      // Load shared config\n      const config = loadSharedConfig();\n      const projectRoot = getProjectRoot();\n      const artifactsRoot = config.paths.artifacts_root;\n      \n      // Define paths (relative to project root, not cwd)\n      const root = resolve(projectRoot, artifactsRoot, String(workItemId));\n      const researchDir = resolve(root, 'research');\n      const groomingDir = resolve(root, 'grooming');\n      const solutioningDir = resolve(root, 'solutioning');\n      const wikiDir = resolve(root, 'wiki');\n      const runStatePath = resolve(root, 'run-state.json');\n      \n      // Check if already initialized\n      if (existsSync(runStatePath) && !options.force) {\n        const result = {\n          success: false,\n          message: `Workflow already initialized for ${workItemId}. Use --force to reinitialize.`,\n          runStatePath,\n        };\n        console.log(options.json ? JSON.stringify(result, null, 2) : result.message);\n        process.exit(0);\n      }\n      \n      // Fetch work item to validate it exists\n      const workItem = await getWorkItem(workItemId, { expand: 'All' });\n      \n      // Create directories\n      const dirsCreated: string[] = [];\n      for (const dir of [root, researchDir, groomingDir, solutioningDir, wikiDir]) {\n        if (!existsSync(dir)) {\n          mkdirSync(dir, { recursive: true });\n          dirsCreated.push(dir);\n        }\n      }\n      \n      // Create run state\n      const now = new Date().toISOString();\n      const runState = {\n        workItemId: String(workItemId),\n        version: 1,\n        currentPhase: 'research',\n        phaseOrder: ['research', 'grooming', 'solutioning', 'wiki', 'finalization'],\n        completedSteps: [],\n        errors: [],\n        metrics: {\n          phases: {},\n          startedAt: now,\n        },\n        lastUpdated: now,\n      };\n      writeFileSync(runStatePath, JSON.stringify(runState, null, 2), 'utf-8');\n      \n      // Save work item snapshot\n      const workItemPath = resolve(researchDir, config.artifact_files.research.ado_workitem);\n      writeFileSync(workItemPath, JSON.stringify(workItem, null, 2), 'utf-8');\n      \n      const result = {\n        success: true,\n        workItemId,\n        workItemType: workItem.fields['System.WorkItemType'],\n        title: workItem.fields['System.Title'],\n        directories: {\n          root,\n          research: researchDir,\n          grooming: groomingDir,\n          solutioning: solutioningDir,\n          wiki: wikiDir,\n        },\n        files: {\n          runState: runStatePath,\n          workItemSnapshot: workItemPath,\n        },\n        message: `Workflow initialized for ${workItemId}. Next: Run research phase.`,\n      };\n      \n      if (options.json) {\n        console.log(JSON.stringify(result, null, 2));\n      } else {\n        console.log(`✓ Initialized workflow for ${workItem.fields['System.WorkItemType']} #${workItemId}`);\n        console.log(`  Title: ${workItem.fields['System.Title']}`);\n        console.log(`  Run state: ${runStatePath}`);\n        console.log(`  Next step: Run research phase`);\n      }\n    } catch (error) {\n      console.error('Error:', error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\n// Status command\nprogram\n  .command('status')\n  .description('Get workflow status')\n  .requiredOption('-w, --work-item <id>', 'Work item ID', parseInt)\n  .option('--json', 'Output as JSON')\n  .option('-v, --verbose', 'Verbose output')\n  .action(async (options) => {\n    try {\n      if (options.verbose) {\n        configureLogger({ minLevel: 'debug' });\n      }\n\n      const workItemId = options.workItem;\n      const config = loadSharedConfig();\n      const projectRoot = getProjectRoot();\n      const artifactsRoot = config.paths.artifacts_root;\n      const root = resolve(projectRoot, artifactsRoot, String(workItemId));\n      const runStatePath = resolve(root, 'run-state.json');\n      \n      if (!existsSync(runStatePath)) {\n        const result = {\n          success: false,\n          workItemId,\n          message: `No workflow found for ${workItemId}. Run 'workflow-tools prepare' first.`,\n        };\n        console.log(options.json ? JSON.stringify(result, null, 2) : result.message);\n        process.exit(1);\n      }\n      \n      const runState = JSON.parse(readFileSync(runStatePath, 'utf-8'));\n      \n      // Count artifacts in each phase directory\n      const countFiles = (dir: string): number => {\n        if (!existsSync(dir)) return 0;\n        return readdirSync(dir).length;\n      };\n      \n      const result = {\n        success: true,\n        workItemId,\n        currentPhase: runState.currentPhase,\n        completedSteps: runState.completedSteps.length,\n        errors: runState.errors.length,\n        artifacts: {\n          research: countFiles(resolve(root, 'research')),\n          grooming: countFiles(resolve(root, 'grooming')),\n          solutioning: countFiles(resolve(root, 'solutioning')),\n          wiki: countFiles(resolve(root, 'wiki')),\n        },\n        startedAt: runState.metrics?.startedAt,\n        lastUpdated: runState.lastUpdated,\n      };\n      \n      if (options.json) {\n        console.log(JSON.stringify(result, null, 2));\n      } else {\n        console.log(`Workflow Status for #${workItemId}`);\n        console.log(`  Current Phase: ${runState.currentPhase}`);\n        console.log(`  Completed Steps: ${runState.completedSteps.length}`);\n        console.log(`  Errors: ${runState.errors.length}`);\n        console.log(`  Artifacts: research=${result.artifacts.research}, grooming=${result.artifacts.grooming}, solutioning=${result.artifacts.solutioning}, wiki=${result.artifacts.wiki}`);\n        console.log(`  Started: ${runState.metrics?.startedAt || 'N/A'}`);\n        console.log(`  Last Updated: ${runState.lastUpdated}`);\n      }\n    } catch (error) {\n      console.error('Error:', error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\n// Reset command\nprogram\n  .command('reset')\n  .description('Reset workflow state (all phases or specific phase)')\n  .requiredOption('-w, --work-item <id>', 'Work item ID', parseInt)\n  .option('-p, --phase <phase>', 'Specific phase to reset (research, grooming, solutioning, wiki)')\n  .option('--force', 'Skip confirmation')\n  .option('--json', 'Output as JSON')\n  .option('-v, --verbose', 'Verbose output')\n  .action(async (options) => {\n    try {\n      if (options.verbose) {\n        configureLogger({ minLevel: 'debug' });\n      }\n\n      if (!options.force) {\n        const scope = options.phase ? `${options.phase} phase` : 'all artifacts';\n        console.error(`Error: Use --force to confirm reset. This will delete ${scope}.`);\n        process.exit(1);\n      }\n\n      const workItemId = options.workItem;\n      const phase = options.phase;\n      const validPhases = ['research', 'grooming', 'solutioning', 'wiki'];\n      \n      // Validate phase if provided\n      if (phase && !validPhases.includes(phase)) {\n        console.error(`Error: Invalid phase '${phase}'. Valid phases: ${validPhases.join(', ')}`);\n        process.exit(1);\n      }\n\n      const config = loadSharedConfig();\n      const projectRoot = getProjectRoot();\n      const artifactsRoot = config.paths.artifacts_root;\n      const root = resolve(projectRoot, artifactsRoot, String(workItemId));\n      \n      if (!existsSync(root)) {\n        const result = {\n          success: false,\n          workItemId,\n          message: `No workflow found for ${workItemId}.`,\n        };\n        console.log(options.json ? JSON.stringify(result, null, 2) : result.message);\n        process.exit(0);\n      }\n\n      if (phase) {\n        // Reset specific phase\n        const phaseDir = resolve(root, phase);\n        const deletedFiles: string[] = [];\n        \n        if (existsSync(phaseDir)) {\n          // Count files before deletion\n          const files = readdirSync(phaseDir);\n          deletedFiles.push(...files);\n          rmSync(phaseDir, { recursive: true, force: true });\n          // Recreate empty directory\n          mkdirSync(phaseDir, { recursive: true });\n        }\n        \n        // Update run state to reflect phase reset\n        const runStatePath = resolve(root, 'run-state.json');\n        if (existsSync(runStatePath)) {\n          const runState = JSON.parse(readFileSync(runStatePath, 'utf-8'));\n          // Remove completed steps for this phase\n          runState.completedSteps = runState.completedSteps.filter(\n            (step: string) => !step.toLowerCase().includes(phase)\n          );\n          // If resetting a phase before current, reset currentPhase\n          const phaseIndex = runState.phaseOrder.indexOf(phase);\n          const currentIndex = runState.phaseOrder.indexOf(runState.currentPhase);\n          if (phaseIndex <= currentIndex) {\n            runState.currentPhase = phase;\n          }\n          // Clear phase metrics\n          if (runState.metrics?.phases?.[phase]) {\n            delete runState.metrics.phases[phase];\n          }\n          runState.lastUpdated = new Date().toISOString();\n          writeFileSync(runStatePath, JSON.stringify(runState, null, 2), 'utf-8');\n        }\n        \n        const result = {\n          success: true,\n          workItemId,\n          phase,\n          deletedFiles: deletedFiles.length,\n          message: `Phase '${phase}' reset for ${workItemId}. ${deletedFiles.length} files deleted.`,\n          deletedPath: phaseDir,\n        };\n        \n        if (options.json) {\n          console.log(JSON.stringify(result, null, 2));\n        } else {\n          console.log(`✓ Phase '${phase}' reset for #${workItemId}`);\n          console.log(`  Deleted: ${deletedFiles.length} files from ${phaseDir}`);\n          console.log(`  Run state updated`);\n        }\n      } else {\n        // Reset all (original behavior)\n        rmSync(root, { recursive: true, force: true });\n        \n        const result = {\n          success: true,\n          workItemId,\n          phase: 'all',\n          message: `Workflow reset for ${workItemId}. All artifacts deleted.`,\n          deletedPath: root,\n        };\n        \n        if (options.json) {\n          console.log(JSON.stringify(result, null, 2));\n        } else {\n          console.log(`✓ Workflow reset for #${workItemId}`);\n          console.log(`  Deleted: ${root}`);\n        }\n      }\n    } catch (error) {\n      console.error('Error:', error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\nprogram.parse();\n","/**\n * Structured Logger\n * JSON-based logging for consistent output\n */\n\n/**\n * Log levels\n */\nexport type LogLevel = 'debug' | 'info' | 'warn' | 'error';\n\n/**\n * Log entry structure\n */\nexport interface LogEntry {\n  timestamp: string;\n  level: LogLevel;\n  message: string;\n  data?: unknown;\n  context?: LogContext;\n}\n\n/**\n * Log context for tracking operations\n */\nexport interface LogContext {\n  operation?: string;\n  workItemId?: number;\n  sfOrg?: string;\n  duration?: number;\n  [key: string]: unknown;\n}\n\n/**\n * Logger configuration\n */\nexport interface LoggerConfig {\n  minLevel: LogLevel;\n  jsonOutput: boolean;\n  includeTimestamp: boolean;\n  context?: LogContext;\n  /** When true, suppress all log output (useful for CLI --json mode) */\n  silent: boolean;\n  /** When true, output to stderr instead of stdout */\n  useStderr: boolean;\n}\n\n/**\n * Log level priority (higher = more important)\n */\nconst LOG_LEVEL_PRIORITY: Record<LogLevel, number> = {\n  debug: 0,\n  info: 1,\n  warn: 2,\n  error: 3,\n};\n\n/**\n * Default logger configuration\n */\nlet config: LoggerConfig = {\n  minLevel: 'info',\n  jsonOutput: false,\n  includeTimestamp: true,\n  silent: false,\n  useStderr: false,\n};\n\n/**\n * Configure the logger\n */\nexport function configureLogger(newConfig: Partial<LoggerConfig>): void {\n  config = { ...config, ...newConfig };\n}\n\n/**\n * Get current logger configuration\n */\nexport function getLoggerConfig(): LoggerConfig {\n  return { ...config };\n}\n\n/**\n * Check if a log level should be output\n */\nfunction shouldLog(level: LogLevel): boolean {\n  if (config.silent) return false;\n  return LOG_LEVEL_PRIORITY[level] >= LOG_LEVEL_PRIORITY[config.minLevel];\n}\n\n/**\n * Output a log message to the appropriate stream\n */\nfunction output(level: LogLevel, message: string): void {\n  if (config.useStderr) {\n    console.error(message);\n  } else {\n    switch (level) {\n      case 'debug':\n        console.debug(message);\n        break;\n      case 'info':\n        console.info(message);\n        break;\n      case 'warn':\n        console.warn(message);\n        break;\n      case 'error':\n        console.error(message);\n        break;\n    }\n  }\n}\n\n/**\n * Format a log entry\n */\nfunction formatEntry(entry: LogEntry): string {\n  if (config.jsonOutput) {\n    return JSON.stringify(entry);\n  }\n\n  const parts: string[] = [];\n\n  if (config.includeTimestamp) {\n    parts.push(`[${entry.timestamp}]`);\n  }\n\n  parts.push(`[${entry.level.toUpperCase()}]`);\n  parts.push(entry.message);\n\n  if (entry.data !== undefined) {\n    if (typeof entry.data === 'object') {\n      parts.push(JSON.stringify(entry.data, null, 2));\n    } else {\n      parts.push(String(entry.data));\n    }\n  }\n\n  return parts.join(' ');\n}\n\n/**\n * Create a log entry\n */\nfunction createEntry(level: LogLevel, message: string, data?: unknown, context?: LogContext): LogEntry {\n  return {\n    timestamp: new Date().toISOString(),\n    level,\n    message,\n    data,\n    context: context ?? config.context,\n  };\n}\n\n/**\n * Log a debug message\n */\nexport function logDebug(message: string, data?: unknown, context?: LogContext): void {\n  if (!shouldLog('debug')) return;\n  const entry = createEntry('debug', message, data, context);\n  output('debug', formatEntry(entry));\n}\n\n/**\n * Log an info message\n */\nexport function logInfo(message: string, data?: unknown, context?: LogContext): void {\n  if (!shouldLog('info')) return;\n  const entry = createEntry('info', message, data, context);\n  output('info', formatEntry(entry));\n}\n\n/**\n * Log a warning message\n */\nexport function logWarn(message: string, data?: unknown, context?: LogContext): void {\n  if (!shouldLog('warn')) return;\n  const entry = createEntry('warn', message, data, context);\n  output('warn', formatEntry(entry));\n}\n\n/**\n * Log an error message\n */\nexport function logError(message: string, data?: unknown, context?: LogContext): void {\n  if (!shouldLog('error')) return;\n  const entry = createEntry('error', message, data, context);\n  output('error', formatEntry(entry));\n}\n\n/**\n * Log an event (always info level, but with structured event data)\n */\nexport function logEvent(event: string, data?: Record<string, unknown>, context?: LogContext): void {\n  if (!shouldLog('info')) return;\n  const entry = createEntry('info', `[EVENT] ${event}`, data, context);\n  output('info', formatEntry(entry));\n}\n\n/**\n * Create a child logger with additional context\n */\nexport function createChildLogger(additionalContext: LogContext): ChildLogger {\n  return {\n    debug: (message: string, data?: unknown) => logDebug(message, data, additionalContext),\n    info: (message: string, data?: unknown) => logInfo(message, data, additionalContext),\n    warn: (message: string, data?: unknown) => logWarn(message, data, additionalContext),\n    error: (message: string, data?: unknown) => logError(message, data, additionalContext),\n    event: (event: string, data?: Record<string, unknown>) => logEvent(event, data, additionalContext),\n  };\n}\n\n/**\n * Child logger interface\n */\nexport interface ChildLogger {\n  debug: (message: string, data?: unknown) => void;\n  info: (message: string, data?: unknown) => void;\n  warn: (message: string, data?: unknown) => void;\n  error: (message: string, data?: unknown) => void;\n  event: (event: string, data?: Record<string, unknown>) => void;\n}\n\n/**\n * Timer utility for measuring operation duration\n */\nexport function createTimer(): Timer {\n  const startTime = Date.now();\n  return {\n    elapsed: () => Date.now() - startTime,\n    elapsedSeconds: () => (Date.now() - startTime) / 1000,\n    log: (operation: string, level: LogLevel = 'info') => {\n      const duration = Date.now() - startTime;\n      const message = `${operation} completed in ${duration}ms`;\n      const context: LogContext = { operation, duration };\n      \n      switch (level) {\n        case 'debug': logDebug(message, undefined, context); break;\n        case 'info': logInfo(message, undefined, context); break;\n        case 'warn': logWarn(message, undefined, context); break;\n        case 'error': logError(message, undefined, context); break;\n      }\n    },\n  };\n}\n\n/**\n * Timer interface\n */\nexport interface Timer {\n  elapsed: () => number;\n  elapsedSeconds: () => number;\n  log: (operation: string, level?: LogLevel) => void;\n}\n","/**\n * Azure DevOps Work Items\n * Operations for getting, creating, updating, and searching work items\n */\n\nimport { Operation, type JsonPatchOperation } from 'azure-devops-node-api/interfaces/common/VSSInterfaces.js';\nimport type { \n  WorkItem as AdoWorkItem,\n  WorkItemExpand,\n  Wiql,\n} from 'azure-devops-node-api/interfaces/WorkItemTrackingInterfaces.js';\nimport { createAdoConnection, type AdoConnectionConfig } from './adoClient.js';\nimport { retryWithBackoff, RETRY_PRESETS } from './lib/retryWithBackoff.js';\nimport { logInfo, logDebug, createTimer } from './lib/loggerStructured.js';\nimport { validate, GetWorkItemOptionsSchema, CreateWorkItemOptionsSchema, UpdateWorkItemOptionsSchema, SearchWorkItemsOptionsSchema } from './lib/validationSchemas.js';\nimport type {\n  WorkItem,\n  WorkItemWithComments,\n  WorkItemFields,\n  GetWorkItemOptions,\n  CreateWorkItemOptions,\n  UpdateWorkItemOptions,\n  SearchWorkItemsOptions,\n  WorkItemSearchResult,\n} from './types/adoWorkItemTypes.js';\nimport { ADO_FIELDS } from './types/adoFieldTypes.js';\n\n/**\n * Convert ADO API work item to our WorkItem type\n */\nfunction convertWorkItem(item: AdoWorkItem): WorkItem {\n  return {\n    id: item.id ?? 0,\n    rev: item.rev ?? 0,\n    url: item.url ?? '',\n    fields: (item.fields ?? {}) as WorkItemFields,\n    relations: item.relations?.map(r => ({\n      rel: r.rel ?? '',\n      url: r.url ?? '',\n      attributes: r.attributes ?? {},\n    })) ?? [],\n    _links: item._links as Record<string, { href: string }> | undefined,\n  };\n}\n\n/**\n * Map expand option to API enum\n */\nfunction mapExpandOption(expand?: string): WorkItemExpand | undefined {\n  if (!expand) return undefined;\n  const expandMap: Record<string, WorkItemExpand> = {\n    'None': 0,\n    'Relations': 1,\n    'Fields': 2,\n    'Links': 3,\n    'All': 4,\n  };\n  return expandMap[expand];\n}\n\n/**\n * Get a work item by ID\n * \n * @param id - Work item ID\n * @param options - Get options\n * @param config - Connection config\n * @returns Work item\n */\nexport async function getWorkItem(\n  id: number,\n  options: GetWorkItemOptions = {},\n  config?: AdoConnectionConfig\n): Promise<WorkItemWithComments> {\n  const timer = createTimer();\n  const validatedOptions = validate(GetWorkItemOptionsSchema, options);\n  \n  logInfo(`Getting work item ${id}`, { expand: validatedOptions.expand });\n\n  const conn = await createAdoConnection(config);\n  const witApi = await conn.getWorkItemTrackingApi();\n\n  const workItem = await retryWithBackoff(\n    () => witApi.getWorkItem(\n      id,\n      validatedOptions.fields,\n      undefined,\n      mapExpandOption(validatedOptions.expand),\n      conn.project\n    ),\n    { ...RETRY_PRESETS.standard, operationName: `getWorkItem(${id})` }\n  );\n\n  if (!workItem) {\n    throw new Error(`Work item ${id} not found`);\n  }\n\n  const result: WorkItemWithComments = convertWorkItem(workItem);\n\n  // Fetch comments if requested\n  if (validatedOptions.includeComments) {\n    logDebug(`Fetching comments for work item ${id}`);\n    const comments = await retryWithBackoff(\n      () => witApi.getComments(conn.project, id),\n      { ...RETRY_PRESETS.standard, operationName: `getComments(${id})` }\n    );\n    \n    result.comments = comments.comments?.map(c => ({\n      id: c.id ?? 0,\n      workItemId: c.workItemId ?? id,\n      text: c.text ?? '',\n      createdBy: {\n        displayName: c.createdBy?.displayName ?? '',\n        url: c.createdBy?.url ?? '',\n        id: c.createdBy?.id ?? '',\n        uniqueName: c.createdBy?.uniqueName ?? '',\n      },\n      createdDate: c.createdDate?.toISOString() ?? '',\n      format: 'html',\n    })) ?? [];\n  }\n\n  timer.log(`getWorkItem(${id})`);\n  return result;\n}\n\n/**\n * Update a work item\n * \n * @param id - Work item ID\n * @param options - Update options\n * @param config - Connection config\n * @returns Updated work item\n */\nexport async function updateWorkItem(\n  id: number,\n  options: UpdateWorkItemOptions,\n  config?: AdoConnectionConfig\n): Promise<WorkItem> {\n  const timer = createTimer();\n  const validatedOptions = validate(UpdateWorkItemOptionsSchema, options);\n\n  logInfo(`Updating work item ${id}`);\n\n  // Build patch document\n  const patchDoc: JsonPatchOperation[] = [];\n\n  // Add fields from options\n  if (validatedOptions.fields) {\n    for (const [key, value] of Object.entries(validatedOptions.fields)) {\n      if (value !== undefined) {\n        patchDoc.push({\n          op: Operation.Add,\n          path: `/fields/${key}`,\n          value,\n        });\n      }\n    }\n  }\n\n\n  // Add comment/history if specified\n  if (validatedOptions.comment) {\n    patchDoc.push({\n      op: Operation.Add,\n      path: `/fields/${ADO_FIELDS.HISTORY}`,\n      value: validatedOptions.comment,\n    });\n  }\n\n  if (patchDoc.length === 0) {\n    logDebug('No updates to apply');\n    return getWorkItem(id, {}, config);\n  }\n\n  logDebug(`Applying ${patchDoc.length} patch operations`);\n\n  const conn = await createAdoConnection(config);\n  const witApi = await conn.getWorkItemTrackingApi();\n\n  const updatedItem = await retryWithBackoff(\n    () => witApi.updateWorkItem(\n      undefined, // customHeaders\n      patchDoc,\n      id,\n      conn.project\n    ),\n    { ...RETRY_PRESETS.standard, operationName: `updateWorkItem(${id})` }\n  );\n\n  if (!updatedItem) {\n    throw new Error(`Failed to update work item ${id}`);\n  }\n\n  timer.log(`updateWorkItem(${id})`);\n  return convertWorkItem(updatedItem);\n}\n\n/**\n * Create a new work item\n * \n * @param options - Create options\n * @param config - Connection config\n * @returns Created work item\n */\nexport async function createWorkItem(\n  options: CreateWorkItemOptions,\n  config?: AdoConnectionConfig\n): Promise<WorkItem> {\n  const timer = createTimer();\n  const validatedOptions = validate(CreateWorkItemOptionsSchema, options);\n\n  logInfo(`Creating ${validatedOptions.type} work item: ${validatedOptions.title}`);\n\n  // Build patch document\n  const patchDoc: JsonPatchOperation[] = [];\n\n  // Required: Title\n  patchDoc.push({\n    op: Operation.Add,\n    path: `/fields/${ADO_FIELDS.TITLE}`,\n    value: validatedOptions.title,\n  });\n\n  // Optional fields\n  if (validatedOptions.description) {\n    patchDoc.push({\n      op: Operation.Add,\n      path: `/fields/${ADO_FIELDS.DESCRIPTION}`,\n      value: validatedOptions.description,\n    });\n  }\n\n  if (validatedOptions.areaPath) {\n    patchDoc.push({\n      op: Operation.Add,\n      path: `/fields/${ADO_FIELDS.AREA_PATH}`,\n      value: validatedOptions.areaPath,\n    });\n  }\n\n  if (validatedOptions.iterationPath) {\n    patchDoc.push({\n      op: Operation.Add,\n      path: `/fields/${ADO_FIELDS.ITERATION_PATH}`,\n      value: validatedOptions.iterationPath,\n    });\n  }\n\n  if (validatedOptions.assignedTo) {\n    patchDoc.push({\n      op: Operation.Add,\n      path: `/fields/${ADO_FIELDS.ASSIGNED_TO}`,\n      value: validatedOptions.assignedTo,\n    });\n  }\n\n  if (validatedOptions.tags && validatedOptions.tags.length > 0) {\n    patchDoc.push({\n      op: Operation.Add,\n      path: `/fields/${ADO_FIELDS.TAGS}`,\n      value: validatedOptions.tags.join('; '),\n    });\n  }\n\n  // Add parent link if specified\n  if (validatedOptions.parentId) {\n    const conn = await createAdoConnection(config);\n    patchDoc.push({\n      op: Operation.Add,\n      path: '/relations/-',\n      value: {\n        rel: 'System.LinkTypes.Hierarchy-Reverse',\n        url: `${conn.orgUrl}/${conn.project}/_apis/wit/workItems/${validatedOptions.parentId}`,\n      },\n    });\n  }\n\n  // Add any additional fields\n  if (validatedOptions.additionalFields) {\n    for (const [key, value] of Object.entries(validatedOptions.additionalFields)) {\n      if (value !== undefined && !key.startsWith('System.')) {\n        patchDoc.push({\n          op: Operation.Add,\n          path: `/fields/${key}`,\n          value,\n        });\n      }\n    }\n  }\n\n  const conn = await createAdoConnection(config);\n  const witApi = await conn.getWorkItemTrackingApi();\n\n  const createdItem = await retryWithBackoff(\n    () => witApi.createWorkItem(\n      undefined, // customHeaders\n      patchDoc,\n      conn.project,\n      validatedOptions.type\n    ),\n    { ...RETRY_PRESETS.standard, operationName: 'createWorkItem' }\n  );\n\n  if (!createdItem) {\n    throw new Error('Failed to create work item');\n  }\n\n  logInfo(`Created work item ${createdItem.id}`);\n  timer.log('createWorkItem');\n  return convertWorkItem(createdItem);\n}\n\n/**\n * Search for work items\n * \n * @param options - Search options\n * @param config - Connection config\n * @returns Search results\n */\nexport async function searchWorkItems(\n  options: SearchWorkItemsOptions,\n  config?: AdoConnectionConfig\n): Promise<WorkItemSearchResult> {\n  const timer = createTimer();\n  const validatedOptions = validate(SearchWorkItemsOptionsSchema, options);\n\n  logInfo('Searching work items', validatedOptions);\n\n  const conn = await createAdoConnection(config);\n  const witApi = await conn.getWorkItemTrackingApi();\n\n  let wiqlQuery: string;\n\n  if (validatedOptions.wiql) {\n    // Use provided WIQL directly\n    wiqlQuery = validatedOptions.wiql;\n  } else {\n    // Build WIQL from options\n    const conditions: string[] = [];\n\n    if (validatedOptions.searchText) {\n      conditions.push(`[System.Title] CONTAINS '${validatedOptions.searchText}'`);\n    }\n\n    if (validatedOptions.workItemType) {\n      conditions.push(`[System.WorkItemType] = '${validatedOptions.workItemType}'`);\n    }\n\n    if (validatedOptions.state) {\n      conditions.push(`[System.State] = '${validatedOptions.state}'`);\n    }\n\n    if (validatedOptions.assignedTo) {\n      conditions.push(`[System.AssignedTo] = '${validatedOptions.assignedTo}'`);\n    }\n\n    if (validatedOptions.areaPath) {\n      conditions.push(`[System.AreaPath] UNDER '${validatedOptions.areaPath}'`);\n    }\n\n    if (validatedOptions.iterationPath) {\n      conditions.push(`[System.IterationPath] UNDER '${validatedOptions.iterationPath}'`);\n    }\n\n    if (validatedOptions.tags && validatedOptions.tags.length > 0) {\n      for (const tag of validatedOptions.tags) {\n        conditions.push(`[System.Tags] CONTAINS '${tag}'`);\n      }\n    }\n\n    const whereClause = conditions.length > 0 \n      ? `WHERE ${conditions.join(' AND ')}` \n      : '';\n\n    // WIQL format: SELECT [fields] FROM WorkItems WHERE ... ORDER BY ...\n    // Note: WIQL doesn't support TOP in the query - we limit in code instead\n    wiqlQuery = `SELECT [System.Id] FROM WorkItems ${whereClause} ORDER BY [System.ChangedDate] DESC`;\n  }\n\n  logDebug('Executing WIQL', { wiql: wiqlQuery });\n\n  const wiql: Wiql = { query: wiqlQuery };\n\n  const queryResult = await retryWithBackoff(\n    () => witApi.queryByWiql(wiql, { project: conn.project }),\n    { ...RETRY_PRESETS.standard, operationName: 'queryByWiql' }\n  );\n\n  if (!queryResult.workItems || queryResult.workItems.length === 0) {\n    logDebug('No work items found');\n    return { workItems: [], count: 0 };\n  }\n\n  // Get full work item details\n  let ids = queryResult.workItems\n    .map(wi => wi.id)\n    .filter((id): id is number => id !== undefined);\n\n  // Apply top limit if specified\n  if (validatedOptions.top && ids.length > validatedOptions.top) {\n    ids = ids.slice(0, validatedOptions.top);\n  }\n\n  logDebug(`Found ${ids.length} work items, fetching details`);\n\n  // Azure DevOps API has a 200 work item limit per request\n  // Fetch in batches to handle larger result sets\n  const BATCH_SIZE = 200;\n  const allWorkItems: AdoWorkItem[] = [];\n  \n  for (let i = 0; i < ids.length; i += BATCH_SIZE) {\n    const batchIds = ids.slice(i, i + BATCH_SIZE);\n    logDebug(`Fetching batch ${Math.floor(i / BATCH_SIZE) + 1} of ${Math.ceil(ids.length / BATCH_SIZE)} (${batchIds.length} items)`);\n    \n    const batchWorkItems = await retryWithBackoff(\n      () => witApi.getWorkItems(batchIds, undefined, undefined, undefined, undefined, conn.project),\n      { ...RETRY_PRESETS.standard, operationName: `getWorkItems(batch ${Math.floor(i / BATCH_SIZE) + 1})` }\n    );\n    \n    allWorkItems.push(...batchWorkItems.filter((wi): wi is AdoWorkItem => wi !== null));\n  }\n\n  const results = allWorkItems.map(convertWorkItem);\n\n  timer.log('searchWorkItems');\n  return {\n    workItems: results,\n    count: results.length,\n  };\n}\n","/**\n * Azure DevOps Client\n * Creates authenticated connections to Azure DevOps\n */\n\nimport * as azdev from 'azure-devops-node-api';\nimport type { IWorkItemTrackingApi } from 'azure-devops-node-api/WorkItemTrackingApi.js';\nimport type { IWikiApi } from 'azure-devops-node-api/WikiApi.js';\nimport type { ICoreApi } from 'azure-devops-node-api/CoreApi.js';\nimport type { IGitApi } from 'azure-devops-node-api/GitApi.js';\nimport { getAzureBearerToken, validateAzureAuth } from './lib/authAzureCli.js';\nimport { DEFAULT_ADO_ORG, DEFAULT_ADO_PROJECT } from './types/adoFieldTypes.js';\nimport { logInfo, logDebug } from './lib/loggerStructured.js';\n\n/**\n * ADO connection configuration\n */\nexport interface AdoConnectionConfig {\n  /** Azure DevOps organization URL (default: https://dev.azure.com/UMGC) */\n  orgUrl?: string;\n  /** Project name (default: Digital Platforms) */\n  project?: string;\n  /** Skip auth validation (for testing) */\n  skipAuthValidation?: boolean;\n}\n\n/**\n * ADO connection with APIs\n */\nexport interface AdoConnection {\n  /** The WebApi connection */\n  connection: azdev.WebApi;\n  /** Organization URL */\n  orgUrl: string;\n  /** Project name */\n  project: string;\n  /** Get Work Item Tracking API */\n  getWorkItemTrackingApi: () => Promise<IWorkItemTrackingApi>;\n  /** Get Wiki API */\n  getWikiApi: () => Promise<IWikiApi>;\n  /** Get Core API */\n  getCoreApi: () => Promise<ICoreApi>;\n  /** Get Git API */\n  getGitApi: () => Promise<IGitApi>;\n}\n\n/**\n * Cached connection to avoid re-creating for each operation\n */\nlet cachedConnection: AdoConnection | null = null;\nlet cachedConfig: AdoConnectionConfig | null = null;\n\n/**\n * Check if config has changed\n */\nfunction configChanged(config: AdoConnectionConfig): boolean {\n  if (!cachedConfig) return true;\n  return (\n    config.orgUrl !== cachedConfig.orgUrl ||\n    config.project !== cachedConfig.project\n  );\n}\n\n/**\n * Create an authenticated connection to Azure DevOps\n * \n * @param config - Connection configuration\n * @returns ADO connection with APIs\n */\nexport async function createAdoConnection(\n  config: AdoConnectionConfig = {}\n): Promise<AdoConnection> {\n  const orgUrl = config.orgUrl ?? DEFAULT_ADO_ORG;\n  const project = config.project ?? DEFAULT_ADO_PROJECT;\n\n  // Return cached connection if config hasn't changed\n  if (cachedConnection && !configChanged(config)) {\n    logDebug('Using cached ADO connection');\n    return cachedConnection;\n  }\n\n  logInfo(`Creating ADO connection to ${orgUrl}`);\n\n  // Validate Azure CLI auth\n  if (!config.skipAuthValidation) {\n    validateAzureAuth();\n  }\n\n  // Get bearer token from Azure CLI\n  const token = getAzureBearerToken();\n  \n  // Create auth handler with bearer token\n  const authHandler = azdev.getBearerHandler(token);\n  \n  // Create connection\n  const connection = new azdev.WebApi(orgUrl, authHandler);\n\n  // Create the connection object\n  const adoConnection: AdoConnection = {\n    connection,\n    orgUrl,\n    project,\n    getWorkItemTrackingApi: () => connection.getWorkItemTrackingApi(),\n    getWikiApi: () => connection.getWikiApi(),\n    getCoreApi: () => connection.getCoreApi(),\n    getGitApi: () => connection.getGitApi(),\n  };\n\n  // Cache the connection\n  cachedConnection = adoConnection;\n  cachedConfig = { orgUrl, project };\n\n  logDebug('ADO connection created successfully');\n  return adoConnection;\n}\n\n/**\n * Clear the cached connection (useful for testing or forced refresh)\n */\nexport function clearAdoConnectionCache(): void {\n  cachedConnection = null;\n  cachedConfig = null;\n}\n\n/**\n * Get the Work Item Tracking API\n * Convenience function that creates connection if needed\n */\nexport async function getWorkItemTrackingApi(\n  config?: AdoConnectionConfig\n): Promise<IWorkItemTrackingApi> {\n  const conn = await createAdoConnection(config);\n  return conn.getWorkItemTrackingApi();\n}\n\n/**\n * Get the Wiki API\n * Convenience function that creates connection if needed\n */\nexport async function getWikiApi(\n  config?: AdoConnectionConfig\n): Promise<IWikiApi> {\n  const conn = await createAdoConnection(config);\n  return conn.getWikiApi();\n}\n\n/**\n * Get the Core API\n * Convenience function that creates connection if needed\n */\nexport async function getCoreApi(\n  config?: AdoConnectionConfig\n): Promise<ICoreApi> {\n  const conn = await createAdoConnection(config);\n  return conn.getCoreApi();\n}\n","/**\n * Azure CLI Authentication\n * Provides bearer token authentication using Azure CLI\n */\n\nimport { execSync } from 'child_process';\nimport { ADO_RESOURCE_ID } from '../types/adoFieldTypes.js';\n\n/**\n * Cache for bearer tokens to avoid repeated CLI calls\n */\ninterface TokenCache {\n  token: string;\n  expiresAt: number;\n}\n\nlet tokenCache: TokenCache | null = null;\nconst TOKEN_EXPIRY_BUFFER_MS = 5 * 60 * 1000; // 5 minutes before expiry\n\n/**\n * Get a bearer token for Azure DevOps using Azure CLI\n * \n * @returns Bearer token string\n * @throws Error if Azure CLI is not authenticated\n */\nexport function getAzureBearerToken(): string {\n  // Check cache first\n  if (tokenCache && Date.now() < tokenCache.expiresAt - TOKEN_EXPIRY_BUFFER_MS) {\n    return tokenCache.token;\n  }\n\n  try {\n    // Get token with expiry info\n    const result = execSync(\n      `az account get-access-token --resource ${ADO_RESOURCE_ID} --query \"{token:accessToken,expiresOn:expiresOn}\" -o json`,\n      { encoding: 'utf-8', stdio: ['pipe', 'pipe', 'pipe'] }\n    );\n\n    const parsed = JSON.parse(result) as { token: string; expiresOn: string };\n    const expiresAt = new Date(parsed.expiresOn).getTime();\n\n    // Cache the token\n    tokenCache = {\n      token: parsed.token,\n      expiresAt,\n    };\n\n    return parsed.token;\n  } catch (error) {\n    // Clear cache on error\n    tokenCache = null;\n\n    if (error instanceof Error) {\n      if (error.message.includes('az: command not found') || \n          error.message.includes('is not recognized')) {\n        throw new Error(\n          'Azure CLI is not installed. Please install it from: https://docs.microsoft.com/en-us/cli/azure/install-azure-cli'\n        );\n      }\n      if (error.message.includes('AADSTS') || \n          error.message.includes('Please run')) {\n        throw new Error(\n          'Azure CLI is not authenticated. Please run: az login'\n        );\n      }\n      throw new Error(`Failed to get Azure bearer token: ${error.message}`);\n    }\n    throw error;\n  }\n}\n\n/**\n * Validate that Azure CLI is authenticated\n * \n * @throws Error if Azure CLI is not installed or not authenticated\n */\nexport function validateAzureAuth(): void {\n  try {\n    execSync('az account show', { \n      encoding: 'utf-8', \n      stdio: ['pipe', 'pipe', 'pipe'] \n    });\n  } catch (error) {\n    if (error instanceof Error) {\n      if (error.message.includes('az: command not found') || \n          error.message.includes('is not recognized')) {\n        throw new Error(\n          'Azure CLI is not installed. Please install it from: https://docs.microsoft.com/en-us/cli/azure/install-azure-cli'\n        );\n      }\n      throw new Error(\n        'Azure CLI is not authenticated. Please run: az login'\n      );\n    }\n    throw error;\n  }\n}\n\n/**\n * Get the current Azure account information\n * \n * @returns Account information including subscription and tenant\n */\nexport function getAzureAccountInfo(): AzureAccountInfo {\n  validateAzureAuth();\n\n  const result = execSync(\n    'az account show --query \"{subscription:name,subscriptionId:id,tenantId:tenantId,user:user.name}\" -o json',\n    { encoding: 'utf-8', stdio: ['pipe', 'pipe', 'pipe'] }\n  );\n\n  return JSON.parse(result) as AzureAccountInfo;\n}\n\n/**\n * Azure account information\n */\nexport interface AzureAccountInfo {\n  subscription: string;\n  subscriptionId: string;\n  tenantId: string;\n  user: string;\n}\n\n/**\n * Clear the token cache (useful for testing or forced refresh)\n */\nexport function clearTokenCache(): void {\n  tokenCache = null;\n}\n","/**\n * Azure DevOps Field Types\n * Strongly-typed picklist values for ADO work item fields\n */\n\n// Work Class Type picklist values\nexport type WorkClassType =\n  | 'Critical/Escalation'\n  | 'Development'\n  | 'Fixed Date Delivery'\n  | 'Maintenance/Recurring Tasks'\n  | 'Standard';\n\n// Requires QA picklist values\nexport type RequiresQA = 'Yes' | 'No';\n\n// Priority picklist values\nexport type Priority = 1 | 2 | 3 | 4;\n\n// Severity picklist values\nexport type Severity = '1 - Critical' | '2 - High' | '3 - Medium' | '4 - Low';\n\n// State values for different work item types\nexport type UserStoryState =\n  | 'New'\n  | 'Active'\n  | 'Resolved'\n  | 'Closed'\n  | 'Removed';\n\nexport type TaskState =\n  | 'New'\n  | 'Active'\n  | 'Closed'\n  | 'Removed';\n\nexport type BugState =\n  | 'New'\n  | 'Active'\n  | 'Resolved'\n  | 'Closed';\n\n// Work item types\nexport type WorkItemType =\n  | 'User Story'\n  | 'Task'\n  | 'Bug'\n  | 'Feature'\n  | 'Epic'\n  | 'Issue'\n  | 'Test Case'\n  | 'Test Plan'\n  | 'Test Suite';\n\n// Value Area picklist\nexport type ValueArea = 'Business' | 'Architectural';\n\n// Risk picklist\nexport type Risk = '1 - High' | '2 - Medium' | '3 - Low';\n\n// Reason picklist values (common across types)\nexport type CommonReason =\n  | 'New'\n  | 'Build Failure'\n  | 'Implementation Started'\n  | 'Moved to the backlog'\n  | 'Moved out of the backlog';\n\n// Area Path type (for organizational structure)\nexport type AreaPath = string;\n\n// Iteration Path type (for sprint planning)\nexport type IterationPath = string;\n\n// Constants for ADO configuration\nexport const ADO_RESOURCE_ID = '499b84ac-1321-427f-aa17-267ca6975798';\nexport const DEFAULT_ADO_ORG = 'https://dev.azure.com/UMGC';\nexport const DEFAULT_ADO_PROJECT = 'Digital Platforms';\n\n// Field path constants\nexport const ADO_FIELDS = {\n  // System fields\n  ID: 'System.Id',\n  TITLE: 'System.Title',\n  DESCRIPTION: 'System.Description',\n  STATE: 'System.State',\n  REASON: 'System.Reason',\n  AREA_PATH: 'System.AreaPath',\n  ITERATION_PATH: 'System.IterationPath',\n  WORK_ITEM_TYPE: 'System.WorkItemType',\n  ASSIGNED_TO: 'System.AssignedTo',\n  CREATED_BY: 'System.CreatedBy',\n  CREATED_DATE: 'System.CreatedDate',\n  CHANGED_BY: 'System.ChangedBy',\n  CHANGED_DATE: 'System.ChangedDate',\n  TAGS: 'System.Tags',\n  HISTORY: 'System.History',\n  \n  // Microsoft VSTS Common fields\n  STORY_POINTS: 'Microsoft.VSTS.Scheduling.StoryPoints',\n  PRIORITY: 'Microsoft.VSTS.Common.Priority',\n  SEVERITY: 'Microsoft.VSTS.Common.Severity',\n  VALUE_AREA: 'Microsoft.VSTS.Common.ValueArea',\n  RISK: 'Microsoft.VSTS.Common.Risk',\n  ACCEPTANCE_CRITERIA: 'Microsoft.VSTS.Common.AcceptanceCriteria',\n  \n  // Microsoft VSTS TCM fields (Bug-specific)\n  REPRO_STEPS: 'Microsoft.VSTS.TCM.ReproSteps',\n  SYSTEM_INFO: 'Microsoft.VSTS.TCM.SystemInfo',\n  \n  // Custom fields\n  WORK_CLASS_TYPE: 'Custom.WorkClassType',\n  REQUIRES_QA: 'Custom.RequiresQA',\n  SF_COMPONENTS: 'Custom.SFComponents',\n  TECHNICAL_NOTES: 'Custom.TechnicalNotes',\n  ROOT_CAUSE_DETAIL: 'Custom.RootCauseDetail',\n} as const;\n","/**\n * Retry with Exponential Backoff\n * Provides resilient API calls with configurable retry logic\n */\n\nimport { logWarn, logError, logDebug } from './loggerStructured.js';\n\n/**\n * Retry options\n */\nexport interface RetryOptions {\n  /** Maximum number of retry attempts (default: 3) */\n  maxRetries?: number;\n  /** Initial delay in milliseconds (default: 1000) */\n  initialDelayMs?: number;\n  /** Maximum delay in milliseconds (default: 30000) */\n  maxDelayMs?: number;\n  /** Backoff multiplier (default: 2) */\n  backoffMultiplier?: number;\n  /** Jitter factor 0-1 to randomize delay (default: 0.1) */\n  jitterFactor?: number;\n  /** Custom function to determine if error is retryable */\n  isRetryable?: (error: unknown) => boolean;\n  /** Callback before each retry attempt */\n  onRetry?: (attempt: number, error: unknown, delayMs: number) => void;\n  /** Operation name for logging */\n  operationName?: string;\n}\n\n/**\n * Default retry options\n */\nconst DEFAULT_OPTIONS: Required<Omit<RetryOptions, 'isRetryable' | 'onRetry' | 'operationName'>> = {\n  maxRetries: 3,\n  initialDelayMs: 1000,\n  maxDelayMs: 30000,\n  backoffMultiplier: 2,\n  jitterFactor: 0.1,\n};\n\n/**\n * Calculate exponential delay with optional jitter\n */\nexport function exponentialDelay(\n  attempt: number,\n  initialDelayMs: number,\n  backoffMultiplier: number,\n  maxDelayMs: number,\n  jitterFactor: number\n): number {\n  // Calculate base delay with exponential backoff\n  const baseDelay = initialDelayMs * Math.pow(backoffMultiplier, attempt - 1);\n  \n  // Cap at max delay\n  const cappedDelay = Math.min(baseDelay, maxDelayMs);\n  \n  // Add jitter\n  const jitter = cappedDelay * jitterFactor * (Math.random() * 2 - 1);\n  \n  return Math.max(0, Math.round(cappedDelay + jitter));\n}\n\n/**\n * Default function to determine if an error is retryable\n */\nfunction defaultIsRetryable(error: unknown): boolean {\n  if (error instanceof Error) {\n    const message = error.message.toLowerCase();\n    const name = error.name.toLowerCase();\n    \n    // Network errors\n    if (message.includes('network') || \n        message.includes('timeout') ||\n        message.includes('econnreset') ||\n        message.includes('econnrefused') ||\n        message.includes('socket hang up')) {\n      return true;\n    }\n    \n    // Rate limiting\n    if (message.includes('rate limit') ||\n        message.includes('too many requests') ||\n        message.includes('429')) {\n      return true;\n    }\n    \n    // Temporary server errors\n    if (message.includes('502') ||\n        message.includes('503') ||\n        message.includes('504') ||\n        message.includes('service unavailable') ||\n        message.includes('internal server error')) {\n      return true;\n    }\n    \n    // Transient errors\n    if (name.includes('transient') ||\n        message.includes('temporarily')) {\n      return true;\n    }\n  }\n  \n  // Check for HTTP status codes on response objects\n  if (typeof error === 'object' && error !== null) {\n    const statusCode = (error as Record<string, unknown>)['statusCode'] ?? \n                       (error as Record<string, unknown>)['status'];\n    if (typeof statusCode === 'number') {\n      // Retry on 429, 502, 503, 504\n      return [429, 502, 503, 504].includes(statusCode);\n    }\n  }\n  \n  return false;\n}\n\n/**\n * Sleep for a specified duration\n */\nfunction sleep(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n/**\n * Execute a function with retry and exponential backoff\n * \n * @param fn - Async function to execute\n * @param options - Retry options\n * @returns Result of the function\n * @throws Last error if all retries fail\n */\nexport async function retryWithBackoff<T>(\n  fn: () => Promise<T>,\n  options: RetryOptions = {}\n): Promise<T> {\n  const {\n    maxRetries = DEFAULT_OPTIONS.maxRetries,\n    initialDelayMs = DEFAULT_OPTIONS.initialDelayMs,\n    maxDelayMs = DEFAULT_OPTIONS.maxDelayMs,\n    backoffMultiplier = DEFAULT_OPTIONS.backoffMultiplier,\n    jitterFactor = DEFAULT_OPTIONS.jitterFactor,\n    isRetryable = defaultIsRetryable,\n    onRetry,\n    operationName = 'operation',\n  } = options;\n\n  let lastError: unknown;\n  \n  for (let attempt = 1; attempt <= maxRetries + 1; attempt++) {\n    try {\n      logDebug(`${operationName}: attempt ${attempt}/${maxRetries + 1}`);\n      return await fn();\n    } catch (error) {\n      lastError = error;\n      \n      // Check if we've exhausted retries\n      if (attempt > maxRetries) {\n        logError(`${operationName}: all ${maxRetries} retries exhausted`, {\n          error: error instanceof Error ? error.message : String(error),\n        });\n        break;\n      }\n      \n      // Check if error is retryable\n      if (!isRetryable(error)) {\n        logError(`${operationName}: non-retryable error`, {\n          error: error instanceof Error ? error.message : String(error),\n        });\n        break;\n      }\n      \n      // Calculate delay\n      const delayMs = exponentialDelay(\n        attempt,\n        initialDelayMs,\n        backoffMultiplier,\n        maxDelayMs,\n        jitterFactor\n      );\n      \n      logWarn(`${operationName}: attempt ${attempt} failed, retrying in ${delayMs}ms`, {\n        error: error instanceof Error ? error.message : String(error),\n        attempt,\n        delayMs,\n      });\n      \n      // Call onRetry callback if provided\n      if (onRetry) {\n        onRetry(attempt, error, delayMs);\n      }\n      \n      // Wait before retrying\n      await sleep(delayMs);\n    }\n  }\n  \n  throw lastError;\n}\n\n/**\n * Create a retry wrapper for a function\n */\nexport function withRetry<T extends unknown[], R>(\n  fn: (...args: T) => Promise<R>,\n  options: RetryOptions = {}\n): (...args: T) => Promise<R> {\n  return (...args: T) => retryWithBackoff(() => fn(...args), options);\n}\n\n/**\n * Retry decorator options for specific error types\n */\nexport const RETRY_PRESETS = {\n  /** Quick retry for transient network issues */\n  quick: {\n    maxRetries: 2,\n    initialDelayMs: 500,\n    maxDelayMs: 2000,\n    backoffMultiplier: 2,\n  } satisfies RetryOptions,\n  \n  /** Standard retry for API calls */\n  standard: {\n    maxRetries: 3,\n    initialDelayMs: 1000,\n    maxDelayMs: 10000,\n    backoffMultiplier: 2,\n  } satisfies RetryOptions,\n  \n  /** Aggressive retry for critical operations */\n  aggressive: {\n    maxRetries: 5,\n    initialDelayMs: 1000,\n    maxDelayMs: 60000,\n    backoffMultiplier: 2,\n  } satisfies RetryOptions,\n  \n  /** Rate limit specific retry (longer delays) */\n  rateLimit: {\n    maxRetries: 3,\n    initialDelayMs: 5000,\n    maxDelayMs: 60000,\n    backoffMultiplier: 3,\n  } satisfies RetryOptions,\n} as const;\n","/**\n * Validation Schemas\n * Zod schemas for runtime validation of inputs\n */\n\nimport { z } from 'zod';\n\n// ============================================\n// Azure DevOps Schemas\n// ============================================\n\n/**\n * Work Class Type enum\n */\nexport const WorkClassTypeSchema = z.enum([\n  'Critical/Escalation',\n  'Development',\n  'Fixed Date Delivery',\n  'Maintenance/Recurring Tasks',\n  'Standard',\n]);\n\n/**\n * Requires QA enum\n */\nexport const RequiresQASchema = z.enum(['Yes', 'No']);\n\n/**\n * Priority enum\n */\nexport const PrioritySchema = z.union([\n  z.literal(1),\n  z.literal(2),\n  z.literal(3),\n  z.literal(4),\n]);\n\n/**\n * Work item type enum\n */\nexport const WorkItemTypeSchema = z.enum([\n  'User Story',\n  'Task',\n  'Bug',\n  'Feature',\n  'Epic',\n  'Issue',\n  'Test Case',\n  'Test Plan',\n  'Test Suite',\n]);\n\n/**\n * Link type alias enum\n */\nexport const LinkTypeAliasSchema = z.enum([\n  'parent',\n  'child',\n  'related',\n  'predecessor',\n  'successor',\n  'duplicate',\n  'affects',\n]);\n\n/**\n * Work item fields schema (partial - only commonly used fields)\n */\nexport const WorkItemFieldsSchema = z.object({\n  // System fields\n  'System.Title': z.string().optional(),\n  'System.Description': z.string().optional(),\n  'System.State': z.string().optional(),\n  'System.AreaPath': z.string().optional(),\n  'System.IterationPath': z.string().optional(),\n  'System.AssignedTo': z.string().optional(),\n  'System.Tags': z.string().optional(),\n  // Microsoft VSTS Common fields\n  'Microsoft.VSTS.Scheduling.StoryPoints': z.number().optional(),\n  'Microsoft.VSTS.Common.Priority': PrioritySchema.optional(),\n  'Microsoft.VSTS.Common.AcceptanceCriteria': z.string().optional(),\n  // Microsoft VSTS TCM fields (Bug-specific)\n  'Microsoft.VSTS.TCM.ReproSteps': z.string().optional(),\n  'Microsoft.VSTS.TCM.SystemInfo': z.string().optional(),\n  // Custom fields\n  'Custom.WorkClassType': WorkClassTypeSchema.optional(),\n  'Custom.RequiresQA': RequiresQASchema.optional(),\n  'Custom.SFComponents': z.string().optional(),\n  'Custom.TechnicalNotes': z.string().optional(),\n  'Custom.RootCauseDetail': z.string().optional(),\n}).passthrough(); // Allow additional fields\n\n/**\n * Get work item options schema\n */\nexport const GetWorkItemOptionsSchema = z.object({\n  expand: z.enum(['None', 'Relations', 'Fields', 'Links', 'All']).optional(),\n  includeComments: z.boolean().optional(),\n  fields: z.array(z.string()).optional(),\n});\n\n/**\n * Create work item options schema\n */\nexport const CreateWorkItemOptionsSchema = z.object({\n  type: WorkItemTypeSchema,\n  title: z.string().min(1),\n  description: z.string().optional(),\n  parentId: z.number().positive().optional(),\n  areaPath: z.string().optional(),\n  iterationPath: z.string().optional(),\n  assignedTo: z.string().optional(),\n  tags: z.array(z.string()).optional(),\n  additionalFields: WorkItemFieldsSchema.optional(),\n});\n\n/**\n * Update work item options schema\n */\nexport const UpdateWorkItemOptionsSchema = z.object({\n  fields: WorkItemFieldsSchema.optional(),\n  comment: z.string().optional(),\n});\n\n/**\n * Search work items options schema\n */\nexport const SearchWorkItemsOptionsSchema = z.object({\n  searchText: z.string().optional(),\n  wiql: z.string().optional(),\n  workItemType: WorkItemTypeSchema.optional(),\n  state: z.string().optional(),\n  assignedTo: z.string().optional(),\n  areaPath: z.string().optional(),\n  iterationPath: z.string().optional(),\n  tags: z.array(z.string()).optional(),\n  top: z.number().positive().optional(),\n});\n\n/**\n * Link work items options schema\n */\nexport const LinkWorkItemsOptionsSchema = z.object({\n  sourceId: z.number().positive(),\n  targetId: z.number().positive(),\n  linkType: LinkTypeAliasSchema,\n  comment: z.string().optional(),\n});\n\n// ============================================\n// Salesforce Schemas\n// ============================================\n\n/**\n * Query options schema\n */\nexport const QueryOptionsSchema = z.object({\n  query: z.string().min(1),\n  useToolingApi: z.boolean().optional(),\n  allRows: z.boolean().optional(),\n  maxRecords: z.number().positive().optional(),\n});\n\n/**\n * Dependency discovery options schema\n */\nexport const MetadataTypeSchema = z.enum([\n  'CustomObject',\n  'CustomField',\n  'ApexClass',\n  'ApexTrigger',\n  'ApexPage',\n  'ApexComponent',\n  'AuraDefinitionBundle',\n  'LightningComponentBundle',\n  'Flow',\n  'FlowDefinition',\n  'ValidationRule',\n  'WorkflowRule',\n  'WorkflowFieldUpdate',\n  'WorkflowAlert',\n  'ProcessBuilder',\n  'CustomMetadataType',\n  'CustomSetting',\n  'CustomLabel',\n  'Layout',\n  'RecordType',\n  'FieldSet',\n  'CompactLayout',\n  'ListView',\n  'Report',\n  'Dashboard',\n  'PermissionSet',\n  'Profile',\n  'Unknown',\n]);\n\nexport const DiscoverDependenciesOptionsSchema = z.object({\n  rootType: MetadataTypeSchema,\n  rootName: z.string().min(1),\n  maxDepth: z.number().positive().optional(),\n  includeStandardObjects: z.boolean().optional(),\n  includeNamespaced: z.boolean().optional(),\n  excludeTypes: z.array(MetadataTypeSchema).optional(),\n  parallelQueries: z.number().positive().optional(),\n});\n\n// ============================================\n// Workflow Schemas\n// ============================================\n\n/**\n * Workflow status schema\n */\nexport const WorkflowStatusSchema = z.enum([\n  'pending',\n  'in_progress',\n  'paused',\n  'completed',\n  'failed',\n  'cancelled',\n]);\n\n/**\n * Workflow execution options schema\n */\nexport const WorkflowExecutionOptionsSchema = z.object({\n  workItemId: z.number().positive(),\n  phases: z.array(z.string()).optional(),\n  steps: z.array(z.string()).optional(),\n  dryRun: z.boolean().optional(),\n  verbose: z.boolean().optional(),\n  continueOnError: z.boolean().optional(),\n});\n\n// ============================================\n// Validation Helpers\n// ============================================\n\n/**\n * Validate data against a schema and return typed result\n */\nexport function validate<T>(schema: z.ZodSchema<T>, data: unknown): T {\n  return schema.parse(data);\n}\n\n/**\n * Safely validate data, returning result or undefined\n */\nexport function safeValidate<T>(schema: z.ZodSchema<T>, data: unknown): T | undefined {\n  const result = schema.safeParse(data);\n  return result.success ? result.data : undefined;\n}\n\n/**\n * Get validation errors as a formatted string\n */\nexport function getValidationErrors(schema: z.ZodSchema, data: unknown): string[] {\n  const result = schema.safeParse(data);\n  if (result.success) {\n    return [];\n  }\n  return result.error.errors.map(e => `${e.path.join('.')}: ${e.message}`);\n}\n","/**\n * Configuration Loader\n * Loads and validates configuration files\n */\n\nimport { readFileSync, existsSync } from 'fs';\nimport { resolve, dirname } from 'path';\nimport { fileURLToPath } from 'url';\nimport type { SharedConfig, TemplateVariables, StepManifest } from '../types/configTypes.js';\n\n/**\n * Get the project root directory (where .github lives)\n */\nexport function getProjectRoot(): string {\n  // Try to find .github relative to cwd or script location\n  const possibleRoots = [\n    process.cwd(),\n    resolve(process.cwd(), '..'),\n    resolve(process.cwd(), '..', '..'),\n    resolve(dirname(fileURLToPath(import.meta.url)), '..', '..', '..', '..'),\n  ];\n  \n  for (const root of possibleRoots) {\n    if (existsSync(resolve(root, 'config', 'shared.json'))) {\n      return root;\n    }\n  }\n  \n  // Default to cwd\n  return process.cwd();\n}\n\n/**\n * Get the base directory for config files\n */\nfunction getConfigDir(): string {\n  return resolve(getProjectRoot(), 'config');\n}\n\n/**\n * Load and parse a JSON file\n */\nfunction loadJsonFile<T>(filePath: string): T {\n  if (!existsSync(filePath)) {\n    throw new Error(`Configuration file not found: ${filePath}`);\n  }\n  \n  try {\n    const content = readFileSync(filePath, 'utf-8');\n    return JSON.parse(content) as T;\n  } catch (error) {\n    if (error instanceof SyntaxError) {\n      throw new Error(`Invalid JSON in ${filePath}: ${error.message}`);\n    }\n    throw error;\n  }\n}\n\n/**\n * Load the shared configuration\n * \n * @param configPath - Optional explicit path to shared.json\n * @returns Shared configuration object\n */\nexport function loadSharedConfig(configPath?: string): SharedConfig {\n  const path = configPath ?? resolve(getConfigDir(), 'shared.json');\n  return loadJsonFile<SharedConfig>(path);\n}\n\n/**\n * Load template variables\n * \n * @param configPath - Optional explicit path to template-variables.json\n * @returns Template variables object\n */\nexport function loadTemplateVariables(configPath?: string): TemplateVariables {\n  const path = configPath ?? resolve(getConfigDir(), 'template-variables.json');\n  \n  // Template variables might not exist, return empty object\n  if (!existsSync(path)) {\n    return {};\n  }\n  \n  return loadJsonFile<TemplateVariables>(path);\n}\n\n/**\n * Load step manifests\n * \n * @param configPath - Optional explicit path to step-manifests.json\n * @returns Array of step manifests\n */\nexport function loadStepManifests(configPath?: string): StepManifest[] {\n  const path = configPath ?? resolve(getConfigDir(), 'step-manifests.json');\n  const data = loadJsonFile<{ steps: StepManifest[] } | StepManifest[]>(path);\n  \n  // Handle both array and object with steps property\n  if (Array.isArray(data)) {\n    return data;\n  }\n  return data.steps;\n}\n\n/**\n * Load a specific step manifest by ID\n * \n * @param stepId - Step ID to find\n * @param configPath - Optional explicit path to step-manifests.json\n * @returns Step manifest or undefined\n */\nexport function loadStepManifest(stepId: string, configPath?: string): StepManifest | undefined {\n  const manifests = loadStepManifests(configPath);\n  return manifests.find(m => m.id === stepId);\n}\n\n/**\n * Get a CLI command from shared config\n * \n * @param commandKey - Key of the command to get\n * @param configPath - Optional explicit path to shared.json\n * @returns Command string\n */\nexport function getCliCommand(\n  commandKey: keyof SharedConfig['cli_commands'],\n  configPath?: string\n): string {\n  const config = loadSharedConfig(configPath);\n  const command = config.cli_commands[commandKey];\n  \n  if (!command) {\n    throw new Error(`CLI command not found: ${commandKey}`);\n  }\n  \n  return command;\n}\n\n/**\n * Resolve template variables in a string\n * \n * @param template - Template string with {{variable}} placeholders\n * @param variables - Variables to substitute\n * @returns Resolved string\n */\nexport function resolveTemplate(template: string, variables: TemplateVariables): string {\n  return template.replace(/\\{\\{(\\w+)\\}\\}/g, (match, key: string) => {\n    const value = variables[key];\n    if (value === undefined) {\n      return match; // Leave unresolved placeholders as-is\n    }\n    return String(value);\n  });\n}\n\n/**\n * Merge template variables with defaults\n * \n * @param base - Base variables\n * @param overrides - Override variables\n * @returns Merged variables\n */\nexport function mergeVariables(\n  base: TemplateVariables,\n  overrides: TemplateVariables\n): TemplateVariables {\n  return { ...base, ...overrides };\n}\n\n/**\n * Get the path to a prompt file\n * \n * @param promptName - Name of the prompt (without extension)\n * @returns Full path to the prompt file\n */\nexport function getPromptPath(promptName: string): string {\n  const promptsDir = resolve(getConfigDir(), '..', 'prompts');\n  return resolve(promptsDir, `${promptName}.prompt.md`);\n}\n\n/**\n * Get the path to a template file\n * \n * @param templateName - Name of the template\n * @returns Full path to the template file\n */\nexport function getTemplatePath(templateName: string): string {\n  // Templates are in .github/templates\n  const templatesDir = resolve(getConfigDir(), '..', 'templates');\n  return resolve(templatesDir, templateName);\n}\n\n/**\n * Get the path to a standards file\n * \n * @param standardName - Name of the standard\n * @returns Full path to the standards file\n */\nexport function getStandardPath(standardName: string): string {\n  // Standards are in .github/standards\n  const standardsDir = resolve(getConfigDir(), '..', 'standards');\n  return resolve(standardsDir, standardName);\n}\n"],"mappings":"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","names":["existsSync","readFileSync","resolve","config","resolve","config","config","resolve","existsSync","result","readFileSync"]}